// src/mcp/client.ts
import { jsonSchema } from "ai";
import { nanoid as nanoid2 } from "nanoid";

// src/core/events.ts
function toDisposable(fn) {
  return { dispose: fn };
}
var DisposableStore = class {
  constructor() {
    this._items = [];
  }
  add(d) {
    this._items.push(d);
    return d;
  }
  dispose() {
    while (this._items.length) {
      try {
        this._items.pop().dispose();
      } catch {
      }
    }
  }
};
var Emitter = class {
  constructor() {
    this._listeners = /* @__PURE__ */ new Set();
    this.event = (listener) => {
      this._listeners.add(listener);
      return toDisposable(() => this._listeners.delete(listener));
    };
  }
  fire(data) {
    for (const listener of [...this._listeners]) {
      try {
        listener(data);
      } catch (err) {
        console.error("Emitter listener error:", err);
      }
    }
  }
  dispose() {
    this._listeners.clear();
  }
};

// src/mcp/client-connection.ts
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import {
  ElicitRequestSchema,
  PromptListChangedNotificationSchema,
  ResourceListChangedNotificationSchema,
  ToolListChangedNotificationSchema
} from "@modelcontextprotocol/sdk/types.js";
import { nanoid } from "nanoid";

// src/mcp/errors.ts
function toErrorMessage(error) {
  return error instanceof Error ? error.message : String(error);
}
function isUnauthorized(error) {
  const msg = toErrorMessage(error);
  return msg.includes("Unauthorized") || msg.includes("401");
}
function isTransportNotImplemented(error) {
  const msg = toErrorMessage(error);
  return msg.includes("404") || msg.includes("405") || msg.includes("Not Implemented") || msg.includes("not implemented");
}

// src/mcp/sse-edge.ts
import {
  SSEClientTransport
} from "@modelcontextprotocol/sdk/client/sse.js";
var SSEEdgeClientTransport = class extends SSEClientTransport {
  /**
   * Creates a new EdgeSSEClientTransport, which overrides fetch to be compatible with the CF workers environment
   */
  constructor(url, options) {
    const fetchOverride = async (fetchUrl, fetchInit = {}) => {
      const headers = await this.authHeaders();
      const workerOptions = {
        ...fetchInit,
        headers: {
          ...options.requestInit?.headers,
          ...fetchInit?.headers,
          ...headers
        }
      };
      delete workerOptions.mode;
      return options.eventSourceInit?.fetch?.(
        fetchUrl,
        // @ts-expect-error Expects FetchLikeInit from EventSource but is compatible with RequestInit
        workerOptions
      ) || fetch(fetchUrl, workerOptions);
    };
    super(url, {
      ...options,
      eventSourceInit: {
        ...options.eventSourceInit,
        fetch: fetchOverride
      }
    });
    this.authProvider = options.authProvider;
  }
  async authHeaders() {
    if (this.authProvider) {
      const tokens = await this.authProvider.tokens();
      if (tokens) {
        return {
          Authorization: `Bearer ${tokens.access_token}`
        };
      }
    }
  }
};

// src/mcp/streamable-http-edge.ts
import {
  StreamableHTTPClientTransport
} from "@modelcontextprotocol/sdk/client/streamableHttp.js";
var StreamableHTTPEdgeClientTransport = class extends StreamableHTTPClientTransport {
  /**
   * Creates a new StreamableHTTPEdgeClientTransport, which overrides fetch to be compatible with the CF workers environment
   */
  constructor(url, options) {
    const fetchOverride = async (fetchUrl, fetchInit = {}) => {
      const headers = await this.authHeaders();
      const workerOptions = {
        ...fetchInit,
        headers: {
          ...options.requestInit?.headers,
          ...fetchInit?.headers,
          ...headers
        }
      };
      delete workerOptions.mode;
      return (
        // @ts-expect-error Custom fetch function for Cloudflare Workers compatibility
        options.requestInit?.fetch?.(
          fetchUrl,
          workerOptions
        ) || fetch(fetchUrl, workerOptions)
      );
    };
    super(url, {
      ...options,
      requestInit: {
        ...options.requestInit,
        // @ts-expect-error Custom fetch override for Cloudflare Workers
        fetch: fetchOverride
      }
    });
    this.authProvider = options.authProvider;
  }
  async authHeaders() {
    if (this.authProvider) {
      const tokens = await this.authProvider.tokens();
      if (tokens) {
        return {
          Authorization: `Bearer ${tokens.access_token}`
        };
      }
    }
  }
};

// src/mcp/client-connection.ts
var MCPClientConnection = class {
  constructor(url, info, options = { client: {}, transport: {} }) {
    this.url = url;
    this.options = options;
    this.connectionState = "connecting";
    this.tools = [];
    this.prompts = [];
    this.resources = [];
    this.resourceTemplates = [];
    this._onObservabilityEvent = new Emitter();
    this.onObservabilityEvent = this._onObservabilityEvent.event;
    const clientOptions = {
      ...options.client,
      capabilities: {
        ...options.client?.capabilities,
        elicitation: {}
      }
    };
    this.client = new Client(info, clientOptions);
  }
  /**
   * Initialize a client connection
   *
   * @returns
   */
  async init() {
    const transportType = this.options.transport.type;
    if (!transportType) {
      throw new Error("Transport type must be specified");
    }
    try {
      await this.tryConnect(transportType);
    } catch (e) {
      if (isUnauthorized(e)) {
        this.connectionState = "authenticating";
        return;
      }
      this._onObservabilityEvent.fire({
        type: "mcp:client:connect",
        displayMessage: `Connection initialization failed for ${this.url.toString()}`,
        payload: {
          url: this.url.toString(),
          transport: transportType,
          state: this.connectionState,
          error: toErrorMessage(e)
        },
        timestamp: Date.now(),
        id: nanoid()
      });
      this.connectionState = "failed";
      return;
    }
    await this.discoverAndRegister();
  }
  /**
   * Finish OAuth by probing transports based on configured type.
   * - Explicit: finish on that transport
   * - Auto: try streamable-http, then sse on 404/405/Not Implemented
   */
  async finishAuthProbe(code) {
    if (!this.options.transport.authProvider) {
      throw new Error("No auth provider configured");
    }
    const configuredType = this.options.transport.type;
    if (!configuredType) {
      throw new Error("Transport type must be specified");
    }
    const finishAuth = async (base) => {
      const transport = this.getTransport(base);
      await transport.finishAuth(code);
    };
    if (configuredType === "sse" || configuredType === "streamable-http") {
      await finishAuth(configuredType);
      return;
    }
    try {
      await finishAuth("streamable-http");
    } catch (e) {
      if (isTransportNotImplemented(e)) {
        await finishAuth("sse");
        return;
      }
      throw e;
    }
  }
  /**
   * Complete OAuth authorization
   */
  async completeAuthorization(code) {
    if (this.connectionState !== "authenticating") {
      throw new Error(
        "Connection must be in authenticating state to complete authorization"
      );
    }
    try {
      await this.finishAuthProbe(code);
      this.connectionState = "connecting";
    } catch (error) {
      this.connectionState = "failed";
      throw error;
    }
  }
  /**
   * Establish connection after successful authorization
   */
  async establishConnection() {
    if (this.connectionState !== "connecting") {
      throw new Error(
        "Connection must be in connecting state to establish connection"
      );
    }
    try {
      const transportType = this.options.transport.type;
      if (!transportType) {
        throw new Error("Transport type must be specified");
      }
      await this.tryConnect(transportType);
      await this.discoverAndRegister();
    } catch (error) {
      this.connectionState = "failed";
      throw error;
    }
  }
  /**
   * Discover server capabilities and register tools, resources, prompts, and templates
   */
  async discoverAndRegister() {
    this.connectionState = "discovering";
    this.serverCapabilities = this.client.getServerCapabilities();
    if (!this.serverCapabilities) {
      throw new Error("The MCP Server failed to return server capabilities");
    }
    const [
      instructionsResult,
      toolsResult,
      resourcesResult,
      promptsResult,
      resourceTemplatesResult
    ] = await Promise.allSettled([
      this.client.getInstructions(),
      this.registerTools(),
      this.registerResources(),
      this.registerPrompts(),
      this.registerResourceTemplates()
    ]);
    const operations = [
      { name: "instructions", result: instructionsResult },
      { name: "tools", result: toolsResult },
      { name: "resources", result: resourcesResult },
      { name: "prompts", result: promptsResult },
      { name: "resource templates", result: resourceTemplatesResult }
    ];
    for (const { name, result } of operations) {
      if (result.status === "rejected") {
        const url = this.url.toString();
        this._onObservabilityEvent.fire({
          type: "mcp:client:discover",
          displayMessage: `Failed to discover ${name} for ${url}`,
          payload: {
            url,
            capability: name,
            error: result.reason
          },
          timestamp: Date.now(),
          id: nanoid()
        });
      }
    }
    this.instructions = instructionsResult.status === "fulfilled" ? instructionsResult.value : void 0;
    this.tools = toolsResult.status === "fulfilled" ? toolsResult.value : [];
    this.resources = resourcesResult.status === "fulfilled" ? resourcesResult.value : [];
    this.prompts = promptsResult.status === "fulfilled" ? promptsResult.value : [];
    this.resourceTemplates = resourceTemplatesResult.status === "fulfilled" ? resourceTemplatesResult.value : [];
    this.connectionState = "ready";
  }
  /**
   * Notification handler registration
   */
  async registerTools() {
    if (!this.serverCapabilities || !this.serverCapabilities.tools) {
      return [];
    }
    if (this.serverCapabilities.tools.listChanged) {
      this.client.setNotificationHandler(
        ToolListChangedNotificationSchema,
        async (_notification) => {
          this.tools = await this.fetchTools();
        }
      );
    }
    return this.fetchTools();
  }
  async registerResources() {
    if (!this.serverCapabilities || !this.serverCapabilities.resources) {
      return [];
    }
    if (this.serverCapabilities.resources.listChanged) {
      this.client.setNotificationHandler(
        ResourceListChangedNotificationSchema,
        async (_notification) => {
          this.resources = await this.fetchResources();
        }
      );
    }
    return this.fetchResources();
  }
  async registerPrompts() {
    if (!this.serverCapabilities || !this.serverCapabilities.prompts) {
      return [];
    }
    if (this.serverCapabilities.prompts.listChanged) {
      this.client.setNotificationHandler(
        PromptListChangedNotificationSchema,
        async (_notification) => {
          this.prompts = await this.fetchPrompts();
        }
      );
    }
    return this.fetchPrompts();
  }
  async registerResourceTemplates() {
    if (!this.serverCapabilities || !this.serverCapabilities.resources) {
      return [];
    }
    return this.fetchResourceTemplates();
  }
  async fetchTools() {
    let toolsAgg = [];
    let toolsResult = { tools: [] };
    do {
      toolsResult = await this.client.listTools({
        cursor: toolsResult.nextCursor
      }).catch(this._capabilityErrorHandler({ tools: [] }, "tools/list"));
      toolsAgg = toolsAgg.concat(toolsResult.tools);
    } while (toolsResult.nextCursor);
    return toolsAgg;
  }
  async fetchResources() {
    let resourcesAgg = [];
    let resourcesResult = { resources: [] };
    do {
      resourcesResult = await this.client.listResources({
        cursor: resourcesResult.nextCursor
      }).catch(
        this._capabilityErrorHandler({ resources: [] }, "resources/list")
      );
      resourcesAgg = resourcesAgg.concat(resourcesResult.resources);
    } while (resourcesResult.nextCursor);
    return resourcesAgg;
  }
  async fetchPrompts() {
    let promptsAgg = [];
    let promptsResult = { prompts: [] };
    do {
      promptsResult = await this.client.listPrompts({
        cursor: promptsResult.nextCursor
      }).catch(this._capabilityErrorHandler({ prompts: [] }, "prompts/list"));
      promptsAgg = promptsAgg.concat(promptsResult.prompts);
    } while (promptsResult.nextCursor);
    return promptsAgg;
  }
  async fetchResourceTemplates() {
    let templatesAgg = [];
    let templatesResult = {
      resourceTemplates: []
    };
    do {
      templatesResult = await this.client.listResourceTemplates({
        cursor: templatesResult.nextCursor
      }).catch(
        this._capabilityErrorHandler(
          { resourceTemplates: [] },
          "resources/templates/list"
        )
      );
      templatesAgg = templatesAgg.concat(templatesResult.resourceTemplates);
    } while (templatesResult.nextCursor);
    return templatesAgg;
  }
  /**
   * Handle elicitation request from server
   * Automatically uses the Agent's built-in elicitation handling if available
   */
  async handleElicitationRequest(_request) {
    throw new Error(
      "Elicitation handler must be implemented for your platform. Override handleElicitationRequest method."
    );
  }
  /**
   * Get the transport for the client
   * @param transportType - The transport type to get
   * @returns The transport for the client
   */
  getTransport(transportType) {
    switch (transportType) {
      case "streamable-http":
        return new StreamableHTTPEdgeClientTransport(
          this.url,
          this.options.transport
        );
      case "sse":
        return new SSEEdgeClientTransport(
          this.url,
          this.options.transport
        );
      default:
        throw new Error(`Unsupported transport type: ${transportType}`);
    }
  }
  async tryConnect(transportType) {
    const transports = transportType === "auto" ? ["streamable-http", "sse"] : [transportType];
    for (const currentTransportType of transports) {
      const isLastTransport = currentTransportType === transports[transports.length - 1];
      const hasFallback = transportType === "auto" && currentTransportType === "streamable-http" && !isLastTransport;
      const transport = this.getTransport(currentTransportType);
      try {
        await this.client.connect(transport);
        this.lastConnectedTransport = currentTransportType;
        const url = this.url.toString();
        this._onObservabilityEvent.fire({
          type: "mcp:client:connect",
          displayMessage: `Connected successfully using ${currentTransportType} transport for ${url}`,
          payload: {
            url,
            transport: currentTransportType,
            state: this.connectionState
          },
          timestamp: Date.now(),
          id: nanoid()
        });
        break;
      } catch (e) {
        const error = e instanceof Error ? e : new Error(String(e));
        if (isUnauthorized(error)) {
          throw e;
        }
        if (hasFallback && isTransportNotImplemented(error)) {
          const url = this.url.toString();
          this._onObservabilityEvent.fire({
            type: "mcp:client:connect",
            displayMessage: `${currentTransportType} transport not available, trying ${transports[transports.indexOf(currentTransportType) + 1]} for ${url}`,
            payload: {
              url,
              transport: currentTransportType,
              state: this.connectionState
            },
            timestamp: Date.now(),
            id: nanoid()
          });
          continue;
        }
        throw e;
      }
    }
    this.client.setRequestHandler(
      ElicitRequestSchema,
      async (request) => {
        return await this.handleElicitationRequest(request);
      }
    );
  }
  _capabilityErrorHandler(empty, method) {
    return (e) => {
      if (e.code === -32601) {
        const url = this.url.toString();
        this._onObservabilityEvent.fire({
          type: "mcp:client:discover",
          displayMessage: `The server advertised support for the capability ${method.split("/")[0]}, but returned "Method not found" for '${method}' for ${url}`,
          payload: {
            url,
            capability: method.split("/")[0],
            error: toErrorMessage(e)
          },
          timestamp: Date.now(),
          id: nanoid()
        });
        return empty;
      }
      throw e;
    };
  }
};

// src/mcp/client.ts
var MCPClientManager = class {
  /**
   * @param _name Name of the MCP client
   * @param _version Version of the MCP Client
   * @param auth Auth paramters if being used to create a DurableObjectOAuthClientProvider
   */
  constructor(_name, _version) {
    this._name = _name;
    this._version = _version;
    this.mcpConnections = {};
    this._callbackUrls = [];
    this._didWarnAboutUnstableGetAITools = false;
    this._connectionDisposables = /* @__PURE__ */ new Map();
    this._onObservabilityEvent = new Emitter();
    this.onObservabilityEvent = this._onObservabilityEvent.event;
    this._onConnected = new Emitter();
    this.onConnected = this._onConnected.event;
  }
  /**
   * Connect to and register an MCP server
   *
   * @param transportConfig Transport config
   * @param clientConfig Client config
   * @param capabilities Client capabilities (i.e. if the client supports roots/sampling)
   */
  async connect(url, options = {}) {
    const id = options.reconnect?.id ?? nanoid2(8);
    if (options.transport?.authProvider) {
      options.transport.authProvider.serverId = id;
      if (options.reconnect?.oauthClientId) {
        options.transport.authProvider.clientId = options.reconnect?.oauthClientId;
      }
    }
    if (!options.reconnect?.oauthCode || !this.mcpConnections[id]) {
      const normalizedTransport = {
        ...options.transport,
        type: options.transport?.type ?? "auto"
      };
      this.mcpConnections[id] = new MCPClientConnection(
        new URL(url),
        {
          name: this._name,
          version: this._version
        },
        {
          client: options.client ?? {},
          transport: normalizedTransport
        }
      );
      const store = new DisposableStore();
      const existing = this._connectionDisposables.get(id);
      if (existing) existing.dispose();
      this._connectionDisposables.set(id, store);
      store.add(
        this.mcpConnections[id].onObservabilityEvent((event) => {
          this._onObservabilityEvent.fire(event);
        })
      );
    }
    await this.mcpConnections[id].init();
    if (options.reconnect?.oauthCode) {
      try {
        await this.mcpConnections[id].completeAuthorization(
          options.reconnect.oauthCode
        );
        await this.mcpConnections[id].establishConnection();
      } catch (error) {
        this._onObservabilityEvent.fire({
          type: "mcp:client:connect",
          displayMessage: `Failed to complete OAuth reconnection for ${id} for ${url}`,
          payload: {
            url,
            transport: options.transport?.type ?? "auto",
            state: this.mcpConnections[id].connectionState,
            error: toErrorMessage(error)
          },
          timestamp: Date.now(),
          id
        });
        throw error;
      }
    }
    const authUrl = options.transport?.authProvider?.authUrl;
    if (this.mcpConnections[id].connectionState === "authenticating" && authUrl && options.transport?.authProvider?.redirectUrl) {
      this._callbackUrls.push(
        options.transport.authProvider.redirectUrl.toString()
      );
      return {
        authUrl,
        clientId: options.transport?.authProvider?.clientId,
        id
      };
    }
    return {
      id
    };
  }
  isCallbackRequest(req) {
    return req.method === "GET" && !!this._callbackUrls.find((url) => {
      return req.url.startsWith(url);
    });
  }
  async handleCallbackRequest(req) {
    const url = new URL(req.url);
    const urlMatch = this._callbackUrls.find((url2) => {
      return req.url.startsWith(url2);
    });
    if (!urlMatch) {
      throw new Error(
        `No callback URI match found for the request url: ${req.url}. Was the request matched with \`isCallbackRequest()\`?`
      );
    }
    const code = url.searchParams.get("code");
    const state = url.searchParams.get("state");
    const urlParams = urlMatch.split("/");
    const serverId = urlParams[urlParams.length - 1];
    if (!code) {
      throw new Error("Unauthorized: no code provided");
    }
    if (!state) {
      throw new Error("Unauthorized: no state provided");
    }
    if (this.mcpConnections[serverId] === void 0) {
      throw new Error(`Could not find serverId: ${serverId}`);
    }
    if (this.mcpConnections[serverId].connectionState !== "authenticating") {
      throw new Error(
        "Failed to authenticate: the client isn't in the `authenticating` state"
      );
    }
    const conn = this.mcpConnections[serverId];
    if (!conn.options.transport.authProvider) {
      throw new Error(
        "Trying to finalize authentication for a server connection without an authProvider"
      );
    }
    const clientId = conn.options.transport.authProvider.clientId || state;
    conn.options.transport.authProvider.clientId = clientId;
    conn.options.transport.authProvider.serverId = serverId;
    try {
      await conn.completeAuthorization(code);
      return {
        serverId,
        authSuccess: true
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return {
        serverId,
        authSuccess: false,
        authError: errorMessage
      };
    }
  }
  /**
   * Establish connection in the background after OAuth completion
   * This method is called asynchronously and doesn't block the OAuth callback response
   * @param serverId The server ID to establish connection for
   */
  async establishConnection(serverId) {
    const conn = this.mcpConnections[serverId];
    if (!conn) {
      this._onObservabilityEvent.fire({
        type: "mcp:client:preconnect",
        displayMessage: `Connection not found for serverId: ${serverId}`,
        payload: { serverId },
        timestamp: Date.now(),
        id: nanoid2()
      });
      return;
    }
    try {
      await conn.establishConnection();
      this._onConnected.fire(serverId);
    } catch (error) {
      const url = conn.url.toString();
      this._onObservabilityEvent.fire({
        type: "mcp:client:connect",
        displayMessage: `Failed to establish connection to server ${serverId} with url ${url}`,
        payload: {
          url,
          transport: conn.options.transport.type ?? "auto",
          state: conn.connectionState,
          error: toErrorMessage(error)
        },
        timestamp: Date.now(),
        id: nanoid2()
      });
    }
  }
  /**
   * Register a callback URL for OAuth handling
   * @param url The callback URL to register
   */
  registerCallbackUrl(url) {
    if (!this._callbackUrls.includes(url)) {
      this._callbackUrls.push(url);
    }
  }
  /**
   * Unregister a callback URL
   * @param serverId The server ID whose callback URL should be removed
   */
  unregisterCallbackUrl(serverId) {
    this._callbackUrls = this._callbackUrls.filter(
      (url) => !url.endsWith(`/${serverId}`)
    );
  }
  /**
   * Configure OAuth callback handling
   * @param config OAuth callback configuration
   */
  configureOAuthCallback(config) {
    this._oauthCallbackConfig = config;
  }
  /**
   * Get the current OAuth callback configuration
   * @returns The current OAuth callback configuration
   */
  getOAuthCallbackConfig() {
    return this._oauthCallbackConfig;
  }
  /**
   * @returns namespaced list of tools
   */
  listTools() {
    return getNamespacedData(this.mcpConnections, "tools");
  }
  /**
   * @returns a set of tools that you can use with the AI SDK
   */
  getAITools() {
    return Object.fromEntries(
      getNamespacedData(this.mcpConnections, "tools").map((tool) => {
        return [
          `tool_${tool.serverId.replace(/-/g, "")}_${tool.name}`,
          {
            description: tool.description,
            execute: async (args) => {
              const result = await this.callTool({
                arguments: args,
                name: tool.name,
                serverId: tool.serverId
              });
              if (result.isError) {
                throw new Error(result.content[0].text);
              }
              return result;
            },
            // @ts-expect-error drift between ai and mcp types
            inputSchema: jsonSchema(tool.inputSchema),
            outputSchema: tool.outputSchema ? (
              // @ts-expect-error drift between ai and mcp types
              jsonSchema(tool.outputSchema)
            ) : void 0
          }
        ];
      })
    );
  }
  /**
   * @deprecated this has been renamed to getAITools(), and unstable_getAITools will be removed in the next major version
   * @returns a set of tools that you can use with the AI SDK
   */
  unstable_getAITools() {
    if (!this._didWarnAboutUnstableGetAITools) {
      this._didWarnAboutUnstableGetAITools = true;
      console.warn(
        "unstable_getAITools is deprecated, use getAITools instead. unstable_getAITools will be removed in the next major version."
      );
    }
    return this.getAITools();
  }
  /**
   * Closes all connections to MCP servers
   */
  async closeAllConnections() {
    const ids = Object.keys(this.mcpConnections);
    await Promise.all(
      ids.map(async (id) => {
        await this.mcpConnections[id].client.close();
      })
    );
    for (const id of ids) {
      const store = this._connectionDisposables.get(id);
      if (store) store.dispose();
      this._connectionDisposables.delete(id);
      delete this.mcpConnections[id];
    }
  }
  /**
   * Closes a connection to an MCP server
   * @param id The id of the connection to close
   */
  async closeConnection(id) {
    if (!this.mcpConnections[id]) {
      throw new Error(`Connection with id "${id}" does not exist.`);
    }
    await this.mcpConnections[id].client.close();
    delete this.mcpConnections[id];
    const store = this._connectionDisposables.get(id);
    if (store) store.dispose();
    this._connectionDisposables.delete(id);
  }
  /**
   * Dispose the manager and all resources.
   */
  async dispose() {
    try {
      await this.closeAllConnections();
    } finally {
      this._onConnected.dispose();
      this._onObservabilityEvent.dispose();
    }
  }
  /**
   * @returns namespaced list of prompts
   */
  listPrompts() {
    return getNamespacedData(this.mcpConnections, "prompts");
  }
  /**
   * @returns namespaced list of tools
   */
  listResources() {
    return getNamespacedData(this.mcpConnections, "resources");
  }
  /**
   * @returns namespaced list of resource templates
   */
  listResourceTemplates() {
    return getNamespacedData(this.mcpConnections, "resourceTemplates");
  }
  /**
   * Namespaced version of callTool
   */
  async callTool(params, resultSchema, options) {
    const unqualifiedName = params.name.replace(`${params.serverId}.`, "");
    return this.mcpConnections[params.serverId].client.callTool(
      {
        ...params,
        name: unqualifiedName
      },
      resultSchema,
      options
    );
  }
  /**
   * Namespaced version of readResource
   */
  readResource(params, options) {
    return this.mcpConnections[params.serverId].client.readResource(
      params,
      options
    );
  }
  /**
   * Namespaced version of getPrompt
   */
  getPrompt(params, options) {
    return this.mcpConnections[params.serverId].client.getPrompt(
      params,
      options
    );
  }
};
function getNamespacedData(mcpClients, type) {
  const sets = Object.entries(mcpClients).map(([name, conn]) => {
    return { data: conn[type], name };
  });
  const namespacedData = sets.flatMap(({ name: serverId, data }) => {
    return data.map((item) => {
      return {
        ...item,
        // we add a serverId so we can easily pull it out and send the tool call to the right server
        serverId
      };
    });
  });
  return namespacedData;
}

export {
  DisposableStore,
  SSEEdgeClientTransport,
  StreamableHTTPEdgeClientTransport,
  MCPClientManager,
  getNamespacedData
};
//# sourceMappingURL=chunk-ZMMHNOMZ.js.map