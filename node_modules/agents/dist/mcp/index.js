import {
  Agent,
  getAgentByName,
  getCurrentAgent
} from "../chunk-XGMKNUJA.js";
import {
  SSEEdgeClientTransport,
  StreamableHTTPEdgeClientTransport
} from "../chunk-ZMMHNOMZ.js";
import "../chunk-C2OEBJZ2.js";
import "../chunk-QEVM4BVL.js";
import "../chunk-BER7KXUJ.js";
import "../chunk-PR4QN5HX.js";

// src/mcp/index.ts
import {
  JSONRPCMessageSchema as JSONRPCMessageSchema3,
  isJSONRPCError as isJSONRPCError2,
  isJSONRPCResponse as isJSONRPCResponse3
} from "@modelcontextprotocol/sdk/types.js";

// src/mcp/utils.ts
import {
  JSONRPCMessageSchema,
  InitializeRequestSchema,
  isJSONRPCResponse,
  isJSONRPCNotification
} from "@modelcontextprotocol/sdk/types.js";
var MCP_HTTP_METHOD_HEADER = "cf-mcp-method";
var MCP_MESSAGE_HEADER = "cf-mcp-message";
var MAXIMUM_MESSAGE_SIZE_BYTES = 4 * 1024 * 1024;
var createStreamingHttpHandler = (basePath, namespace, corsOptions) => {
  let pathname = basePath;
  if (basePath === "/") pathname = "/*";
  const basePattern = new URLPattern({ pathname });
  return async (request, ctx) => {
    const url = new URL(request.url);
    if (basePattern.test(url)) {
      if (request.method === "POST") {
        const acceptHeader = request.headers.get("accept");
        if (!acceptHeader?.includes("application/json") || !acceptHeader.includes("text/event-stream")) {
          const body2 = JSON.stringify({
            error: {
              code: -32e3,
              message: "Not Acceptable: Client must accept both application/json and text/event-stream"
            },
            id: null,
            jsonrpc: "2.0"
          });
          return new Response(body2, { status: 406 });
        }
        const ct = request.headers.get("content-type");
        if (!ct || !ct.includes("application/json")) {
          const body2 = JSON.stringify({
            error: {
              code: -32e3,
              message: "Unsupported Media Type: Content-Type must be application/json"
            },
            id: null,
            jsonrpc: "2.0"
          });
          return new Response(body2, { status: 415 });
        }
        const contentLength = Number.parseInt(
          request.headers.get("content-length") ?? "0",
          10
        );
        if (contentLength > MAXIMUM_MESSAGE_SIZE_BYTES) {
          const body2 = JSON.stringify({
            error: {
              code: -32e3,
              message: `Request body too large. Maximum size is ${MAXIMUM_MESSAGE_SIZE_BYTES} bytes`
            },
            id: null,
            jsonrpc: "2.0"
          });
          return new Response(body2, { status: 413 });
        }
        let sessionId = request.headers.get("mcp-session-id");
        let rawMessage;
        try {
          rawMessage = await request.json();
        } catch (_error) {
          const body2 = JSON.stringify({
            error: {
              code: -32700,
              message: "Parse error: Invalid JSON"
            },
            id: null,
            jsonrpc: "2.0"
          });
          return new Response(body2, { status: 400 });
        }
        let arrayMessage;
        if (Array.isArray(rawMessage)) {
          arrayMessage = rawMessage;
        } else {
          arrayMessage = [rawMessage];
        }
        let messages = [];
        for (const msg of arrayMessage) {
          if (!JSONRPCMessageSchema.safeParse(msg).success) {
            const body2 = JSON.stringify({
              error: {
                code: -32700,
                message: "Parse error: Invalid JSON-RPC message"
              },
              id: null,
              jsonrpc: "2.0"
            });
            return new Response(body2, { status: 400 });
          }
        }
        messages = arrayMessage.map((msg) => JSONRPCMessageSchema.parse(msg));
        const maybeInitializeRequest = messages.find(
          (msg) => InitializeRequestSchema.safeParse(msg).success
        );
        if (!!maybeInitializeRequest && sessionId) {
          const body2 = JSON.stringify({
            error: {
              code: -32600,
              message: "Invalid Request: Initialization requests must not include a sessionId"
            },
            id: null,
            jsonrpc: "2.0"
          });
          return new Response(body2, { status: 400 });
        }
        if (!!maybeInitializeRequest && messages.length > 1) {
          const body2 = JSON.stringify({
            error: {
              code: -32600,
              message: "Invalid Request: Only one initialization request is allowed"
            },
            id: null,
            jsonrpc: "2.0"
          });
          return new Response(body2, { status: 400 });
        }
        if (!maybeInitializeRequest && !sessionId) {
          const body2 = JSON.stringify({
            error: {
              code: -32e3,
              message: "Bad Request: Mcp-Session-Id header is required"
            },
            id: null,
            jsonrpc: "2.0"
          });
          return new Response(body2, { status: 400 });
        }
        sessionId = sessionId ?? namespace.newUniqueId().toString();
        const agent = await getAgentByName(
          namespace,
          `streamable-http:${sessionId}`,
          { props: ctx.props }
        );
        const isInitialized = await agent.getInitializeRequest();
        if (maybeInitializeRequest) {
          await agent.setInitializeRequest(maybeInitializeRequest);
        } else if (!isInitialized) {
          const body2 = JSON.stringify({
            error: {
              code: -32001,
              message: "Session not found"
            },
            id: null,
            jsonrpc: "2.0"
          });
          return new Response(body2, { status: 404 });
        }
        const { readable, writable } = new TransformStream();
        const writer = writable.getWriter();
        const encoder = new TextEncoder();
        const existingHeaders = {};
        request.headers.forEach((value, key) => {
          existingHeaders[key] = value;
        });
        const req = new Request(request.url, {
          headers: {
            ...existingHeaders,
            [MCP_HTTP_METHOD_HEADER]: "POST",
            [MCP_MESSAGE_HEADER]: JSON.stringify(messages),
            Upgrade: "websocket"
          }
        });
        if (ctx.props) agent.updateProps(ctx.props);
        const response = await agent.fetch(req);
        const ws = response.webSocket;
        if (!ws) {
          console.error("Failed to establish WebSocket connection");
          await writer.close();
          const body2 = JSON.stringify({
            error: {
              code: -32001,
              message: "Failed to establish WebSocket connection"
            },
            id: null,
            jsonrpc: "2.0"
          });
          return new Response(body2, { status: 500 });
        }
        ws.accept();
        ws.addEventListener("message", (event) => {
          async function onMessage(event2) {
            try {
              const data = typeof event2.data === "string" ? event2.data : new TextDecoder().decode(event2.data);
              const message = JSON.parse(data);
              if (message.type !== "cf_mcp_agent_event" /* CF_MCP_AGENT_EVENT */) {
                return;
              }
              await writer.write(encoder.encode(message.event));
              if (message.close) {
                ws?.close();
                await writer.close().catch(() => {
                });
              }
            } catch (error) {
              console.error("Error forwarding message to SSE:", error);
            }
          }
          onMessage(event).catch(console.error);
        });
        ws.addEventListener("error", (error) => {
          async function onError(_error) {
            await writer.close().catch(() => {
            });
          }
          onError(error).catch(console.error);
        });
        ws.addEventListener("close", () => {
          async function onClose() {
            await writer.close().catch(() => {
            });
          }
          onClose().catch(console.error);
        });
        const hasOnlyNotificationsOrResponses = messages.every(
          (msg) => isJSONRPCNotification(msg) || isJSONRPCResponse(msg)
        );
        if (hasOnlyNotificationsOrResponses) {
          ws.close();
          return new Response(null, {
            headers: corsHeaders(request, corsOptions),
            status: 202
          });
        }
        return new Response(readable, {
          headers: {
            "Cache-Control": "no-cache",
            Connection: "keep-alive",
            "Content-Type": "text/event-stream",
            "mcp-session-id": sessionId,
            ...corsHeaders(request, corsOptions)
          },
          status: 200
        });
      } else if (request.method === "GET") {
        const acceptHeader = request.headers.get("accept");
        if (!acceptHeader?.includes("text/event-stream")) {
          const body2 = JSON.stringify({
            jsonrpc: "2.0",
            error: {
              code: -32e3,
              message: "Not Acceptable: Client must accept text/event-stream"
            },
            id: null
          });
          return new Response(body2, { status: 406 });
        }
        const sessionId = request.headers.get("mcp-session-id");
        if (!sessionId)
          return new Response(
            JSON.stringify({
              error: {
                code: -32e3,
                message: "Bad Request: Mcp-Session-Id header is required"
              },
              id: null,
              jsonrpc: "2.0"
            }),
            { status: 400 }
          );
        const { readable, writable } = new TransformStream();
        const writer = writable.getWriter();
        const encoder = new TextEncoder();
        const agent = await getAgentByName(
          namespace,
          `streamable-http:${sessionId}`,
          { props: ctx.props }
        );
        const isInitialized = await agent.getInitializeRequest();
        if (!isInitialized) {
          return new Response(
            JSON.stringify({
              jsonrpc: "2.0",
              error: { code: -32001, message: "Session not found" },
              id: null
            }),
            { status: 404 }
          );
        }
        const existingHeaders = {};
        request.headers.forEach((v, k) => {
          existingHeaders[k] = v;
        });
        if (ctx.props) agent.updateProps(ctx.props);
        const response = await agent.fetch(
          new Request(request.url, {
            headers: {
              ...existingHeaders,
              [MCP_HTTP_METHOD_HEADER]: "GET",
              Upgrade: "websocket"
            }
          })
        );
        const ws = response.webSocket;
        if (!ws) {
          await writer.close();
          return new Response("Failed to establish WS to DO", {
            status: 500
          });
        }
        ws.accept();
        ws.addEventListener("message", (event) => {
          try {
            async function onMessage(ev) {
              const data = typeof ev.data === "string" ? ev.data : new TextDecoder().decode(ev.data);
              const message = JSON.parse(data);
              if (message.type !== "cf_mcp_agent_event" /* CF_MCP_AGENT_EVENT */) {
                return;
              }
              await writer.write(encoder.encode(message.event));
            }
            onMessage(event).catch(console.error);
          } catch (e) {
            console.error("Error forwarding message to SSE:", e);
          }
        });
        ws.addEventListener("error", () => {
          writer.close().catch(() => {
          });
        });
        ws.addEventListener("close", () => {
          writer.close().catch(() => {
          });
        });
        return new Response(readable, {
          headers: {
            "Cache-Control": "no-cache",
            Connection: "keep-alive",
            "Content-Type": "text/event-stream",
            "mcp-session-id": sessionId,
            ...corsHeaders(request, corsOptions)
          },
          status: 200
        });
      } else if (request.method === "DELETE") {
        const sessionId = request.headers.get("mcp-session-id");
        if (!sessionId) {
          return new Response(
            JSON.stringify({
              jsonrpc: "2.0",
              error: {
                code: -32e3,
                message: "Bad Request: Mcp-Session-Id header is required"
              },
              id: null
            }),
            { status: 400, headers: corsHeaders(request, corsOptions) }
          );
        }
        const agent = await getAgentByName(
          namespace,
          `streamable-http:${sessionId}`
        );
        const isInitialized = await agent.getInitializeRequest();
        if (!isInitialized) {
          return new Response(
            JSON.stringify({
              jsonrpc: "2.0",
              error: { code: -32001, message: "Session not found" },
              id: null
            }),
            { status: 404, headers: corsHeaders(request, corsOptions) }
          );
        }
        ctx.waitUntil(
          agent.destroy().catch(() => {
          })
        );
        return new Response(null, {
          status: 204,
          headers: corsHeaders(request, corsOptions)
        });
      }
    }
    const body = JSON.stringify({
      error: {
        code: -32e3,
        message: "Not found"
      },
      id: null,
      jsonrpc: "2.0"
    });
    return new Response(body, { status: 404 });
  };
};
var createLegacySseHandler = (basePath, namespace, corsOptions) => {
  let pathname = basePath;
  if (basePath === "/") pathname = "/*";
  const basePattern = new URLPattern({ pathname });
  const messagePattern = new URLPattern({ pathname: `${basePath}/message` });
  return async (request, ctx) => {
    const url = new URL(request.url);
    if (request.method === "GET" && basePattern.test(url)) {
      const sessionId = url.searchParams.get("sessionId") || namespace.newUniqueId().toString();
      const { readable, writable } = new TransformStream();
      const writer = writable.getWriter();
      const encoder = new TextEncoder();
      const endpointUrl = new URL(request.url);
      endpointUrl.pathname = encodeURI(`${basePath}/message`);
      endpointUrl.searchParams.set("sessionId", sessionId);
      const relativeUrlWithSession = endpointUrl.pathname + endpointUrl.search + endpointUrl.hash;
      const endpointMessage = `event: endpoint
data: ${relativeUrlWithSession}

`;
      writer.write(encoder.encode(endpointMessage));
      const agent = await getAgentByName(namespace, `sse:${sessionId}`, {
        props: ctx.props
      });
      const existingHeaders = {};
      request.headers.forEach((value, key) => {
        existingHeaders[key] = value;
      });
      if (ctx.props) agent.updateProps(ctx.props);
      const response = await agent.fetch(
        new Request(request.url, {
          headers: {
            ...existingHeaders,
            Upgrade: "websocket"
          }
        })
      );
      const ws = response.webSocket;
      if (!ws) {
        console.error("Failed to establish WebSocket connection");
        await writer.close();
        return new Response("Failed to establish WebSocket connection", {
          status: 500
        });
      }
      ws.accept();
      ws.addEventListener("message", (event) => {
        async function onMessage(event2) {
          try {
            const message = JSON.parse(event2.data);
            const result = JSONRPCMessageSchema.safeParse(message);
            if (!result.success) {
              return;
            }
            const messageText = `event: message
data: ${JSON.stringify(result.data)}

`;
            await writer.write(encoder.encode(messageText));
          } catch (error) {
            console.error("Error forwarding message to SSE:", error);
          }
        }
        onMessage(event).catch(console.error);
      });
      ws.addEventListener("error", (error) => {
        async function onError(_error) {
          try {
            await writer.close();
          } catch (_e) {
          }
        }
        onError(error).catch(console.error);
      });
      ws.addEventListener("close", () => {
        async function onClose() {
          try {
            await writer.close();
          } catch (error) {
            console.error("Error closing SSE connection:", error);
          }
        }
        onClose().catch(console.error);
      });
      return new Response(readable, {
        headers: {
          "Cache-Control": "no-cache",
          Connection: "keep-alive",
          "Content-Type": "text/event-stream",
          ...corsHeaders(request, corsOptions)
        }
      });
    }
    if (request.method === "POST" && messagePattern.test(url)) {
      const sessionId = url.searchParams.get("sessionId");
      if (!sessionId) {
        return new Response(
          `Missing sessionId. Expected POST to ${basePath} to initiate new one`,
          { status: 400 }
        );
      }
      const contentType = request.headers.get("content-type") || "";
      if (!contentType.includes("application/json")) {
        return new Response(`Unsupported content-type: ${contentType}`, {
          status: 400
        });
      }
      const contentLength = Number.parseInt(
        request.headers.get("content-length") || "0",
        10
      );
      if (contentLength > MAXIMUM_MESSAGE_SIZE_BYTES) {
        return new Response(`Request body too large: ${contentLength} bytes`, {
          status: 400
        });
      }
      const agent = await getAgentByName(namespace, `sse:${sessionId}`, {
        props: ctx.props
      });
      const messageBody = await request.json();
      const error = await agent.onSSEMcpMessage(sessionId, messageBody);
      if (error) {
        return new Response(error.message, {
          headers: {
            "Cache-Control": "no-cache",
            Connection: "keep-alive",
            "Content-Type": "text/event-stream",
            ...corsHeaders(request, corsOptions)
          },
          status: 400
        });
      }
      return new Response("Accepted", {
        headers: {
          "Cache-Control": "no-cache",
          Connection: "keep-alive",
          "Content-Type": "text/event-stream",
          ...corsHeaders(request, corsOptions)
        },
        status: 202
      });
    }
    return new Response("Not Found", { status: 404 });
  };
};
function corsHeaders(_request, corsOptions = {}) {
  const origin = "*";
  return {
    "Access-Control-Allow-Headers": corsOptions.headers || "Content-Type, Accept, mcp-session-id, mcp-protocol-version",
    "Access-Control-Allow-Methods": corsOptions.methods || "GET, POST, DELETE, OPTIONS",
    "Access-Control-Allow-Origin": corsOptions.origin || origin,
    "Access-Control-Expose-Headers": corsOptions.exposeHeaders || "mcp-session-id",
    "Access-Control-Max-Age": (corsOptions.maxAge || 86400).toString()
  };
}
function handleCORS(request, corsOptions) {
  if (request.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders(request, corsOptions) });
  }
  return null;
}
function isDurableObjectNamespace(namespace) {
  return typeof namespace === "object" && namespace !== null && "newUniqueId" in namespace && typeof namespace.newUniqueId === "function" && "idFromName" in namespace && typeof namespace.idFromName === "function";
}

// src/mcp/transport.ts
import {
  isJSONRPCError,
  isJSONRPCRequest,
  isJSONRPCResponse as isJSONRPCResponse2,
  JSONRPCMessageSchema as JSONRPCMessageSchema2
} from "@modelcontextprotocol/sdk/types.js";
var McpSSETransport = class {
  constructor(getWebSocket) {
    this._started = false;
    this._getWebSocket = getWebSocket;
  }
  async start() {
    if (this._started) {
      throw new Error("Transport already started");
    }
    this._started = true;
  }
  async send(message) {
    if (!this._started) {
      throw new Error("Transport not started");
    }
    const websocket = this._getWebSocket();
    if (!websocket) {
      throw new Error("WebSocket not connected");
    }
    try {
      websocket.send(JSON.stringify(message));
    } catch (error) {
      this.onerror?.(error);
    }
  }
  async close() {
    this.onclose?.();
  }
};
var StreamableHTTPServerTransport = class {
  constructor(options) {
    this._started = false;
    // This is to keep track whether all messages from a single POST request have been answered.
    // I's fine that we don't persist this since it's only for backwards compatibility as clients
    // should no longer batch requests, per the spec.
    this._requestResponseMap = /* @__PURE__ */ new Map();
    const { agent } = getCurrentAgent();
    if (!agent)
      throw new Error("McpAgent was not found in Transport constructor");
    this.sessionId = agent.getSessionId();
    this._eventStore = options.eventStore;
  }
  /**
   * Starts the transport. This is required by the Transport interface but is a no-op
   * for the Streamable HTTP transport as connections are managed per-request.
   */
  async start() {
    if (this._started) {
      throw new Error("Transport already started");
    }
    this._started = true;
  }
  /**
   * Handles GET requests for SSE stream
   */
  async handleGetRequest(req) {
    const { connection } = getCurrentAgent();
    if (!connection)
      throw new Error("Connection was not found in handleGetRequest");
    if (this._eventStore) {
      const lastEventId = req.headers.get("last-event-id");
      if (lastEventId) {
        await this.replayEvents(lastEventId);
        return;
      }
    }
    connection.setState({
      _standaloneSse: true
    });
  }
  /**
   * Replays events that would have been sent after the specified event ID
   * Only used when resumability is enabled
   */
  async replayEvents(lastEventId) {
    if (!this._eventStore) {
      return;
    }
    const { connection } = getCurrentAgent();
    if (!connection)
      throw new Error("Connection was not available in replayEvents");
    try {
      await this._eventStore?.replayEventsAfter(lastEventId, {
        send: async (eventId, message) => {
          try {
            this.writeSSEEvent(connection, message, eventId);
          } catch (error) {
            this.onerror?.(error);
          }
        }
      });
    } catch (error) {
      this.onerror?.(error);
    }
  }
  /**
   * Writes an event to the SSE stream with proper formatting
   */
  writeSSEEvent(connection, message, eventId, close) {
    let eventData = "event: message\n";
    if (eventId) {
      eventData += `id: ${eventId}
`;
    }
    eventData += `data: ${JSON.stringify(message)}

`;
    return connection.send(
      JSON.stringify({
        type: "cf_mcp_agent_event" /* CF_MCP_AGENT_EVENT */,
        event: eventData,
        close
      })
    );
  }
  /**
   * Handles POST requests containing JSON-RPC messages
   */
  async handlePostRequest(req, parsedBody) {
    const authInfo = req.auth;
    const requestInfo = {
      headers: Object.fromEntries(req.headers.entries())
    };
    delete requestInfo.headers[MCP_HTTP_METHOD_HEADER];
    delete requestInfo.headers[MCP_MESSAGE_HEADER];
    delete requestInfo.headers.upgrade;
    const rawMessage = parsedBody;
    let messages;
    if (Array.isArray(rawMessage)) {
      messages = rawMessage.map((msg) => JSONRPCMessageSchema2.parse(msg));
    } else {
      messages = [JSONRPCMessageSchema2.parse(rawMessage)];
    }
    const hasRequests = messages.some(isJSONRPCRequest);
    if (!hasRequests) {
      for (const message of messages) {
        this.onmessage?.(message, { authInfo, requestInfo });
      }
    } else if (hasRequests) {
      const { connection } = getCurrentAgent();
      if (!connection)
        throw new Error("Connection was not found in handlePostRequest");
      const requestIds = messages.filter(isJSONRPCRequest).map((message) => message.id);
      connection.setState({
        requestIds
      });
      for (const message of messages) {
        this.onmessage?.(message, { authInfo, requestInfo });
      }
    }
  }
  async close() {
    const { agent } = getCurrentAgent();
    if (!agent) throw new Error("Agent was not found in close");
    for (const conn of agent.getConnections()) {
      conn.close(1e3, "Session closed");
    }
    this.onclose?.();
  }
  async send(message, options) {
    const { agent } = getCurrentAgent();
    if (!agent) throw new Error("Agent was not found in send");
    let requestId = options?.relatedRequestId;
    if (isJSONRPCResponse2(message) || isJSONRPCError(message)) {
      requestId = message.id;
    }
    if (requestId === void 0) {
      if (isJSONRPCResponse2(message) || isJSONRPCError(message)) {
        throw new Error(
          "Cannot send a response on a standalone SSE stream unless resuming a previous client request"
        );
      }
      let standaloneConnection;
      for (const conn of agent.getConnections()) {
        if (conn.state?._standaloneSse) standaloneConnection = conn;
      }
      if (standaloneConnection === void 0) {
        return;
      }
      let eventId2;
      if (this._eventStore) {
        eventId2 = await this._eventStore.storeEvent(
          standaloneConnection.id,
          message
        );
      }
      this.writeSSEEvent(standaloneConnection, message, eventId2);
      return;
    }
    const connection = Array.from(
      agent.getConnections()
    ).find((conn) => conn.state?.requestIds?.includes(requestId));
    if (!connection) {
      throw new Error(
        `No connection established for request ID: ${String(requestId)}`
      );
    }
    let eventId;
    if (this._eventStore) {
      eventId = await this._eventStore.storeEvent(connection.id, message);
    }
    let shouldClose = false;
    if (isJSONRPCResponse2(message) || isJSONRPCError(message)) {
      this._requestResponseMap.set(requestId, message);
      const relatedIds = connection.state?.requestIds ?? [];
      shouldClose = relatedIds.every((id) => this._requestResponseMap.has(id));
      if (shouldClose) {
        for (const id of relatedIds) {
          this._requestResponseMap.delete(id);
        }
      }
    }
    this.writeSSEEvent(connection, message, eventId, shouldClose);
  }
};

// src/mcp/index.ts
import {
  ElicitRequestSchema
} from "@modelcontextprotocol/sdk/types.js";
var McpAgent = class _McpAgent extends Agent {
  /*
   * Helpers
   */
  async setInitializeRequest(initializeRequest) {
    await this.ctx.storage.put("initializeRequest", initializeRequest);
  }
  async getInitializeRequest() {
    return this.ctx.storage.get("initializeRequest");
  }
  /** Read the transport type for this agent.
   * This relies on the naming scheme being `sse:${sessionId}`
   * or `streamable-http:${sessionId}`.
   */
  getTransportType() {
    const [t, ..._] = this.name.split(":");
    switch (t) {
      case "sse":
        return "sse";
      case "streamable-http":
        return "streamable-http";
      default:
        throw new Error(
          "Invalid transport type. McpAgent must be addressed with a valid protocol."
        );
    }
  }
  /** Read the sessionId for this agent.
   * This relies on the naming scheme being `sse:${sessionId}`
   * or `streamable-http:${sessionId}`.
   */
  getSessionId() {
    const [_, sessionId] = this.name.split(":");
    if (!sessionId) {
      throw new Error(
        "Invalid session id. McpAgent must be addressed with a valid session id."
      );
    }
    return sessionId;
  }
  /** Get the unique WebSocket. SSE transport only. */
  getWebSocket() {
    const websockets = Array.from(this.getConnections());
    if (websockets.length === 0) {
      return null;
    }
    return websockets[0];
  }
  /** Returns a new transport matching the type of the Agent. */
  initTransport() {
    switch (this.getTransportType()) {
      case "sse": {
        return new McpSSETransport(() => this.getWebSocket());
      }
      case "streamable-http": {
        return new StreamableHTTPServerTransport({});
      }
    }
  }
  /** Update and store the props */
  async updateProps(props) {
    await this.ctx.storage.put("props", props ?? {});
    this.props = props;
  }
  async reinitializeServer() {
    const initializeRequest = await this.getInitializeRequest();
    if (initializeRequest) {
      this._transport?.onmessage?.(initializeRequest);
    }
  }
  /*
   * Base Agent / Parykit Server overrides
   */
  /** Sets up the MCP transport and server every time the Agent is started.*/
  async onStart(props) {
    if (props) await this.updateProps(props);
    this.props = await this.ctx.storage.get("props");
    await this.init();
    const server = await this.server;
    this._transport = this.initTransport();
    await server.connect(this._transport);
    await this.reinitializeServer();
  }
  /** Validates new WebSocket connections. */
  async onConnect(conn, { request: req }) {
    switch (this.getTransportType()) {
      case "sse": {
        const websockets = Array.from(this.getConnections());
        if (websockets.length > 1) {
          conn.close(1008, "Websocket already connected");
          return;
        }
        break;
      }
      case "streamable-http":
        if (this._transport instanceof StreamableHTTPServerTransport) {
          switch (req.headers.get(MCP_HTTP_METHOD_HEADER)) {
            case "POST": {
              const payloadHeader = req.headers.get(MCP_MESSAGE_HEADER);
              const parsedBody = await JSON.parse(payloadHeader ?? "{}");
              this._transport?.handlePostRequest(req, parsedBody);
              break;
            }
            case "GET":
              this._transport?.handleGetRequest(req);
              break;
          }
        }
    }
  }
  /*
   * Transport ingress and routing
   */
  /** Handles MCP Messages for the legacy SSE transport. */
  async onSSEMcpMessage(_sessionId, messageBody) {
    if (this.getTransportType() !== "sse") {
      return new Error("Internal Server Error: Expected SSE transport");
    }
    try {
      let parsedMessage;
      try {
        parsedMessage = JSONRPCMessageSchema3.parse(messageBody);
      } catch (error) {
        this._transport?.onerror?.(error);
        throw error;
      }
      if (await this._handleElicitationResponse(parsedMessage)) {
        return null;
      }
      this._transport?.onmessage?.(parsedMessage);
      return null;
    } catch (error) {
      console.error("Error forwarding message to SSE:", error);
      this._transport?.onerror?.(error);
      return error;
    }
  }
  /** Elicit user input with a message and schema */
  async elicitInput(params) {
    const requestId = `elicit_${Math.random().toString(36).substring(2, 11)}`;
    await this.ctx.storage.put(`elicitation:${requestId}`, {
      message: params.message,
      requestedSchema: params.requestedSchema,
      timestamp: Date.now()
    });
    const elicitRequest = {
      jsonrpc: "2.0",
      id: requestId,
      method: "elicitation/create",
      params: {
        message: params.message,
        requestedSchema: params.requestedSchema
      }
    };
    if (this._transport) {
      await this._transport.send(elicitRequest);
    } else {
      const connections = this.getConnections();
      if (!connections || Array.from(connections).length === 0) {
        await this.ctx.storage.delete(`elicitation:${requestId}`);
        throw new Error("No active connections available for elicitation");
      }
      const connectionList = Array.from(connections);
      for (const connection of connectionList) {
        try {
          connection.send(JSON.stringify(elicitRequest));
        } catch (error) {
          console.error("Failed to send elicitation request:", error);
        }
      }
    }
    return this._waitForElicitationResponse(requestId);
  }
  /** Wait for elicitation response through storage polling */
  async _waitForElicitationResponse(requestId) {
    const startTime = Date.now();
    const timeout = 6e4;
    try {
      while (Date.now() - startTime < timeout) {
        const response = await this.ctx.storage.get(
          `elicitation:response:${requestId}`
        );
        if (response) {
          await this.ctx.storage.delete(`elicitation:${requestId}`);
          await this.ctx.storage.delete(`elicitation:response:${requestId}`);
          return response;
        }
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
      throw new Error("Elicitation request timed out");
    } finally {
      await this.ctx.storage.delete(`elicitation:${requestId}`);
      await this.ctx.storage.delete(`elicitation:response:${requestId}`);
    }
  }
  /** Handle elicitation responses */
  async _handleElicitationResponse(message) {
    if (isJSONRPCResponse3(message) && message.result) {
      const requestId = message.id?.toString();
      if (!requestId || !requestId.startsWith("elicit_")) return false;
      const pendingRequest = await this.ctx.storage.get(
        `elicitation:${requestId}`
      );
      if (!pendingRequest) return false;
      await this.ctx.storage.put(
        `elicitation:response:${requestId}`,
        message.result
      );
      return true;
    }
    if (isJSONRPCError2(message)) {
      const requestId = message.id?.toString();
      if (!requestId || !requestId.startsWith("elicit_")) return false;
      const pendingRequest = await this.ctx.storage.get(
        `elicitation:${requestId}`
      );
      if (!pendingRequest) return false;
      const errorResult = {
        action: "cancel",
        content: {
          error: message.error.message || "Elicitation request failed"
        }
      };
      await this.ctx.storage.put(
        `elicitation:response:${requestId}`,
        errorResult
      );
      return true;
    }
    return false;
  }
  /** Return a handler for the given path for this MCP.
   * Defaults to Streamable HTTP transport.
   */
  static serve(path, {
    binding = "MCP_OBJECT",
    corsOptions,
    transport = "streamable-http"
  } = {}) {
    return {
      async fetch(request, env, ctx) {
        const corsResponse = handleCORS(request, corsOptions);
        if (corsResponse) {
          return corsResponse;
        }
        const bindingValue = env[binding];
        if (bindingValue == null || typeof bindingValue !== "object") {
          throw new Error(
            `Could not find McpAgent binding for ${binding}. Did you update your wrangler configuration?`
          );
        }
        if (!isDurableObjectNamespace(bindingValue)) {
          throw new Error(
            `Invalid McpAgent binding for ${binding}. Make sure it's a Durable Object binding.`
          );
        }
        const namespace = bindingValue;
        switch (transport) {
          case "streamable-http": {
            const handleStreamableHttp = createStreamingHttpHandler(
              path,
              namespace,
              corsOptions
            );
            return handleStreamableHttp(request, ctx);
          }
          case "sse": {
            const handleLegacySse = createLegacySseHandler(
              path,
              namespace,
              corsOptions
            );
            return handleLegacySse(request, ctx);
          }
          default:
            return new Response(
              "Invalid MCP transport mode. Only `streamable-http` or `sse` are allowed.",
              { status: 500 }
            );
        }
      }
    };
  }
  /**
   * Legacy api
   **/
  static mount(path, opts = {}) {
    return _McpAgent.serveSSE(path, opts);
  }
  static serveSSE(path, opts = {}) {
    return _McpAgent.serve(path, { ...opts, transport: "sse" });
  }
};
export {
  ElicitRequestSchema,
  McpAgent,
  SSEEdgeClientTransport,
  StreamableHTTPEdgeClientTransport
};
//# sourceMappingURL=index.js.map