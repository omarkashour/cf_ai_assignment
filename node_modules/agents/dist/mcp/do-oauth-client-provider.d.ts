import { OAuthClientProvider } from '@modelcontextprotocol/sdk/client/auth.js';
import { OAuthClientMetadata, OAuthClientInformation, OAuthClientInformationFull, OAuthTokens } from '@modelcontextprotocol/sdk/shared/auth.js';

interface AgentsOAuthProvider extends OAuthClientProvider {
    authUrl: string | undefined;
    clientId: string | undefined;
    serverId: string | undefined;
}
declare class DurableObjectOAuthClientProvider implements AgentsOAuthProvider {
    storage: DurableObjectStorage;
    clientName: string;
    baseRedirectUrl: string;
    private _authUrl_;
    private _serverId_;
    private _clientId_;
    constructor(storage: DurableObjectStorage, clientName: string, baseRedirectUrl: string);
    get clientMetadata(): OAuthClientMetadata;
    get clientUri(): string;
    get redirectUrl(): string;
    get clientId(): string;
    set clientId(clientId_: string);
    get serverId(): string;
    set serverId(serverId_: string);
    keyPrefix(clientId: string): string;
    clientInfoKey(clientId: string): string;
    clientInformation(): Promise<OAuthClientInformation | undefined>;
    saveClientInformation(clientInformation: OAuthClientInformationFull): Promise<void>;
    tokenKey(clientId: string): string;
    tokens(): Promise<OAuthTokens | undefined>;
    saveTokens(tokens: OAuthTokens): Promise<void>;
    get authUrl(): string | undefined;
    /**
     * Because this operates on the server side (but we need browser auth), we send this url back to the user
     * and require user interact to initiate the redirect flow
     */
    redirectToAuthorization(authUrl: URL): Promise<void>;
    codeVerifierKey(clientId: string): string;
    saveCodeVerifier(verifier: string): Promise<void>;
    codeVerifier(): Promise<string>;
}

export { type AgentsOAuthProvider, DurableObjectOAuthClientProvider };
