import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { JSONRPCMessage, ElicitResult } from '@modelcontextprotocol/sdk/types.js';
export { ElicitRequest, ElicitRequestSchema, ElicitResult } from '@modelcontextprotocol/sdk/types.js';
import { Agent } from '../index.js';
import { M as MaybePromise, B as BaseTransportType, S as ServeOptions } from '../client-DVoPb3-C.js';
export { d as MCPClientOAuthCallbackConfig, c as MCPClientOAuthResult, a as SSEEdgeClientTransport, b as StreamableHTTPEdgeClientTransport } from '../client-DVoPb3-C.js';
import { Connection, ConnectionContext } from 'partyserver';
import 'cloudflare:workers';
import '@modelcontextprotocol/sdk/client/index.js';
import '../observability/index.js';
import '../mcp-BH1fJeiU.js';
import '../ai-types.js';
import 'ai';
import 'zod';
import '@modelcontextprotocol/sdk/shared/protocol.js';
import '@modelcontextprotocol/sdk/client/sse.js';
import '@modelcontextprotocol/sdk/client/streamableHttp.js';
import './do-oauth-client-provider.js';
import '@modelcontextprotocol/sdk/client/auth.js';
import '@modelcontextprotocol/sdk/shared/auth.js';

declare abstract class McpAgent<Env = unknown, State = unknown, Props extends Record<string, unknown> = Record<string, unknown>> extends Agent<Env, State, Props> {
    private _transport?;
    props?: Props;
    abstract server: MaybePromise<McpServer | Server>;
    abstract init(): Promise<void>;
    setInitializeRequest(initializeRequest: JSONRPCMessage): Promise<void>;
    getInitializeRequest(): Promise<JSONRPCMessage | undefined>;
    /** Read the transport type for this agent.
     * This relies on the naming scheme being `sse:${sessionId}`
     * or `streamable-http:${sessionId}`.
     */
    getTransportType(): BaseTransportType;
    /** Read the sessionId for this agent.
     * This relies on the naming scheme being `sse:${sessionId}`
     * or `streamable-http:${sessionId}`.
     */
    getSessionId(): string;
    /** Get the unique WebSocket. SSE transport only. */
    private getWebSocket;
    /** Returns a new transport matching the type of the Agent. */
    private initTransport;
    /** Update and store the props */
    updateProps(props?: Props): Promise<void>;
    reinitializeServer(): Promise<void>;
    /** Sets up the MCP transport and server every time the Agent is started.*/
    onStart(props?: Props): Promise<void>;
    /** Validates new WebSocket connections. */
    onConnect(conn: Connection, { request: req }: ConnectionContext): Promise<void>;
    /** Handles MCP Messages for the legacy SSE transport. */
    onSSEMcpMessage(_sessionId: string, messageBody: unknown): Promise<Error | null>;
    /** Elicit user input with a message and schema */
    elicitInput(params: {
        message: string;
        requestedSchema: unknown;
    }): Promise<ElicitResult>;
    /** Wait for elicitation response through storage polling */
    private _waitForElicitationResponse;
    /** Handle elicitation responses */
    private _handleElicitationResponse;
    /** Return a handler for the given path for this MCP.
     * Defaults to Streamable HTTP transport.
     */
    static serve(path: string, { binding, corsOptions, transport }?: ServeOptions): {
        fetch<Env>(this: void, request: Request, env: Env, ctx: ExecutionContext): Promise<Response>;
    };
    /**
     * Legacy api
     **/
    static mount(path: string, opts?: Omit<ServeOptions, "transport">): {
        fetch<Env>(this: void, request: Request, env: Env, ctx: ExecutionContext): Promise<Response>;
    };
    static serveSSE(path: string, opts?: Omit<ServeOptions, "transport">): {
        fetch<Env>(this: void, request: Request, env: Env, ctx: ExecutionContext): Promise<Response>;
    };
}

export { McpAgent };
