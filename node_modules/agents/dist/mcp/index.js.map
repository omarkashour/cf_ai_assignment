{"version":3,"sources":["../../src/mcp/index.ts","../../src/mcp/utils.ts","../../src/mcp/transport.ts"],"sourcesContent":["import type { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport type { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport type { Transport } from \"@modelcontextprotocol/sdk/shared/transport.js\";\nimport type { JSONRPCMessage } from \"@modelcontextprotocol/sdk/types.js\";\nimport {\n  JSONRPCMessageSchema,\n  isJSONRPCError,\n  isJSONRPCResponse,\n  type ElicitResult\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport type { Connection, ConnectionContext } from \"../\";\nimport { Agent } from \"../index\";\nimport type { BaseTransportType, MaybePromise, ServeOptions } from \"./types\";\nimport {\n  createLegacySseHandler,\n  createStreamingHttpHandler,\n  handleCORS,\n  isDurableObjectNamespace,\n  MCP_HTTP_METHOD_HEADER,\n  MCP_MESSAGE_HEADER\n} from \"./utils\";\nimport { McpSSETransport, StreamableHTTPServerTransport } from \"./transport\";\n\nexport abstract class McpAgent<\n  Env = unknown,\n  State = unknown,\n  Props extends Record<string, unknown> = Record<string, unknown>\n> extends Agent<Env, State, Props> {\n  private _transport?: Transport;\n  props?: Props;\n\n  abstract server: MaybePromise<McpServer | Server>;\n  abstract init(): Promise<void>;\n\n  /*\n   * Helpers\n   */\n\n  async setInitializeRequest(initializeRequest: JSONRPCMessage) {\n    await this.ctx.storage.put(\"initializeRequest\", initializeRequest);\n  }\n\n  async getInitializeRequest() {\n    return this.ctx.storage.get<JSONRPCMessage>(\"initializeRequest\");\n  }\n\n  /** Read the transport type for this agent.\n   * This relies on the naming scheme being `sse:${sessionId}`\n   * or `streamable-http:${sessionId}`.\n   */\n  getTransportType(): BaseTransportType {\n    const [t, ..._] = this.name.split(\":\");\n    switch (t) {\n      case \"sse\":\n        return \"sse\";\n      case \"streamable-http\":\n        return \"streamable-http\";\n      default:\n        throw new Error(\n          \"Invalid transport type. McpAgent must be addressed with a valid protocol.\"\n        );\n    }\n  }\n\n  /** Read the sessionId for this agent.\n   * This relies on the naming scheme being `sse:${sessionId}`\n   * or `streamable-http:${sessionId}`.\n   */\n  getSessionId(): string {\n    const [_, sessionId] = this.name.split(\":\");\n    if (!sessionId) {\n      throw new Error(\n        \"Invalid session id. McpAgent must be addressed with a valid session id.\"\n      );\n    }\n    return sessionId;\n  }\n\n  /** Get the unique WebSocket. SSE transport only. */\n  private getWebSocket() {\n    const websockets = Array.from(this.getConnections());\n    if (websockets.length === 0) {\n      return null;\n    }\n    return websockets[0];\n  }\n\n  /** Returns a new transport matching the type of the Agent. */\n  private initTransport() {\n    switch (this.getTransportType()) {\n      case \"sse\": {\n        return new McpSSETransport(() => this.getWebSocket());\n      }\n      case \"streamable-http\": {\n        return new StreamableHTTPServerTransport({});\n      }\n    }\n  }\n\n  /** Update and store the props */\n  async updateProps(props?: Props) {\n    await this.ctx.storage.put(\"props\", props ?? {});\n    this.props = props;\n  }\n\n  async reinitializeServer() {\n    // If the agent was previously initialized, we have to populate\n    // the server again by sending the initialize request to make\n    // client information available to the server.\n    const initializeRequest = await this.getInitializeRequest();\n    if (initializeRequest) {\n      this._transport?.onmessage?.(initializeRequest);\n    }\n  }\n\n  /*\n   * Base Agent / Parykit Server overrides\n   */\n\n  /** Sets up the MCP transport and server every time the Agent is started.*/\n  async onStart(props?: Props) {\n    // If onStart was passed props, save them in storage\n    if (props) await this.updateProps(props);\n    this.props = await this.ctx.storage.get(\"props\");\n\n    await this.init();\n    const server = await this.server;\n    // Connect to the MCP server\n    this._transport = this.initTransport();\n    await server.connect(this._transport);\n    await this.reinitializeServer();\n  }\n\n  /** Validates new WebSocket connections. */\n  async onConnect(\n    conn: Connection,\n    { request: req }: ConnectionContext\n  ): Promise<void> {\n    switch (this.getTransportType()) {\n      case \"sse\": {\n        // For SSE connections, we can only have one open connection per session\n        // If we get an upgrade while already connected, we should error\n        const websockets = Array.from(this.getConnections());\n        if (websockets.length > 1) {\n          conn.close(1008, \"Websocket already connected\");\n          return;\n        }\n        break;\n      }\n      case \"streamable-http\":\n        if (this._transport instanceof StreamableHTTPServerTransport) {\n          switch (req.headers.get(MCP_HTTP_METHOD_HEADER)) {\n            case \"POST\": {\n              // This returns the repsonse directly to the client\n              const payloadHeader = req.headers.get(MCP_MESSAGE_HEADER);\n              const parsedBody = await JSON.parse(payloadHeader ?? \"{}\");\n              this._transport?.handlePostRequest(req, parsedBody);\n              break;\n            }\n            case \"GET\":\n              this._transport?.handleGetRequest(req);\n              break;\n          }\n        }\n    }\n  }\n\n  /*\n   * Transport ingress and routing\n   */\n\n  /** Handles MCP Messages for the legacy SSE transport. */\n  async onSSEMcpMessage(\n    _sessionId: string,\n    messageBody: unknown\n  ): Promise<Error | null> {\n    // Since we address the DO via both the protocol and the session id,\n    // this should never happen, but let's enforce it just in case\n    if (this.getTransportType() !== \"sse\") {\n      return new Error(\"Internal Server Error: Expected SSE transport\");\n    }\n\n    try {\n      let parsedMessage: JSONRPCMessage;\n      try {\n        parsedMessage = JSONRPCMessageSchema.parse(messageBody);\n      } catch (error) {\n        this._transport?.onerror?.(error as Error);\n        throw error;\n      }\n\n      // Check if this is an elicitation response before passing to transport\n      if (await this._handleElicitationResponse(parsedMessage)) {\n        return null; // Message was handled by elicitation system\n      }\n\n      this._transport?.onmessage?.(parsedMessage);\n      return null;\n    } catch (error) {\n      console.error(\"Error forwarding message to SSE:\", error);\n      this._transport?.onerror?.(error as Error);\n      return error as Error;\n    }\n  }\n\n  /** Elicit user input with a message and schema */\n  async elicitInput(params: {\n    message: string;\n    requestedSchema: unknown;\n  }): Promise<ElicitResult> {\n    const requestId = `elicit_${Math.random().toString(36).substring(2, 11)}`;\n\n    // Store pending request in durable storage\n    await this.ctx.storage.put(`elicitation:${requestId}`, {\n      message: params.message,\n      requestedSchema: params.requestedSchema,\n      timestamp: Date.now()\n    });\n\n    const elicitRequest = {\n      jsonrpc: \"2.0\" as const,\n      id: requestId,\n      method: \"elicitation/create\",\n      params: {\n        message: params.message,\n        requestedSchema: params.requestedSchema\n      }\n    };\n\n    // Send through MCP transport\n    if (this._transport) {\n      await this._transport.send(elicitRequest);\n    } else {\n      const connections = this.getConnections();\n      if (!connections || Array.from(connections).length === 0) {\n        await this.ctx.storage.delete(`elicitation:${requestId}`);\n        throw new Error(\"No active connections available for elicitation\");\n      }\n\n      const connectionList = Array.from(connections);\n      for (const connection of connectionList) {\n        try {\n          connection.send(JSON.stringify(elicitRequest));\n        } catch (error) {\n          console.error(\"Failed to send elicitation request:\", error);\n        }\n      }\n    }\n\n    // Wait for response through MCP\n    return this._waitForElicitationResponse(requestId);\n  }\n\n  /** Wait for elicitation response through storage polling */\n  private async _waitForElicitationResponse(\n    requestId: string\n  ): Promise<ElicitResult> {\n    const startTime = Date.now();\n    const timeout = 60000; // 60 second timeout\n\n    try {\n      while (Date.now() - startTime < timeout) {\n        // Check if response has been stored\n        const response = await this.ctx.storage.get<ElicitResult>(\n          `elicitation:response:${requestId}`\n        );\n        if (response) {\n          // Immediately clean up both request and response\n          await this.ctx.storage.delete(`elicitation:${requestId}`);\n          await this.ctx.storage.delete(`elicitation:response:${requestId}`);\n          return response;\n        }\n\n        // Sleep briefly before checking again\n        await new Promise((resolve) => setTimeout(resolve, 100));\n      }\n\n      throw new Error(\"Elicitation request timed out\");\n    } finally {\n      // Always clean up on timeout or error\n      await this.ctx.storage.delete(`elicitation:${requestId}`);\n      await this.ctx.storage.delete(`elicitation:response:${requestId}`);\n    }\n  }\n\n  /** Handle elicitation responses */\n  private async _handleElicitationResponse(\n    message: JSONRPCMessage\n  ): Promise<boolean> {\n    // Check if this is a response to an elicitation request\n    if (isJSONRPCResponse(message) && message.result) {\n      const requestId = message.id?.toString();\n      if (!requestId || !requestId.startsWith(\"elicit_\")) return false;\n\n      // Check if we have a pending request for this ID\n      const pendingRequest = await this.ctx.storage.get(\n        `elicitation:${requestId}`\n      );\n      if (!pendingRequest) return false;\n\n      // Store the response in durable storage\n      await this.ctx.storage.put(\n        `elicitation:response:${requestId}`,\n        message.result as ElicitResult\n      );\n      return true;\n    }\n\n    // Check if this is an error response to an elicitation request\n    if (isJSONRPCError(message)) {\n      const requestId = message.id?.toString();\n      if (!requestId || !requestId.startsWith(\"elicit_\")) return false;\n\n      // Check if we have a pending request for this ID\n      const pendingRequest = await this.ctx.storage.get(\n        `elicitation:${requestId}`\n      );\n      if (!pendingRequest) return false;\n\n      // Store error response\n      const errorResult: ElicitResult = {\n        action: \"cancel\",\n        content: {\n          error: message.error.message || \"Elicitation request failed\"\n        }\n      };\n      await this.ctx.storage.put(\n        `elicitation:response:${requestId}`,\n        errorResult\n      );\n      return true;\n    }\n\n    return false;\n  }\n\n  /** Return a handler for the given path for this MCP.\n   * Defaults to Streamable HTTP transport.\n   */\n  static serve(\n    path: string,\n    {\n      binding = \"MCP_OBJECT\",\n      corsOptions,\n      transport = \"streamable-http\"\n    }: ServeOptions = {}\n  ) {\n    return {\n      async fetch<Env>(\n        this: void,\n        request: Request,\n        env: Env,\n        ctx: ExecutionContext\n      ): Promise<Response> {\n        // Handle CORS preflight\n        const corsResponse = handleCORS(request, corsOptions);\n        if (corsResponse) {\n          return corsResponse;\n        }\n\n        const bindingValue = env[binding as keyof typeof env] as unknown;\n\n        // Ensure we have a binding of some sort\n        if (bindingValue == null || typeof bindingValue !== \"object\") {\n          throw new Error(\n            `Could not find McpAgent binding for ${binding}. Did you update your wrangler configuration?`\n          );\n        }\n\n        // Ensure that the binding is to a DurableObject\n        if (!isDurableObjectNamespace(bindingValue)) {\n          throw new Error(\n            `Invalid McpAgent binding for ${binding}. Make sure it's a Durable Object binding.`\n          );\n        }\n\n        const namespace =\n          bindingValue satisfies DurableObjectNamespace<McpAgent>;\n\n        switch (transport) {\n          case \"streamable-http\": {\n            // Streamable HTTP transport handling\n            const handleStreamableHttp = createStreamingHttpHandler(\n              path,\n              namespace,\n              corsOptions\n            );\n            return handleStreamableHttp(request, ctx);\n          }\n          case \"sse\": {\n            // Legacy SSE transport handling\n            const handleLegacySse = createLegacySseHandler(\n              path,\n              namespace,\n              corsOptions\n            );\n            return handleLegacySse(request, ctx);\n          }\n          default:\n            return new Response(\n              \"Invalid MCP transport mode. Only `streamable-http` or `sse` are allowed.\",\n              { status: 500 }\n            );\n        }\n      }\n    };\n  }\n  /**\n   * Legacy api\n   **/\n  static mount(path: string, opts: Omit<ServeOptions, \"transport\"> = {}) {\n    return McpAgent.serveSSE(path, opts);\n  }\n\n  static serveSSE(path: string, opts: Omit<ServeOptions, \"transport\"> = {}) {\n    return McpAgent.serve(path, { ...opts, transport: \"sse\" });\n  }\n}\n\n// Export client transport classes\nexport { SSEEdgeClientTransport } from \"./sse-edge\";\nexport { StreamableHTTPEdgeClientTransport } from \"./streamable-http-edge\";\n\n// Export elicitation types and schemas\nexport {\n  ElicitRequestSchema,\n  type ElicitRequest,\n  type ElicitResult\n} from \"@modelcontextprotocol/sdk/types.js\";\n\n// Export OAuth-related types\nexport type {\n  MCPClientOAuthResult,\n  MCPClientOAuthCallbackConfig\n} from \"./client\";\n","import {\n  JSONRPCMessageSchema,\n  type JSONRPCMessage,\n  InitializeRequestSchema,\n  isJSONRPCResponse,\n  isJSONRPCNotification\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport type { McpAgent } from \".\";\nimport { getAgentByName } from \"..\";\nimport type { CORSOptions } from \"./types\";\nimport { MessageType } from \"../ai-types\";\n\n/**\n * Since we use WebSockets to bridge the client to the\n * MCP transport in the Agent, we use this header to signal\n * the method of the original request the user made, while\n * leaving the WS Upgrade request as GET.\n */\nexport const MCP_HTTP_METHOD_HEADER = \"cf-mcp-method\";\n\n/**\n * Since we use WebSockets to bridge the client to the\n * MCP transport in the Agent, we use this header to include\n * the original request body.\n */\nexport const MCP_MESSAGE_HEADER = \"cf-mcp-message\";\n\nconst MAXIMUM_MESSAGE_SIZE_BYTES = 4 * 1024 * 1024; // 4MB\n\nexport const createStreamingHttpHandler = (\n  basePath: string,\n  namespace: DurableObjectNamespace<McpAgent>,\n  corsOptions?: CORSOptions\n) => {\n  let pathname = basePath;\n  if (basePath === \"/\") pathname = \"/*\";\n\n  const basePattern = new URLPattern({ pathname });\n  return async (request: Request, ctx: ExecutionContext) => {\n    const url = new URL(request.url);\n    if (basePattern.test(url)) {\n      if (request.method === \"POST\") {\n        // Validate the Accept header\n        const acceptHeader = request.headers.get(\"accept\");\n        // The client MUST include an Accept header, listing both application/json and text/event-stream as supported content types.\n        if (\n          !acceptHeader?.includes(\"application/json\") ||\n          !acceptHeader.includes(\"text/event-stream\")\n        ) {\n          const body = JSON.stringify({\n            error: {\n              code: -32000,\n              message:\n                \"Not Acceptable: Client must accept both application/json and text/event-stream\"\n            },\n            id: null,\n            jsonrpc: \"2.0\"\n          });\n          return new Response(body, { status: 406 });\n        }\n\n        const ct = request.headers.get(\"content-type\");\n        if (!ct || !ct.includes(\"application/json\")) {\n          const body = JSON.stringify({\n            error: {\n              code: -32000,\n              message:\n                \"Unsupported Media Type: Content-Type must be application/json\"\n            },\n            id: null,\n            jsonrpc: \"2.0\"\n          });\n          return new Response(body, { status: 415 });\n        }\n\n        // Check content length against maximum allowed size\n        const contentLength = Number.parseInt(\n          request.headers.get(\"content-length\") ?? \"0\",\n          10\n        );\n        if (contentLength > MAXIMUM_MESSAGE_SIZE_BYTES) {\n          const body = JSON.stringify({\n            error: {\n              code: -32000,\n              message: `Request body too large. Maximum size is ${MAXIMUM_MESSAGE_SIZE_BYTES} bytes`\n            },\n            id: null,\n            jsonrpc: \"2.0\"\n          });\n          return new Response(body, { status: 413 });\n        }\n\n        let sessionId = request.headers.get(\"mcp-session-id\");\n        let rawMessage: unknown;\n\n        try {\n          rawMessage = await request.json();\n        } catch (_error) {\n          const body = JSON.stringify({\n            error: {\n              code: -32700,\n              message: \"Parse error: Invalid JSON\"\n            },\n            id: null,\n            jsonrpc: \"2.0\"\n          });\n          return new Response(body, { status: 400 });\n        }\n\n        // Make sure the message is an array to simplify logic\n        let arrayMessage: unknown[];\n        if (Array.isArray(rawMessage)) {\n          arrayMessage = rawMessage;\n        } else {\n          arrayMessage = [rawMessage];\n        }\n\n        let messages: JSONRPCMessage[] = [];\n\n        // Try to parse each message as JSON RPC. Fail if any message is invalid\n        for (const msg of arrayMessage) {\n          if (!JSONRPCMessageSchema.safeParse(msg).success) {\n            const body = JSON.stringify({\n              error: {\n                code: -32700,\n                message: \"Parse error: Invalid JSON-RPC message\"\n              },\n              id: null,\n              jsonrpc: \"2.0\"\n            });\n            return new Response(body, { status: 400 });\n          }\n        }\n\n        messages = arrayMessage.map((msg) => JSONRPCMessageSchema.parse(msg));\n\n        // Before we pass the messages to the agent, there's another error condition we need to enforce\n        // Check if this is an initialization request\n        // https://spec.modelcontextprotocol.io/specification/2025-03-26/basic/lifecycle/\n        const maybeInitializeRequest = messages.find(\n          (msg) => InitializeRequestSchema.safeParse(msg).success\n        );\n\n        if (!!maybeInitializeRequest && sessionId) {\n          const body = JSON.stringify({\n            error: {\n              code: -32600,\n              message:\n                \"Invalid Request: Initialization requests must not include a sessionId\"\n            },\n            id: null,\n            jsonrpc: \"2.0\"\n          });\n          return new Response(body, { status: 400 });\n        }\n\n        // The initialization request must be the only request in the batch\n        if (!!maybeInitializeRequest && messages.length > 1) {\n          const body = JSON.stringify({\n            error: {\n              code: -32600,\n              message:\n                \"Invalid Request: Only one initialization request is allowed\"\n            },\n            id: null,\n            jsonrpc: \"2.0\"\n          });\n          return new Response(body, { status: 400 });\n        }\n\n        // If an Mcp-Session-Id is returned by the server during initialization,\n        // clients using the Streamable HTTP transport MUST include it\n        // in the Mcp-Session-Id header on all of their subsequent HTTP requests.\n        if (!maybeInitializeRequest && !sessionId) {\n          const body = JSON.stringify({\n            error: {\n              code: -32000,\n              message: \"Bad Request: Mcp-Session-Id header is required\"\n            },\n            id: null,\n            jsonrpc: \"2.0\"\n          });\n          return new Response(body, { status: 400 });\n        }\n\n        // If we don't have a sessionId, we are serving an initialization request\n        // and need to generate a new sessionId\n        sessionId = sessionId ?? namespace.newUniqueId().toString();\n\n        // Get the agent and set props\n        const agent = await getAgentByName(\n          namespace,\n          `streamable-http:${sessionId}`,\n          { props: ctx.props as Record<string, unknown> | undefined }\n        );\n        const isInitialized = await agent.getInitializeRequest();\n\n        if (maybeInitializeRequest) {\n          await agent.setInitializeRequest(maybeInitializeRequest);\n        } else if (!isInitialized) {\n          // if we have gotten here, then a session id that was never initialized\n          // was provided\n          const body = JSON.stringify({\n            error: {\n              code: -32001,\n              message: \"Session not found\"\n            },\n            id: null,\n            jsonrpc: \"2.0\"\n          });\n          return new Response(body, { status: 404 });\n        }\n\n        // We've evaluated all the error conditions! Now it's time to establish\n        // all the streams\n\n        // Create a Transform Stream for SSE\n        const { readable, writable } = new TransformStream();\n        const writer = writable.getWriter();\n        const encoder = new TextEncoder();\n\n        // Connect to the Durable Object via WebSocket\n        const existingHeaders: Record<string, string> = {};\n        request.headers.forEach((value, key) => {\n          existingHeaders[key] = value;\n        });\n        const req = new Request(request.url, {\n          headers: {\n            ...existingHeaders,\n            [MCP_HTTP_METHOD_HEADER]: \"POST\",\n            [MCP_MESSAGE_HEADER]: JSON.stringify(messages),\n            Upgrade: \"websocket\"\n          }\n        });\n        if (ctx.props) agent.updateProps(ctx.props as Record<string, unknown>);\n        const response = await agent.fetch(req);\n\n        // Get the WebSocket\n        const ws = response.webSocket;\n        if (!ws) {\n          console.error(\"Failed to establish WebSocket connection\");\n\n          await writer.close();\n          const body = JSON.stringify({\n            error: {\n              code: -32001,\n              message: \"Failed to establish WebSocket connection\"\n            },\n            id: null,\n            jsonrpc: \"2.0\"\n          });\n          return new Response(body, { status: 500 });\n        }\n\n        // Accept the WebSocket\n        ws.accept();\n\n        // Handle messages from the Durable Object\n        ws.addEventListener(\"message\", (event) => {\n          async function onMessage(event: MessageEvent) {\n            try {\n              const data =\n                typeof event.data === \"string\"\n                  ? event.data\n                  : new TextDecoder().decode(event.data);\n              const message = JSON.parse(data);\n\n              // We only forward events from the MCP server\n              if (message.type !== MessageType.CF_MCP_AGENT_EVENT) {\n                return;\n              }\n\n              // Send the message as an SSE event\n              await writer.write(encoder.encode(message.event));\n\n              // If we have received all the responses, close the connection\n              if (message.close) {\n                ws?.close();\n                await writer.close().catch(() => {});\n              }\n            } catch (error) {\n              console.error(\"Error forwarding message to SSE:\", error);\n            }\n          }\n          onMessage(event).catch(console.error);\n        });\n\n        // Handle WebSocket errors\n        ws.addEventListener(\"error\", (error) => {\n          async function onError(_error: Event) {\n            await writer.close().catch(() => {});\n          }\n          onError(error).catch(console.error);\n        });\n\n        // Handle WebSocket closure\n        ws.addEventListener(\"close\", () => {\n          async function onClose() {\n            await writer.close().catch(() => {});\n          }\n          onClose().catch(console.error);\n        });\n\n        // If there are no requests, we send the messages to the agent and acknowledge the request with a 202\n        // since we don't expect any responses back through this connection\n        const hasOnlyNotificationsOrResponses = messages.every(\n          (msg) => isJSONRPCNotification(msg) || isJSONRPCResponse(msg)\n        );\n        if (hasOnlyNotificationsOrResponses) {\n          // closing the websocket will also close the SSE connection\n          ws.close();\n\n          return new Response(null, {\n            headers: corsHeaders(request, corsOptions),\n            status: 202\n          });\n        }\n\n        // Return the SSE response. We handle closing the stream in the ws \"message\"\n        // handler\n        return new Response(readable, {\n          headers: {\n            \"Cache-Control\": \"no-cache\",\n            Connection: \"keep-alive\",\n            \"Content-Type\": \"text/event-stream\",\n            \"mcp-session-id\": sessionId,\n            ...corsHeaders(request, corsOptions)\n          },\n          status: 200\n        });\n      } else if (request.method === \"GET\") {\n        // Validate the Accept header\n        const acceptHeader = request.headers.get(\"accept\");\n        // The client MUST include an Accept header, listing both application/json and text/event-stream as supported content types.\n        if (!acceptHeader?.includes(\"text/event-stream\")) {\n          const body = JSON.stringify({\n            jsonrpc: \"2.0\",\n            error: {\n              code: -32000,\n              message: \"Not Acceptable: Client must accept text/event-stream\"\n            },\n            id: null\n          });\n          return new Response(body, { status: 406 });\n        }\n\n        // Require sessionId\n        const sessionId = request.headers.get(\"mcp-session-id\");\n        if (!sessionId)\n          return new Response(\n            JSON.stringify({\n              error: {\n                code: -32000,\n                message: \"Bad Request: Mcp-Session-Id header is required\"\n              },\n              id: null,\n              jsonrpc: \"2.0\"\n            }),\n            { status: 400 }\n          );\n\n        // Create SSE stream\n        const { readable, writable } = new TransformStream();\n        const writer = writable.getWriter();\n        const encoder = new TextEncoder();\n\n        const agent = await getAgentByName(\n          namespace,\n          `streamable-http:${sessionId}`,\n          { props: ctx.props as Record<string, unknown> | undefined }\n        );\n        const isInitialized = await agent.getInitializeRequest();\n        if (!isInitialized) {\n          return new Response(\n            JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: { code: -32001, message: \"Session not found\" },\n              id: null\n            }),\n            { status: 404 }\n          );\n        }\n\n        const existingHeaders: Record<string, string> = {};\n        request.headers.forEach((v, k) => {\n          existingHeaders[k] = v;\n        });\n\n        if (ctx.props) agent.updateProps(ctx.props as Record<string, unknown>);\n        const response = await agent.fetch(\n          new Request(request.url, {\n            headers: {\n              ...existingHeaders,\n              [MCP_HTTP_METHOD_HEADER]: \"GET\",\n              Upgrade: \"websocket\"\n            }\n          })\n        );\n\n        const ws = response.webSocket;\n        if (!ws) {\n          await writer.close();\n          return new Response(\"Failed to establish WS to DO\", {\n            status: 500\n          });\n        }\n        ws.accept();\n\n        // Forward DO messages as SSE\n        ws.addEventListener(\"message\", (event) => {\n          try {\n            async function onMessage(ev: MessageEvent) {\n              const data =\n                typeof ev.data === \"string\"\n                  ? ev.data\n                  : new TextDecoder().decode(ev.data);\n              const message = JSON.parse(data);\n\n              // We only forward events from the MCP server\n              if (message.type !== MessageType.CF_MCP_AGENT_EVENT) {\n                return;\n              }\n              await writer.write(encoder.encode(message.event));\n            }\n            onMessage(event).catch(console.error);\n          } catch (e) {\n            console.error(\"Error forwarding message to SSE:\", e);\n          }\n        });\n\n        ws.addEventListener(\"error\", () => {\n          writer.close().catch(() => {});\n        });\n        ws.addEventListener(\"close\", () => {\n          writer.close().catch(() => {});\n        });\n\n        return new Response(readable, {\n          headers: {\n            \"Cache-Control\": \"no-cache\",\n            Connection: \"keep-alive\",\n            \"Content-Type\": \"text/event-stream\",\n            \"mcp-session-id\": sessionId,\n            ...corsHeaders(request, corsOptions)\n          },\n          status: 200\n        });\n      } else if (request.method === \"DELETE\") {\n        const sessionId = request.headers.get(\"mcp-session-id\");\n        if (!sessionId) {\n          return new Response(\n            JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32000,\n                message: \"Bad Request: Mcp-Session-Id header is required\"\n              },\n              id: null\n            }),\n            { status: 400, headers: corsHeaders(request, corsOptions) }\n          );\n        }\n        const agent = await getAgentByName(\n          namespace,\n          `streamable-http:${sessionId}`\n        );\n        const isInitialized = await agent.getInitializeRequest();\n        if (!isInitialized) {\n          return new Response(\n            JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: { code: -32001, message: \"Session not found\" },\n              id: null\n            }),\n            { status: 404, headers: corsHeaders(request, corsOptions) }\n          );\n        }\n        // .destroy() passes an uncatchable Error, so we make sure we first return\n        // the response to the client.\n        ctx.waitUntil(\n          agent.destroy().catch(() => {\n            /* This will always throw. We silently catch here */\n          })\n        );\n        return new Response(null, {\n          status: 204,\n          headers: corsHeaders(request, corsOptions)\n        });\n      }\n    }\n\n    // Route not found\n    const body = JSON.stringify({\n      error: {\n        code: -32000,\n        message: \"Not found\"\n      },\n      id: null,\n      jsonrpc: \"2.0\"\n    });\n    return new Response(body, { status: 404 });\n  };\n};\n\nexport const createLegacySseHandler = (\n  basePath: string,\n  namespace: DurableObjectNamespace<McpAgent>,\n  corsOptions?: CORSOptions\n) => {\n  let pathname = basePath;\n  if (basePath === \"/\") pathname = \"/*\";\n\n  const basePattern = new URLPattern({ pathname });\n  const messagePattern = new URLPattern({ pathname: `${basePath}/message` }); // SSE only\n  return async (request: Request, ctx: ExecutionContext) => {\n    const url = new URL(request.url);\n    // Handle initial SSE connection\n    if (request.method === \"GET\" && basePattern.test(url)) {\n      // Use a session ID if one is passed in, or create a unique\n      // session ID for this connection\n      const sessionId =\n        url.searchParams.get(\"sessionId\") || namespace.newUniqueId().toString();\n\n      // Create a Transform Stream for SSE\n      const { readable, writable } = new TransformStream();\n      const writer = writable.getWriter();\n      const encoder = new TextEncoder();\n\n      // Send the endpoint event\n      const endpointUrl = new URL(request.url);\n      endpointUrl.pathname = encodeURI(`${basePath}/message`);\n      endpointUrl.searchParams.set(\"sessionId\", sessionId);\n      const relativeUrlWithSession =\n        endpointUrl.pathname + endpointUrl.search + endpointUrl.hash;\n      const endpointMessage = `event: endpoint\\ndata: ${relativeUrlWithSession}\\n\\n`;\n      writer.write(encoder.encode(endpointMessage));\n\n      // Get the Durable Object\n      const agent = await getAgentByName(namespace, `sse:${sessionId}`, {\n        props: ctx.props as Record<string, unknown> | undefined\n      });\n\n      // Connect to the Durable Object via WebSocket\n      const existingHeaders: Record<string, string> = {};\n      request.headers.forEach((value, key) => {\n        existingHeaders[key] = value;\n      });\n      if (ctx.props) agent.updateProps(ctx.props as Record<string, unknown>);\n      const response = await agent.fetch(\n        new Request(request.url, {\n          headers: {\n            ...existingHeaders,\n            Upgrade: \"websocket\"\n          }\n        })\n      );\n\n      // Get the WebSocket\n      const ws = response.webSocket;\n      if (!ws) {\n        console.error(\"Failed to establish WebSocket connection\");\n        await writer.close();\n        return new Response(\"Failed to establish WebSocket connection\", {\n          status: 500\n        });\n      }\n\n      // Accept the WebSocket\n      ws.accept();\n\n      // Handle messages from the Durable Object\n      ws.addEventListener(\"message\", (event) => {\n        async function onMessage(event: MessageEvent) {\n          try {\n            const message = JSON.parse(event.data);\n\n            // validate that the message is a valid JSONRPC message\n            const result = JSONRPCMessageSchema.safeParse(message);\n            if (!result.success) {\n              // The message was not a valid JSONRPC message, so we will drop it\n              // PartyKit will broadcast state change messages to all connected clients\n              // and we need to filter those out so they are not passed to MCP clients\n              return;\n            }\n\n            // Send the message as an SSE event\n            const messageText = `event: message\\ndata: ${JSON.stringify(result.data)}\\n\\n`;\n            await writer.write(encoder.encode(messageText));\n          } catch (error) {\n            console.error(\"Error forwarding message to SSE:\", error);\n          }\n        }\n        onMessage(event).catch(console.error);\n      });\n\n      // Handle WebSocket errors\n      ws.addEventListener(\"error\", (error) => {\n        async function onError(_error: Event) {\n          try {\n            await writer.close();\n          } catch (_e) {\n            // Ignore errors when closing\n          }\n        }\n        onError(error).catch(console.error);\n      });\n\n      // Handle WebSocket closure\n      ws.addEventListener(\"close\", () => {\n        async function onClose() {\n          try {\n            await writer.close();\n          } catch (error) {\n            console.error(\"Error closing SSE connection:\", error);\n          }\n        }\n        onClose().catch(console.error);\n      });\n\n      // Return the SSE response\n      return new Response(readable, {\n        headers: {\n          \"Cache-Control\": \"no-cache\",\n          Connection: \"keep-alive\",\n          \"Content-Type\": \"text/event-stream\",\n          ...corsHeaders(request, corsOptions)\n        }\n      });\n    }\n\n    // Handle incoming MCP messages. These will be passed to McpAgent\n    // but the response will be sent back via the open SSE connection\n    // so we only need to return a 202 Accepted response for success\n    if (request.method === \"POST\" && messagePattern.test(url)) {\n      const sessionId = url.searchParams.get(\"sessionId\");\n      if (!sessionId) {\n        return new Response(\n          `Missing sessionId. Expected POST to ${basePath} to initiate new one`,\n          { status: 400 }\n        );\n      }\n\n      const contentType = request.headers.get(\"content-type\") || \"\";\n      if (!contentType.includes(\"application/json\")) {\n        return new Response(`Unsupported content-type: ${contentType}`, {\n          status: 400\n        });\n      }\n\n      // check if the request body is too large\n      const contentLength = Number.parseInt(\n        request.headers.get(\"content-length\") || \"0\",\n        10\n      );\n      if (contentLength > MAXIMUM_MESSAGE_SIZE_BYTES) {\n        return new Response(`Request body too large: ${contentLength} bytes`, {\n          status: 400\n        });\n      }\n\n      // Get the Durable Object\n      const agent = await getAgentByName(namespace, `sse:${sessionId}`, {\n        props: ctx.props as Record<string, unknown> | undefined\n      });\n\n      const messageBody = await request.json();\n      const error = await agent.onSSEMcpMessage(sessionId, messageBody);\n\n      if (error) {\n        return new Response(error.message, {\n          headers: {\n            \"Cache-Control\": \"no-cache\",\n            Connection: \"keep-alive\",\n            \"Content-Type\": \"text/event-stream\",\n            ...corsHeaders(request, corsOptions)\n          },\n          status: 400\n        });\n      }\n\n      return new Response(\"Accepted\", {\n        headers: {\n          \"Cache-Control\": \"no-cache\",\n          Connection: \"keep-alive\",\n          \"Content-Type\": \"text/event-stream\",\n          ...corsHeaders(request, corsOptions)\n        },\n        status: 202\n      });\n    }\n\n    return new Response(\"Not Found\", { status: 404 });\n  };\n};\n\n// CORS helper functions\nfunction corsHeaders(_request: Request, corsOptions: CORSOptions = {}) {\n  const origin = \"*\";\n  return {\n    \"Access-Control-Allow-Headers\":\n      corsOptions.headers ||\n      \"Content-Type, Accept, mcp-session-id, mcp-protocol-version\",\n    \"Access-Control-Allow-Methods\":\n      corsOptions.methods || \"GET, POST, DELETE, OPTIONS\",\n    \"Access-Control-Allow-Origin\": corsOptions.origin || origin,\n    \"Access-Control-Expose-Headers\":\n      corsOptions.exposeHeaders || \"mcp-session-id\",\n    \"Access-Control-Max-Age\": (corsOptions.maxAge || 86400).toString()\n  };\n}\n\nexport function handleCORS(\n  request: Request,\n  corsOptions?: CORSOptions\n): Response | null {\n  if (request.method === \"OPTIONS\") {\n    return new Response(null, { headers: corsHeaders(request, corsOptions) });\n  }\n\n  return null;\n}\n\nexport function isDurableObjectNamespace(\n  namespace: unknown\n): namespace is DurableObjectNamespace<McpAgent> {\n  return (\n    typeof namespace === \"object\" &&\n    namespace !== null &&\n    \"newUniqueId\" in namespace &&\n    typeof namespace.newUniqueId === \"function\" &&\n    \"idFromName\" in namespace &&\n    typeof namespace.idFromName === \"function\"\n  );\n}\n","import type { Transport } from \"@modelcontextprotocol/sdk/shared/transport.js\";\nimport {\n  type MessageExtraInfo,\n  type RequestInfo,\n  isJSONRPCError,\n  isJSONRPCRequest,\n  isJSONRPCResponse,\n  type JSONRPCMessage,\n  JSONRPCMessageSchema,\n  type RequestId\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport type { AuthInfo } from \"@modelcontextprotocol/sdk/server/auth/types.js\";\nimport { getCurrentAgent, type Connection } from \"..\";\nimport type { McpAgent } from \".\";\nimport { MessageType } from \"../ai-types\";\nimport { MCP_HTTP_METHOD_HEADER, MCP_MESSAGE_HEADER } from \"./utils\";\n\nexport class McpSSETransport implements Transport {\n  sessionId?: string;\n  // Set by the server in `server.connect(transport)`\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n\n  private _getWebSocket: () => WebSocket | null;\n  private _started = false;\n  constructor(getWebSocket: () => WebSocket | null) {\n    this._getWebSocket = getWebSocket;\n  }\n\n  async start() {\n    // The transport does not manage the WebSocket connection since it's terminated\n    // by the Durable Object in order to allow hibernation. There's nothing to initialize.\n    if (this._started) {\n      throw new Error(\"Transport already started\");\n    }\n    this._started = true;\n  }\n\n  async send(message: JSONRPCMessage) {\n    if (!this._started) {\n      throw new Error(\"Transport not started\");\n    }\n    const websocket = this._getWebSocket();\n    if (!websocket) {\n      throw new Error(\"WebSocket not connected\");\n    }\n    try {\n      websocket.send(JSON.stringify(message));\n    } catch (error) {\n      this.onerror?.(error as Error);\n    }\n  }\n\n  async close() {\n    // Similar to start, the only thing to do is to pass the event on to the server\n    this.onclose?.();\n  }\n}\n\nexport type StreamId = string;\nexport type EventId = string;\n\n// TODO: Implement this and make it opt-in?\n/**\n * Interface for resumability support via event storage\n */\nexport interface EventStore {\n  /**\n   * Stores an event for later retrieval\n   * @param streamId ID of the stream the event belongs to\n   * @param message The JSON-RPC message to store\n   * @returns The generated event ID for the stored event\n   */\n  storeEvent(streamId: StreamId, message: JSONRPCMessage): Promise<EventId>;\n\n  replayEventsAfter(\n    lastEventId: EventId,\n    {\n      send\n    }: {\n      send: (eventId: EventId, message: JSONRPCMessage) => Promise<void>;\n    }\n  ): Promise<StreamId>;\n}\n\n/**\n * Configuration options for StreamableHTTPServerTransport\n */\nexport interface StreamableHTTPServerTransportOptions {\n  /**\n   * Event store for resumability support\n   * If provided, resumability will be enabled, allowing clients to reconnect and resume messages\n   */\n  eventStore?: EventStore;\n}\n\n/**\n * Adapted from: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/client/streamableHttp.ts\n * - Validation and initialization are removed as they're handled in `McpAgent.serve()` handler.\n * - Replaces the Node-style `req`/`res` with Worker's `Request`.\n * - Writes events as WS messages that the Worker forwards to the client as SSE events.\n * - Replaces the in-memory maps that track requestID/stream by using `connection.setState()` and `agent.getConnections()`.\n *\n * Besides these points, the implementation is the same and should be updated to match the original as new features are added.\n */\nexport class StreamableHTTPServerTransport implements Transport {\n  private _started = false;\n  private _eventStore?: EventStore;\n\n  // This is to keep track whether all messages from a single POST request have been answered.\n  // I's fine that we don't persist this since it's only for backwards compatibility as clients\n  // should no longer batch requests, per the spec.\n  private _requestResponseMap: Map<RequestId, JSONRPCMessage> = new Map();\n\n  sessionId: string;\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage, extra?: MessageExtraInfo) => void;\n\n  constructor(options: StreamableHTTPServerTransportOptions) {\n    const { agent } = getCurrentAgent<McpAgent>();\n    if (!agent)\n      throw new Error(\"McpAgent was not found in Transport constructor\");\n\n    // Initialization is handled in `McpAgent.serve()` and agents are addressed by sessionId,\n    // so we'll always have this available.\n    this.sessionId = agent.getSessionId();\n    this._eventStore = options.eventStore;\n  }\n\n  /**\n   * Starts the transport. This is required by the Transport interface but is a no-op\n   * for the Streamable HTTP transport as connections are managed per-request.\n   */\n  async start(): Promise<void> {\n    if (this._started) {\n      throw new Error(\"Transport already started\");\n    }\n    this._started = true;\n  }\n\n  /**\n   * Handles GET requests for SSE stream\n   */\n  async handleGetRequest(req: Request): Promise<void> {\n    // Get the WS connection so we can tag it as the standalone stream\n    const { connection } = getCurrentAgent();\n    if (!connection)\n      throw new Error(\"Connection was not found in handleGetRequest\");\n\n    // Handle resumability: check for Last-Event-ID header\n    if (this._eventStore) {\n      const lastEventId = req.headers.get(\"last-event-id\");\n      if (lastEventId) {\n        await this.replayEvents(lastEventId);\n        return;\n      }\n    }\n\n    connection.setState({\n      _standaloneSse: true\n    });\n  }\n\n  /**\n   * Replays events that would have been sent after the specified event ID\n   * Only used when resumability is enabled\n   */\n  private async replayEvents(lastEventId: string): Promise<void> {\n    if (!this._eventStore) {\n      return;\n    }\n\n    const { connection } = getCurrentAgent();\n    if (!connection)\n      throw new Error(\"Connection was not available in replayEvents\");\n\n    try {\n      await this._eventStore?.replayEventsAfter(lastEventId, {\n        send: async (eventId: string, message: JSONRPCMessage) => {\n          try {\n            this.writeSSEEvent(connection, message, eventId);\n          } catch (error) {\n            this.onerror?.(error as Error);\n          }\n        }\n      });\n    } catch (error) {\n      this.onerror?.(error as Error);\n    }\n  }\n\n  /**\n   * Writes an event to the SSE stream with proper formatting\n   */\n  private writeSSEEvent(\n    connection: Connection,\n    message: JSONRPCMessage,\n    eventId?: string,\n    close?: boolean\n  ) {\n    let eventData = \"event: message\\n\";\n    // Include event ID if provided - this is important for resumability\n    if (eventId) {\n      eventData += `id: ${eventId}\\n`;\n    }\n    eventData += `data: ${JSON.stringify(message)}\\n\\n`;\n\n    return connection.send(\n      JSON.stringify({\n        type: MessageType.CF_MCP_AGENT_EVENT,\n        event: eventData,\n        close\n      })\n    );\n  }\n\n  /**\n   * Handles POST requests containing JSON-RPC messages\n   */\n  async handlePostRequest(\n    req: Request & { auth?: AuthInfo },\n    parsedBody: unknown\n  ): Promise<void> {\n    const authInfo: AuthInfo | undefined = req.auth;\n    const requestInfo: RequestInfo = {\n      headers: Object.fromEntries(req.headers.entries())\n    };\n    // Remove headers that are not part of the original request\n    delete requestInfo.headers[MCP_HTTP_METHOD_HEADER];\n    delete requestInfo.headers[MCP_MESSAGE_HEADER];\n    delete requestInfo.headers.upgrade;\n\n    const rawMessage = parsedBody;\n    let messages: JSONRPCMessage[];\n\n    // handle batch and single messages\n    if (Array.isArray(rawMessage)) {\n      messages = rawMessage.map((msg) => JSONRPCMessageSchema.parse(msg));\n    } else {\n      messages = [JSONRPCMessageSchema.parse(rawMessage)];\n    }\n\n    // check if it contains requests\n    const hasRequests = messages.some(isJSONRPCRequest);\n\n    if (!hasRequests) {\n      // We process without sending anything\n      for (const message of messages) {\n        this.onmessage?.(message, { authInfo, requestInfo });\n      }\n    } else if (hasRequests) {\n      const { connection } = getCurrentAgent();\n      if (!connection)\n        throw new Error(\"Connection was not found in handlePostRequest\");\n\n      // We need to track by request ID to maintain the connection\n      const requestIds = messages\n        .filter(isJSONRPCRequest)\n        .map((message) => message.id);\n\n      connection.setState({\n        requestIds\n      });\n\n      // handle each message\n      for (const message of messages) {\n        this.onmessage?.(message, { authInfo, requestInfo });\n      }\n      // The server SHOULD NOT close the SSE stream before sending all JSON-RPC responses\n      // This will be handled by the send() method when responses are ready\n    }\n  }\n\n  async close(): Promise<void> {\n    // Close all SSE connections\n    const { agent } = getCurrentAgent();\n    if (!agent) throw new Error(\"Agent was not found in close\");\n\n    for (const conn of agent.getConnections()) {\n      conn.close(1000, \"Session closed\");\n    }\n    this.onclose?.();\n  }\n\n  async send(\n    message: JSONRPCMessage,\n    options?: { relatedRequestId?: RequestId }\n  ): Promise<void> {\n    const { agent } = getCurrentAgent();\n    if (!agent) throw new Error(\"Agent was not found in send\");\n\n    let requestId = options?.relatedRequestId;\n    if (isJSONRPCResponse(message) || isJSONRPCError(message)) {\n      // If the message is a response, use the request ID from the message\n      requestId = message.id;\n    }\n\n    // Check if this message should be sent on the standalone SSE stream (no request ID)\n    // Ignore notifications from tools (which have relatedRequestId set)\n    // Those will be sent via dedicated response SSE streams\n    if (requestId === undefined) {\n      // For standalone SSE streams, we can only send requests and notifications\n      if (isJSONRPCResponse(message) || isJSONRPCError(message)) {\n        throw new Error(\n          \"Cannot send a response on a standalone SSE stream unless resuming a previous client request\"\n        );\n      }\n\n      let standaloneConnection: Connection | undefined;\n      for (const conn of agent.getConnections<{ _standaloneSse?: boolean }>()) {\n        if (conn.state?._standaloneSse) standaloneConnection = conn;\n      }\n\n      if (standaloneConnection === undefined) {\n        // The spec says the server MAY send messages on the stream, so it's ok to discard if no stream\n        return;\n      }\n\n      // Generate and store event ID if event store is provided\n      let eventId: string | undefined;\n      if (this._eventStore) {\n        // Stores the event and gets the generated event ID\n        eventId = await this._eventStore.storeEvent(\n          standaloneConnection.id,\n          message\n        );\n      }\n\n      // Send the message to the standalone SSE stream\n      this.writeSSEEvent(standaloneConnection, message, eventId);\n      return;\n    }\n\n    // Get the response for this request\n    const connection = Array.from(\n      agent.getConnections<{ requestIds?: number[] }>()\n    ).find((conn) => conn.state?.requestIds?.includes(requestId as number));\n    if (!connection) {\n      throw new Error(\n        `No connection established for request ID: ${String(requestId)}`\n      );\n    }\n\n    let eventId: string | undefined;\n\n    if (this._eventStore) {\n      eventId = await this._eventStore.storeEvent(connection.id, message);\n    }\n\n    let shouldClose = false;\n\n    if (isJSONRPCResponse(message) || isJSONRPCError(message)) {\n      this._requestResponseMap.set(requestId, message);\n      const relatedIds = connection.state?.requestIds ?? [];\n      // Check if we have responses for all requests using this connection\n      shouldClose = relatedIds.every((id) => this._requestResponseMap.has(id));\n\n      if (shouldClose) {\n        // Clean up\n        for (const id of relatedIds) {\n          this._requestResponseMap.delete(id);\n        }\n      }\n    }\n    this.writeSSEEvent(connection, message, eventId, shouldClose);\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;AAIA;AAAA,EACE,wBAAAA;AAAA,EACA,kBAAAC;AAAA,EACA,qBAAAC;AAAA,OAEK;;;ACTP;AAAA,EACE;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAYA,IAAM,yBAAyB;AAO/B,IAAM,qBAAqB;AAElC,IAAM,6BAA6B,IAAI,OAAO;AAEvC,IAAM,6BAA6B,CACxC,UACA,WACA,gBACG;AACH,MAAI,WAAW;AACf,MAAI,aAAa,IAAK,YAAW;AAEjC,QAAM,cAAc,IAAI,WAAW,EAAE,SAAS,CAAC;AAC/C,SAAO,OAAO,SAAkB,QAA0B;AACxD,UAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;AAC/B,QAAI,YAAY,KAAK,GAAG,GAAG;AACzB,UAAI,QAAQ,WAAW,QAAQ;AAE7B,cAAM,eAAe,QAAQ,QAAQ,IAAI,QAAQ;AAEjD,YACE,CAAC,cAAc,SAAS,kBAAkB,KAC1C,CAAC,aAAa,SAAS,mBAAmB,GAC1C;AACA,gBAAMC,QAAO,KAAK,UAAU;AAAA,YAC1B,OAAO;AAAA,cACL,MAAM;AAAA,cACN,SACE;AAAA,YACJ;AAAA,YACA,IAAI;AAAA,YACJ,SAAS;AAAA,UACX,CAAC;AACD,iBAAO,IAAI,SAASA,OAAM,EAAE,QAAQ,IAAI,CAAC;AAAA,QAC3C;AAEA,cAAM,KAAK,QAAQ,QAAQ,IAAI,cAAc;AAC7C,YAAI,CAAC,MAAM,CAAC,GAAG,SAAS,kBAAkB,GAAG;AAC3C,gBAAMA,QAAO,KAAK,UAAU;AAAA,YAC1B,OAAO;AAAA,cACL,MAAM;AAAA,cACN,SACE;AAAA,YACJ;AAAA,YACA,IAAI;AAAA,YACJ,SAAS;AAAA,UACX,CAAC;AACD,iBAAO,IAAI,SAASA,OAAM,EAAE,QAAQ,IAAI,CAAC;AAAA,QAC3C;AAGA,cAAM,gBAAgB,OAAO;AAAA,UAC3B,QAAQ,QAAQ,IAAI,gBAAgB,KAAK;AAAA,UACzC;AAAA,QACF;AACA,YAAI,gBAAgB,4BAA4B;AAC9C,gBAAMA,QAAO,KAAK,UAAU;AAAA,YAC1B,OAAO;AAAA,cACL,MAAM;AAAA,cACN,SAAS,2CAA2C,0BAA0B;AAAA,YAChF;AAAA,YACA,IAAI;AAAA,YACJ,SAAS;AAAA,UACX,CAAC;AACD,iBAAO,IAAI,SAASA,OAAM,EAAE,QAAQ,IAAI,CAAC;AAAA,QAC3C;AAEA,YAAI,YAAY,QAAQ,QAAQ,IAAI,gBAAgB;AACpD,YAAI;AAEJ,YAAI;AACF,uBAAa,MAAM,QAAQ,KAAK;AAAA,QAClC,SAAS,QAAQ;AACf,gBAAMA,QAAO,KAAK,UAAU;AAAA,YAC1B,OAAO;AAAA,cACL,MAAM;AAAA,cACN,SAAS;AAAA,YACX;AAAA,YACA,IAAI;AAAA,YACJ,SAAS;AAAA,UACX,CAAC;AACD,iBAAO,IAAI,SAASA,OAAM,EAAE,QAAQ,IAAI,CAAC;AAAA,QAC3C;AAGA,YAAI;AACJ,YAAI,MAAM,QAAQ,UAAU,GAAG;AAC7B,yBAAe;AAAA,QACjB,OAAO;AACL,yBAAe,CAAC,UAAU;AAAA,QAC5B;AAEA,YAAI,WAA6B,CAAC;AAGlC,mBAAW,OAAO,cAAc;AAC9B,cAAI,CAAC,qBAAqB,UAAU,GAAG,EAAE,SAAS;AAChD,kBAAMA,QAAO,KAAK,UAAU;AAAA,cAC1B,OAAO;AAAA,gBACL,MAAM;AAAA,gBACN,SAAS;AAAA,cACX;AAAA,cACA,IAAI;AAAA,cACJ,SAAS;AAAA,YACX,CAAC;AACD,mBAAO,IAAI,SAASA,OAAM,EAAE,QAAQ,IAAI,CAAC;AAAA,UAC3C;AAAA,QACF;AAEA,mBAAW,aAAa,IAAI,CAAC,QAAQ,qBAAqB,MAAM,GAAG,CAAC;AAKpE,cAAM,yBAAyB,SAAS;AAAA,UACtC,CAAC,QAAQ,wBAAwB,UAAU,GAAG,EAAE;AAAA,QAClD;AAEA,YAAI,CAAC,CAAC,0BAA0B,WAAW;AACzC,gBAAMA,QAAO,KAAK,UAAU;AAAA,YAC1B,OAAO;AAAA,cACL,MAAM;AAAA,cACN,SACE;AAAA,YACJ;AAAA,YACA,IAAI;AAAA,YACJ,SAAS;AAAA,UACX,CAAC;AACD,iBAAO,IAAI,SAASA,OAAM,EAAE,QAAQ,IAAI,CAAC;AAAA,QAC3C;AAGA,YAAI,CAAC,CAAC,0BAA0B,SAAS,SAAS,GAAG;AACnD,gBAAMA,QAAO,KAAK,UAAU;AAAA,YAC1B,OAAO;AAAA,cACL,MAAM;AAAA,cACN,SACE;AAAA,YACJ;AAAA,YACA,IAAI;AAAA,YACJ,SAAS;AAAA,UACX,CAAC;AACD,iBAAO,IAAI,SAASA,OAAM,EAAE,QAAQ,IAAI,CAAC;AAAA,QAC3C;AAKA,YAAI,CAAC,0BAA0B,CAAC,WAAW;AACzC,gBAAMA,QAAO,KAAK,UAAU;AAAA,YAC1B,OAAO;AAAA,cACL,MAAM;AAAA,cACN,SAAS;AAAA,YACX;AAAA,YACA,IAAI;AAAA,YACJ,SAAS;AAAA,UACX,CAAC;AACD,iBAAO,IAAI,SAASA,OAAM,EAAE,QAAQ,IAAI,CAAC;AAAA,QAC3C;AAIA,oBAAY,aAAa,UAAU,YAAY,EAAE,SAAS;AAG1D,cAAM,QAAQ,MAAM;AAAA,UAClB;AAAA,UACA,mBAAmB,SAAS;AAAA,UAC5B,EAAE,OAAO,IAAI,MAA6C;AAAA,QAC5D;AACA,cAAM,gBAAgB,MAAM,MAAM,qBAAqB;AAEvD,YAAI,wBAAwB;AAC1B,gBAAM,MAAM,qBAAqB,sBAAsB;AAAA,QACzD,WAAW,CAAC,eAAe;AAGzB,gBAAMA,QAAO,KAAK,UAAU;AAAA,YAC1B,OAAO;AAAA,cACL,MAAM;AAAA,cACN,SAAS;AAAA,YACX;AAAA,YACA,IAAI;AAAA,YACJ,SAAS;AAAA,UACX,CAAC;AACD,iBAAO,IAAI,SAASA,OAAM,EAAE,QAAQ,IAAI,CAAC;AAAA,QAC3C;AAMA,cAAM,EAAE,UAAU,SAAS,IAAI,IAAI,gBAAgB;AACnD,cAAM,SAAS,SAAS,UAAU;AAClC,cAAM,UAAU,IAAI,YAAY;AAGhC,cAAM,kBAA0C,CAAC;AACjD,gBAAQ,QAAQ,QAAQ,CAAC,OAAO,QAAQ;AACtC,0BAAgB,GAAG,IAAI;AAAA,QACzB,CAAC;AACD,cAAM,MAAM,IAAI,QAAQ,QAAQ,KAAK;AAAA,UACnC,SAAS;AAAA,YACP,GAAG;AAAA,YACH,CAAC,sBAAsB,GAAG;AAAA,YAC1B,CAAC,kBAAkB,GAAG,KAAK,UAAU,QAAQ;AAAA,YAC7C,SAAS;AAAA,UACX;AAAA,QACF,CAAC;AACD,YAAI,IAAI,MAAO,OAAM,YAAY,IAAI,KAAgC;AACrE,cAAM,WAAW,MAAM,MAAM,MAAM,GAAG;AAGtC,cAAM,KAAK,SAAS;AACpB,YAAI,CAAC,IAAI;AACP,kBAAQ,MAAM,0CAA0C;AAExD,gBAAM,OAAO,MAAM;AACnB,gBAAMA,QAAO,KAAK,UAAU;AAAA,YAC1B,OAAO;AAAA,cACL,MAAM;AAAA,cACN,SAAS;AAAA,YACX;AAAA,YACA,IAAI;AAAA,YACJ,SAAS;AAAA,UACX,CAAC;AACD,iBAAO,IAAI,SAASA,OAAM,EAAE,QAAQ,IAAI,CAAC;AAAA,QAC3C;AAGA,WAAG,OAAO;AAGV,WAAG,iBAAiB,WAAW,CAAC,UAAU;AACxC,yBAAe,UAAUC,QAAqB;AAC5C,gBAAI;AACF,oBAAM,OACJ,OAAOA,OAAM,SAAS,WAClBA,OAAM,OACN,IAAI,YAAY,EAAE,OAAOA,OAAM,IAAI;AACzC,oBAAM,UAAU,KAAK,MAAM,IAAI;AAG/B,kBAAI,QAAQ,wDAAyC;AACnD;AAAA,cACF;AAGA,oBAAM,OAAO,MAAM,QAAQ,OAAO,QAAQ,KAAK,CAAC;AAGhD,kBAAI,QAAQ,OAAO;AACjB,oBAAI,MAAM;AACV,sBAAM,OAAO,MAAM,EAAE,MAAM,MAAM;AAAA,gBAAC,CAAC;AAAA,cACrC;AAAA,YACF,SAAS,OAAO;AACd,sBAAQ,MAAM,oCAAoC,KAAK;AAAA,YACzD;AAAA,UACF;AACA,oBAAU,KAAK,EAAE,MAAM,QAAQ,KAAK;AAAA,QACtC,CAAC;AAGD,WAAG,iBAAiB,SAAS,CAAC,UAAU;AACtC,yBAAe,QAAQ,QAAe;AACpC,kBAAM,OAAO,MAAM,EAAE,MAAM,MAAM;AAAA,YAAC,CAAC;AAAA,UACrC;AACA,kBAAQ,KAAK,EAAE,MAAM,QAAQ,KAAK;AAAA,QACpC,CAAC;AAGD,WAAG,iBAAiB,SAAS,MAAM;AACjC,yBAAe,UAAU;AACvB,kBAAM,OAAO,MAAM,EAAE,MAAM,MAAM;AAAA,YAAC,CAAC;AAAA,UACrC;AACA,kBAAQ,EAAE,MAAM,QAAQ,KAAK;AAAA,QAC/B,CAAC;AAID,cAAM,kCAAkC,SAAS;AAAA,UAC/C,CAAC,QAAQ,sBAAsB,GAAG,KAAK,kBAAkB,GAAG;AAAA,QAC9D;AACA,YAAI,iCAAiC;AAEnC,aAAG,MAAM;AAET,iBAAO,IAAI,SAAS,MAAM;AAAA,YACxB,SAAS,YAAY,SAAS,WAAW;AAAA,YACzC,QAAQ;AAAA,UACV,CAAC;AAAA,QACH;AAIA,eAAO,IAAI,SAAS,UAAU;AAAA,UAC5B,SAAS;AAAA,YACP,iBAAiB;AAAA,YACjB,YAAY;AAAA,YACZ,gBAAgB;AAAA,YAChB,kBAAkB;AAAA,YAClB,GAAG,YAAY,SAAS,WAAW;AAAA,UACrC;AAAA,UACA,QAAQ;AAAA,QACV,CAAC;AAAA,MACH,WAAW,QAAQ,WAAW,OAAO;AAEnC,cAAM,eAAe,QAAQ,QAAQ,IAAI,QAAQ;AAEjD,YAAI,CAAC,cAAc,SAAS,mBAAmB,GAAG;AAChD,gBAAMD,QAAO,KAAK,UAAU;AAAA,YAC1B,SAAS;AAAA,YACT,OAAO;AAAA,cACL,MAAM;AAAA,cACN,SAAS;AAAA,YACX;AAAA,YACA,IAAI;AAAA,UACN,CAAC;AACD,iBAAO,IAAI,SAASA,OAAM,EAAE,QAAQ,IAAI,CAAC;AAAA,QAC3C;AAGA,cAAM,YAAY,QAAQ,QAAQ,IAAI,gBAAgB;AACtD,YAAI,CAAC;AACH,iBAAO,IAAI;AAAA,YACT,KAAK,UAAU;AAAA,cACb,OAAO;AAAA,gBACL,MAAM;AAAA,gBACN,SAAS;AAAA,cACX;AAAA,cACA,IAAI;AAAA,cACJ,SAAS;AAAA,YACX,CAAC;AAAA,YACD,EAAE,QAAQ,IAAI;AAAA,UAChB;AAGF,cAAM,EAAE,UAAU,SAAS,IAAI,IAAI,gBAAgB;AACnD,cAAM,SAAS,SAAS,UAAU;AAClC,cAAM,UAAU,IAAI,YAAY;AAEhC,cAAM,QAAQ,MAAM;AAAA,UAClB;AAAA,UACA,mBAAmB,SAAS;AAAA,UAC5B,EAAE,OAAO,IAAI,MAA6C;AAAA,QAC5D;AACA,cAAM,gBAAgB,MAAM,MAAM,qBAAqB;AACvD,YAAI,CAAC,eAAe;AAClB,iBAAO,IAAI;AAAA,YACT,KAAK,UAAU;AAAA,cACb,SAAS;AAAA,cACT,OAAO,EAAE,MAAM,QAAQ,SAAS,oBAAoB;AAAA,cACpD,IAAI;AAAA,YACN,CAAC;AAAA,YACD,EAAE,QAAQ,IAAI;AAAA,UAChB;AAAA,QACF;AAEA,cAAM,kBAA0C,CAAC;AACjD,gBAAQ,QAAQ,QAAQ,CAAC,GAAG,MAAM;AAChC,0BAAgB,CAAC,IAAI;AAAA,QACvB,CAAC;AAED,YAAI,IAAI,MAAO,OAAM,YAAY,IAAI,KAAgC;AACrE,cAAM,WAAW,MAAM,MAAM;AAAA,UAC3B,IAAI,QAAQ,QAAQ,KAAK;AAAA,YACvB,SAAS;AAAA,cACP,GAAG;AAAA,cACH,CAAC,sBAAsB,GAAG;AAAA,cAC1B,SAAS;AAAA,YACX;AAAA,UACF,CAAC;AAAA,QACH;AAEA,cAAM,KAAK,SAAS;AACpB,YAAI,CAAC,IAAI;AACP,gBAAM,OAAO,MAAM;AACnB,iBAAO,IAAI,SAAS,gCAAgC;AAAA,YAClD,QAAQ;AAAA,UACV,CAAC;AAAA,QACH;AACA,WAAG,OAAO;AAGV,WAAG,iBAAiB,WAAW,CAAC,UAAU;AACxC,cAAI;AACF,2BAAe,UAAU,IAAkB;AACzC,oBAAM,OACJ,OAAO,GAAG,SAAS,WACf,GAAG,OACH,IAAI,YAAY,EAAE,OAAO,GAAG,IAAI;AACtC,oBAAM,UAAU,KAAK,MAAM,IAAI;AAG/B,kBAAI,QAAQ,wDAAyC;AACnD;AAAA,cACF;AACA,oBAAM,OAAO,MAAM,QAAQ,OAAO,QAAQ,KAAK,CAAC;AAAA,YAClD;AACA,sBAAU,KAAK,EAAE,MAAM,QAAQ,KAAK;AAAA,UACtC,SAAS,GAAG;AACV,oBAAQ,MAAM,oCAAoC,CAAC;AAAA,UACrD;AAAA,QACF,CAAC;AAED,WAAG,iBAAiB,SAAS,MAAM;AACjC,iBAAO,MAAM,EAAE,MAAM,MAAM;AAAA,UAAC,CAAC;AAAA,QAC/B,CAAC;AACD,WAAG,iBAAiB,SAAS,MAAM;AACjC,iBAAO,MAAM,EAAE,MAAM,MAAM;AAAA,UAAC,CAAC;AAAA,QAC/B,CAAC;AAED,eAAO,IAAI,SAAS,UAAU;AAAA,UAC5B,SAAS;AAAA,YACP,iBAAiB;AAAA,YACjB,YAAY;AAAA,YACZ,gBAAgB;AAAA,YAChB,kBAAkB;AAAA,YAClB,GAAG,YAAY,SAAS,WAAW;AAAA,UACrC;AAAA,UACA,QAAQ;AAAA,QACV,CAAC;AAAA,MACH,WAAW,QAAQ,WAAW,UAAU;AACtC,cAAM,YAAY,QAAQ,QAAQ,IAAI,gBAAgB;AACtD,YAAI,CAAC,WAAW;AACd,iBAAO,IAAI;AAAA,YACT,KAAK,UAAU;AAAA,cACb,SAAS;AAAA,cACT,OAAO;AAAA,gBACL,MAAM;AAAA,gBACN,SAAS;AAAA,cACX;AAAA,cACA,IAAI;AAAA,YACN,CAAC;AAAA,YACD,EAAE,QAAQ,KAAK,SAAS,YAAY,SAAS,WAAW,EAAE;AAAA,UAC5D;AAAA,QACF;AACA,cAAM,QAAQ,MAAM;AAAA,UAClB;AAAA,UACA,mBAAmB,SAAS;AAAA,QAC9B;AACA,cAAM,gBAAgB,MAAM,MAAM,qBAAqB;AACvD,YAAI,CAAC,eAAe;AAClB,iBAAO,IAAI;AAAA,YACT,KAAK,UAAU;AAAA,cACb,SAAS;AAAA,cACT,OAAO,EAAE,MAAM,QAAQ,SAAS,oBAAoB;AAAA,cACpD,IAAI;AAAA,YACN,CAAC;AAAA,YACD,EAAE,QAAQ,KAAK,SAAS,YAAY,SAAS,WAAW,EAAE;AAAA,UAC5D;AAAA,QACF;AAGA,YAAI;AAAA,UACF,MAAM,QAAQ,EAAE,MAAM,MAAM;AAAA,UAE5B,CAAC;AAAA,QACH;AACA,eAAO,IAAI,SAAS,MAAM;AAAA,UACxB,QAAQ;AAAA,UACR,SAAS,YAAY,SAAS,WAAW;AAAA,QAC3C,CAAC;AAAA,MACH;AAAA,IACF;AAGA,UAAM,OAAO,KAAK,UAAU;AAAA,MAC1B,OAAO;AAAA,QACL,MAAM;AAAA,QACN,SAAS;AAAA,MACX;AAAA,MACA,IAAI;AAAA,MACJ,SAAS;AAAA,IACX,CAAC;AACD,WAAO,IAAI,SAAS,MAAM,EAAE,QAAQ,IAAI,CAAC;AAAA,EAC3C;AACF;AAEO,IAAM,yBAAyB,CACpC,UACA,WACA,gBACG;AACH,MAAI,WAAW;AACf,MAAI,aAAa,IAAK,YAAW;AAEjC,QAAM,cAAc,IAAI,WAAW,EAAE,SAAS,CAAC;AAC/C,QAAM,iBAAiB,IAAI,WAAW,EAAE,UAAU,GAAG,QAAQ,WAAW,CAAC;AACzE,SAAO,OAAO,SAAkB,QAA0B;AACxD,UAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;AAE/B,QAAI,QAAQ,WAAW,SAAS,YAAY,KAAK,GAAG,GAAG;AAGrD,YAAM,YACJ,IAAI,aAAa,IAAI,WAAW,KAAK,UAAU,YAAY,EAAE,SAAS;AAGxE,YAAM,EAAE,UAAU,SAAS,IAAI,IAAI,gBAAgB;AACnD,YAAM,SAAS,SAAS,UAAU;AAClC,YAAM,UAAU,IAAI,YAAY;AAGhC,YAAM,cAAc,IAAI,IAAI,QAAQ,GAAG;AACvC,kBAAY,WAAW,UAAU,GAAG,QAAQ,UAAU;AACtD,kBAAY,aAAa,IAAI,aAAa,SAAS;AACnD,YAAM,yBACJ,YAAY,WAAW,YAAY,SAAS,YAAY;AAC1D,YAAM,kBAAkB;AAAA,QAA0B,sBAAsB;AAAA;AAAA;AACxE,aAAO,MAAM,QAAQ,OAAO,eAAe,CAAC;AAG5C,YAAM,QAAQ,MAAM,eAAe,WAAW,OAAO,SAAS,IAAI;AAAA,QAChE,OAAO,IAAI;AAAA,MACb,CAAC;AAGD,YAAM,kBAA0C,CAAC;AACjD,cAAQ,QAAQ,QAAQ,CAAC,OAAO,QAAQ;AACtC,wBAAgB,GAAG,IAAI;AAAA,MACzB,CAAC;AACD,UAAI,IAAI,MAAO,OAAM,YAAY,IAAI,KAAgC;AACrE,YAAM,WAAW,MAAM,MAAM;AAAA,QAC3B,IAAI,QAAQ,QAAQ,KAAK;AAAA,UACvB,SAAS;AAAA,YACP,GAAG;AAAA,YACH,SAAS;AAAA,UACX;AAAA,QACF,CAAC;AAAA,MACH;AAGA,YAAM,KAAK,SAAS;AACpB,UAAI,CAAC,IAAI;AACP,gBAAQ,MAAM,0CAA0C;AACxD,cAAM,OAAO,MAAM;AACnB,eAAO,IAAI,SAAS,4CAA4C;AAAA,UAC9D,QAAQ;AAAA,QACV,CAAC;AAAA,MACH;AAGA,SAAG,OAAO;AAGV,SAAG,iBAAiB,WAAW,CAAC,UAAU;AACxC,uBAAe,UAAUC,QAAqB;AAC5C,cAAI;AACF,kBAAM,UAAU,KAAK,MAAMA,OAAM,IAAI;AAGrC,kBAAM,SAAS,qBAAqB,UAAU,OAAO;AACrD,gBAAI,CAAC,OAAO,SAAS;AAInB;AAAA,YACF;AAGA,kBAAM,cAAc;AAAA,QAAyB,KAAK,UAAU,OAAO,IAAI,CAAC;AAAA;AAAA;AACxE,kBAAM,OAAO,MAAM,QAAQ,OAAO,WAAW,CAAC;AAAA,UAChD,SAAS,OAAO;AACd,oBAAQ,MAAM,oCAAoC,KAAK;AAAA,UACzD;AAAA,QACF;AACA,kBAAU,KAAK,EAAE,MAAM,QAAQ,KAAK;AAAA,MACtC,CAAC;AAGD,SAAG,iBAAiB,SAAS,CAAC,UAAU;AACtC,uBAAe,QAAQ,QAAe;AACpC,cAAI;AACF,kBAAM,OAAO,MAAM;AAAA,UACrB,SAAS,IAAI;AAAA,UAEb;AAAA,QACF;AACA,gBAAQ,KAAK,EAAE,MAAM,QAAQ,KAAK;AAAA,MACpC,CAAC;AAGD,SAAG,iBAAiB,SAAS,MAAM;AACjC,uBAAe,UAAU;AACvB,cAAI;AACF,kBAAM,OAAO,MAAM;AAAA,UACrB,SAAS,OAAO;AACd,oBAAQ,MAAM,iCAAiC,KAAK;AAAA,UACtD;AAAA,QACF;AACA,gBAAQ,EAAE,MAAM,QAAQ,KAAK;AAAA,MAC/B,CAAC;AAGD,aAAO,IAAI,SAAS,UAAU;AAAA,QAC5B,SAAS;AAAA,UACP,iBAAiB;AAAA,UACjB,YAAY;AAAA,UACZ,gBAAgB;AAAA,UAChB,GAAG,YAAY,SAAS,WAAW;AAAA,QACrC;AAAA,MACF,CAAC;AAAA,IACH;AAKA,QAAI,QAAQ,WAAW,UAAU,eAAe,KAAK,GAAG,GAAG;AACzD,YAAM,YAAY,IAAI,aAAa,IAAI,WAAW;AAClD,UAAI,CAAC,WAAW;AACd,eAAO,IAAI;AAAA,UACT,uCAAuC,QAAQ;AAAA,UAC/C,EAAE,QAAQ,IAAI;AAAA,QAChB;AAAA,MACF;AAEA,YAAM,cAAc,QAAQ,QAAQ,IAAI,cAAc,KAAK;AAC3D,UAAI,CAAC,YAAY,SAAS,kBAAkB,GAAG;AAC7C,eAAO,IAAI,SAAS,6BAA6B,WAAW,IAAI;AAAA,UAC9D,QAAQ;AAAA,QACV,CAAC;AAAA,MACH;AAGA,YAAM,gBAAgB,OAAO;AAAA,QAC3B,QAAQ,QAAQ,IAAI,gBAAgB,KAAK;AAAA,QACzC;AAAA,MACF;AACA,UAAI,gBAAgB,4BAA4B;AAC9C,eAAO,IAAI,SAAS,2BAA2B,aAAa,UAAU;AAAA,UACpE,QAAQ;AAAA,QACV,CAAC;AAAA,MACH;AAGA,YAAM,QAAQ,MAAM,eAAe,WAAW,OAAO,SAAS,IAAI;AAAA,QAChE,OAAO,IAAI;AAAA,MACb,CAAC;AAED,YAAM,cAAc,MAAM,QAAQ,KAAK;AACvC,YAAM,QAAQ,MAAM,MAAM,gBAAgB,WAAW,WAAW;AAEhE,UAAI,OAAO;AACT,eAAO,IAAI,SAAS,MAAM,SAAS;AAAA,UACjC,SAAS;AAAA,YACP,iBAAiB;AAAA,YACjB,YAAY;AAAA,YACZ,gBAAgB;AAAA,YAChB,GAAG,YAAY,SAAS,WAAW;AAAA,UACrC;AAAA,UACA,QAAQ;AAAA,QACV,CAAC;AAAA,MACH;AAEA,aAAO,IAAI,SAAS,YAAY;AAAA,QAC9B,SAAS;AAAA,UACP,iBAAiB;AAAA,UACjB,YAAY;AAAA,UACZ,gBAAgB;AAAA,UAChB,GAAG,YAAY,SAAS,WAAW;AAAA,QACrC;AAAA,QACA,QAAQ;AAAA,MACV,CAAC;AAAA,IACH;AAEA,WAAO,IAAI,SAAS,aAAa,EAAE,QAAQ,IAAI,CAAC;AAAA,EAClD;AACF;AAGA,SAAS,YAAY,UAAmB,cAA2B,CAAC,GAAG;AACrE,QAAM,SAAS;AACf,SAAO;AAAA,IACL,gCACE,YAAY,WACZ;AAAA,IACF,gCACE,YAAY,WAAW;AAAA,IACzB,+BAA+B,YAAY,UAAU;AAAA,IACrD,iCACE,YAAY,iBAAiB;AAAA,IAC/B,2BAA2B,YAAY,UAAU,OAAO,SAAS;AAAA,EACnE;AACF;AAEO,SAAS,WACd,SACA,aACiB;AACjB,MAAI,QAAQ,WAAW,WAAW;AAChC,WAAO,IAAI,SAAS,MAAM,EAAE,SAAS,YAAY,SAAS,WAAW,EAAE,CAAC;AAAA,EAC1E;AAEA,SAAO;AACT;AAEO,SAAS,yBACd,WAC+C;AAC/C,SACE,OAAO,cAAc,YACrB,cAAc,QACd,iBAAiB,aACjB,OAAO,UAAU,gBAAgB,cACjC,gBAAgB,aAChB,OAAO,UAAU,eAAe;AAEpC;;;AC5tBA;AAAA,EAGE;AAAA,EACA;AAAA,EACA,qBAAAC;AAAA,EAEA,wBAAAC;AAAA,OAEK;AAOA,IAAM,kBAAN,MAA2C;AAAA,EAShD,YAAY,cAAsC;AADlD,SAAQ,WAAW;AAEjB,SAAK,gBAAgB;AAAA,EACvB;AAAA,EAEA,MAAM,QAAQ;AAGZ,QAAI,KAAK,UAAU;AACjB,YAAM,IAAI,MAAM,2BAA2B;AAAA,IAC7C;AACA,SAAK,WAAW;AAAA,EAClB;AAAA,EAEA,MAAM,KAAK,SAAyB;AAClC,QAAI,CAAC,KAAK,UAAU;AAClB,YAAM,IAAI,MAAM,uBAAuB;AAAA,IACzC;AACA,UAAM,YAAY,KAAK,cAAc;AACrC,QAAI,CAAC,WAAW;AACd,YAAM,IAAI,MAAM,yBAAyB;AAAA,IAC3C;AACA,QAAI;AACF,gBAAU,KAAK,KAAK,UAAU,OAAO,CAAC;AAAA,IACxC,SAAS,OAAO;AACd,WAAK,UAAU,KAAc;AAAA,IAC/B;AAAA,EACF;AAAA,EAEA,MAAM,QAAQ;AAEZ,SAAK,UAAU;AAAA,EACjB;AACF;AAgDO,IAAM,gCAAN,MAAyD;AAAA,EAc9D,YAAY,SAA+C;AAb3D,SAAQ,WAAW;AAMnB;AAAA;AAAA;AAAA,SAAQ,sBAAsD,oBAAI,IAAI;AAQpE,UAAM,EAAE,MAAM,IAAI,gBAA0B;AAC5C,QAAI,CAAC;AACH,YAAM,IAAI,MAAM,iDAAiD;AAInE,SAAK,YAAY,MAAM,aAAa;AACpC,SAAK,cAAc,QAAQ;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,QAAuB;AAC3B,QAAI,KAAK,UAAU;AACjB,YAAM,IAAI,MAAM,2BAA2B;AAAA,IAC7C;AACA,SAAK,WAAW;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAiB,KAA6B;AAElD,UAAM,EAAE,WAAW,IAAI,gBAAgB;AACvC,QAAI,CAAC;AACH,YAAM,IAAI,MAAM,8CAA8C;AAGhE,QAAI,KAAK,aAAa;AACpB,YAAM,cAAc,IAAI,QAAQ,IAAI,eAAe;AACnD,UAAI,aAAa;AACf,cAAM,KAAK,aAAa,WAAW;AACnC;AAAA,MACF;AAAA,IACF;AAEA,eAAW,SAAS;AAAA,MAClB,gBAAgB;AAAA,IAClB,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAc,aAAa,aAAoC;AAC7D,QAAI,CAAC,KAAK,aAAa;AACrB;AAAA,IACF;AAEA,UAAM,EAAE,WAAW,IAAI,gBAAgB;AACvC,QAAI,CAAC;AACH,YAAM,IAAI,MAAM,8CAA8C;AAEhE,QAAI;AACF,YAAM,KAAK,aAAa,kBAAkB,aAAa;AAAA,QACrD,MAAM,OAAO,SAAiB,YAA4B;AACxD,cAAI;AACF,iBAAK,cAAc,YAAY,SAAS,OAAO;AAAA,UACjD,SAAS,OAAO;AACd,iBAAK,UAAU,KAAc;AAAA,UAC/B;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH,SAAS,OAAO;AACd,WAAK,UAAU,KAAc;AAAA,IAC/B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,cACN,YACA,SACA,SACA,OACA;AACA,QAAI,YAAY;AAEhB,QAAI,SAAS;AACX,mBAAa,OAAO,OAAO;AAAA;AAAA,IAC7B;AACA,iBAAa,SAAS,KAAK,UAAU,OAAO,CAAC;AAAA;AAAA;AAE7C,WAAO,WAAW;AAAA,MAChB,KAAK,UAAU;AAAA,QACb;AAAA,QACA,OAAO;AAAA,QACP;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,kBACJ,KACA,YACe;AACf,UAAM,WAAiC,IAAI;AAC3C,UAAM,cAA2B;AAAA,MAC/B,SAAS,OAAO,YAAY,IAAI,QAAQ,QAAQ,CAAC;AAAA,IACnD;AAEA,WAAO,YAAY,QAAQ,sBAAsB;AACjD,WAAO,YAAY,QAAQ,kBAAkB;AAC7C,WAAO,YAAY,QAAQ;AAE3B,UAAM,aAAa;AACnB,QAAI;AAGJ,QAAI,MAAM,QAAQ,UAAU,GAAG;AAC7B,iBAAW,WAAW,IAAI,CAAC,QAAQC,sBAAqB,MAAM,GAAG,CAAC;AAAA,IACpE,OAAO;AACL,iBAAW,CAACA,sBAAqB,MAAM,UAAU,CAAC;AAAA,IACpD;AAGA,UAAM,cAAc,SAAS,KAAK,gBAAgB;AAElD,QAAI,CAAC,aAAa;AAEhB,iBAAW,WAAW,UAAU;AAC9B,aAAK,YAAY,SAAS,EAAE,UAAU,YAAY,CAAC;AAAA,MACrD;AAAA,IACF,WAAW,aAAa;AACtB,YAAM,EAAE,WAAW,IAAI,gBAAgB;AACvC,UAAI,CAAC;AACH,cAAM,IAAI,MAAM,+CAA+C;AAGjE,YAAM,aAAa,SAChB,OAAO,gBAAgB,EACvB,IAAI,CAAC,YAAY,QAAQ,EAAE;AAE9B,iBAAW,SAAS;AAAA,QAClB;AAAA,MACF,CAAC;AAGD,iBAAW,WAAW,UAAU;AAC9B,aAAK,YAAY,SAAS,EAAE,UAAU,YAAY,CAAC;AAAA,MACrD;AAAA,IAGF;AAAA,EACF;AAAA,EAEA,MAAM,QAAuB;AAE3B,UAAM,EAAE,MAAM,IAAI,gBAAgB;AAClC,QAAI,CAAC,MAAO,OAAM,IAAI,MAAM,8BAA8B;AAE1D,eAAW,QAAQ,MAAM,eAAe,GAAG;AACzC,WAAK,MAAM,KAAM,gBAAgB;AAAA,IACnC;AACA,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,MAAM,KACJ,SACA,SACe;AACf,UAAM,EAAE,MAAM,IAAI,gBAAgB;AAClC,QAAI,CAAC,MAAO,OAAM,IAAI,MAAM,6BAA6B;AAEzD,QAAI,YAAY,SAAS;AACzB,QAAIC,mBAAkB,OAAO,KAAK,eAAe,OAAO,GAAG;AAEzD,kBAAY,QAAQ;AAAA,IACtB;AAKA,QAAI,cAAc,QAAW;AAE3B,UAAIA,mBAAkB,OAAO,KAAK,eAAe,OAAO,GAAG;AACzD,cAAM,IAAI;AAAA,UACR;AAAA,QACF;AAAA,MACF;AAEA,UAAI;AACJ,iBAAW,QAAQ,MAAM,eAA6C,GAAG;AACvE,YAAI,KAAK,OAAO,eAAgB,wBAAuB;AAAA,MACzD;AAEA,UAAI,yBAAyB,QAAW;AAEtC;AAAA,MACF;AAGA,UAAIC;AACJ,UAAI,KAAK,aAAa;AAEpB,QAAAA,WAAU,MAAM,KAAK,YAAY;AAAA,UAC/B,qBAAqB;AAAA,UACrB;AAAA,QACF;AAAA,MACF;AAGA,WAAK,cAAc,sBAAsB,SAASA,QAAO;AACzD;AAAA,IACF;AAGA,UAAM,aAAa,MAAM;AAAA,MACvB,MAAM,eAA0C;AAAA,IAClD,EAAE,KAAK,CAAC,SAAS,KAAK,OAAO,YAAY,SAAS,SAAmB,CAAC;AACtE,QAAI,CAAC,YAAY;AACf,YAAM,IAAI;AAAA,QACR,6CAA6C,OAAO,SAAS,CAAC;AAAA,MAChE;AAAA,IACF;AAEA,QAAI;AAEJ,QAAI,KAAK,aAAa;AACpB,gBAAU,MAAM,KAAK,YAAY,WAAW,WAAW,IAAI,OAAO;AAAA,IACpE;AAEA,QAAI,cAAc;AAElB,QAAID,mBAAkB,OAAO,KAAK,eAAe,OAAO,GAAG;AACzD,WAAK,oBAAoB,IAAI,WAAW,OAAO;AAC/C,YAAM,aAAa,WAAW,OAAO,cAAc,CAAC;AAEpD,oBAAc,WAAW,MAAM,CAAC,OAAO,KAAK,oBAAoB,IAAI,EAAE,CAAC;AAEvE,UAAI,aAAa;AAEf,mBAAW,MAAM,YAAY;AAC3B,eAAK,oBAAoB,OAAO,EAAE;AAAA,QACpC;AAAA,MACF;AAAA,IACF;AACA,SAAK,cAAc,YAAY,SAAS,SAAS,WAAW;AAAA,EAC9D;AACF;;;AFwDA;AAAA,EACE;AAAA,OAGK;AArZA,IAAe,WAAf,MAAe,kBAIZ,MAAyB;AAAA;AAAA;AAAA;AAAA,EAWjC,MAAM,qBAAqB,mBAAmC;AAC5D,UAAM,KAAK,IAAI,QAAQ,IAAI,qBAAqB,iBAAiB;AAAA,EACnE;AAAA,EAEA,MAAM,uBAAuB;AAC3B,WAAO,KAAK,IAAI,QAAQ,IAAoB,mBAAmB;AAAA,EACjE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,mBAAsC;AACpC,UAAM,CAAC,GAAG,GAAG,CAAC,IAAI,KAAK,KAAK,MAAM,GAAG;AACrC,YAAQ,GAAG;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT;AACE,cAAM,IAAI;AAAA,UACR;AAAA,QACF;AAAA,IACJ;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,eAAuB;AACrB,UAAM,CAAC,GAAG,SAAS,IAAI,KAAK,KAAK,MAAM,GAAG;AAC1C,QAAI,CAAC,WAAW;AACd,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA;AAAA,EAGQ,eAAe;AACrB,UAAM,aAAa,MAAM,KAAK,KAAK,eAAe,CAAC;AACnD,QAAI,WAAW,WAAW,GAAG;AAC3B,aAAO;AAAA,IACT;AACA,WAAO,WAAW,CAAC;AAAA,EACrB;AAAA;AAAA,EAGQ,gBAAgB;AACtB,YAAQ,KAAK,iBAAiB,GAAG;AAAA,MAC/B,KAAK,OAAO;AACV,eAAO,IAAI,gBAAgB,MAAM,KAAK,aAAa,CAAC;AAAA,MACtD;AAAA,MACA,KAAK,mBAAmB;AACtB,eAAO,IAAI,8BAA8B,CAAC,CAAC;AAAA,MAC7C;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAGA,MAAM,YAAY,OAAe;AAC/B,UAAM,KAAK,IAAI,QAAQ,IAAI,SAAS,SAAS,CAAC,CAAC;AAC/C,SAAK,QAAQ;AAAA,EACf;AAAA,EAEA,MAAM,qBAAqB;AAIzB,UAAM,oBAAoB,MAAM,KAAK,qBAAqB;AAC1D,QAAI,mBAAmB;AACrB,WAAK,YAAY,YAAY,iBAAiB;AAAA,IAChD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,QAAQ,OAAe;AAE3B,QAAI,MAAO,OAAM,KAAK,YAAY,KAAK;AACvC,SAAK,QAAQ,MAAM,KAAK,IAAI,QAAQ,IAAI,OAAO;AAE/C,UAAM,KAAK,KAAK;AAChB,UAAM,SAAS,MAAM,KAAK;AAE1B,SAAK,aAAa,KAAK,cAAc;AACrC,UAAM,OAAO,QAAQ,KAAK,UAAU;AACpC,UAAM,KAAK,mBAAmB;AAAA,EAChC;AAAA;AAAA,EAGA,MAAM,UACJ,MACA,EAAE,SAAS,IAAI,GACA;AACf,YAAQ,KAAK,iBAAiB,GAAG;AAAA,MAC/B,KAAK,OAAO;AAGV,cAAM,aAAa,MAAM,KAAK,KAAK,eAAe,CAAC;AACnD,YAAI,WAAW,SAAS,GAAG;AACzB,eAAK,MAAM,MAAM,6BAA6B;AAC9C;AAAA,QACF;AACA;AAAA,MACF;AAAA,MACA,KAAK;AACH,YAAI,KAAK,sBAAsB,+BAA+B;AAC5D,kBAAQ,IAAI,QAAQ,IAAI,sBAAsB,GAAG;AAAA,YAC/C,KAAK,QAAQ;AAEX,oBAAM,gBAAgB,IAAI,QAAQ,IAAI,kBAAkB;AACxD,oBAAM,aAAa,MAAM,KAAK,MAAM,iBAAiB,IAAI;AACzD,mBAAK,YAAY,kBAAkB,KAAK,UAAU;AAClD;AAAA,YACF;AAAA,YACA,KAAK;AACH,mBAAK,YAAY,iBAAiB,GAAG;AACrC;AAAA,UACJ;AAAA,QACF;AAAA,IACJ;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,gBACJ,YACA,aACuB;AAGvB,QAAI,KAAK,iBAAiB,MAAM,OAAO;AACrC,aAAO,IAAI,MAAM,+CAA+C;AAAA,IAClE;AAEA,QAAI;AACF,UAAI;AACJ,UAAI;AACF,wBAAgBE,sBAAqB,MAAM,WAAW;AAAA,MACxD,SAAS,OAAO;AACd,aAAK,YAAY,UAAU,KAAc;AACzC,cAAM;AAAA,MACR;AAGA,UAAI,MAAM,KAAK,2BAA2B,aAAa,GAAG;AACxD,eAAO;AAAA,MACT;AAEA,WAAK,YAAY,YAAY,aAAa;AAC1C,aAAO;AAAA,IACT,SAAS,OAAO;AACd,cAAQ,MAAM,oCAAoC,KAAK;AACvD,WAAK,YAAY,UAAU,KAAc;AACzC,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA,EAGA,MAAM,YAAY,QAGQ;AACxB,UAAM,YAAY,UAAU,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,UAAU,GAAG,EAAE,CAAC;AAGvE,UAAM,KAAK,IAAI,QAAQ,IAAI,eAAe,SAAS,IAAI;AAAA,MACrD,SAAS,OAAO;AAAA,MAChB,iBAAiB,OAAO;AAAA,MACxB,WAAW,KAAK,IAAI;AAAA,IACtB,CAAC;AAED,UAAM,gBAAgB;AAAA,MACpB,SAAS;AAAA,MACT,IAAI;AAAA,MACJ,QAAQ;AAAA,MACR,QAAQ;AAAA,QACN,SAAS,OAAO;AAAA,QAChB,iBAAiB,OAAO;AAAA,MAC1B;AAAA,IACF;AAGA,QAAI,KAAK,YAAY;AACnB,YAAM,KAAK,WAAW,KAAK,aAAa;AAAA,IAC1C,OAAO;AACL,YAAM,cAAc,KAAK,eAAe;AACxC,UAAI,CAAC,eAAe,MAAM,KAAK,WAAW,EAAE,WAAW,GAAG;AACxD,cAAM,KAAK,IAAI,QAAQ,OAAO,eAAe,SAAS,EAAE;AACxD,cAAM,IAAI,MAAM,iDAAiD;AAAA,MACnE;AAEA,YAAM,iBAAiB,MAAM,KAAK,WAAW;AAC7C,iBAAW,cAAc,gBAAgB;AACvC,YAAI;AACF,qBAAW,KAAK,KAAK,UAAU,aAAa,CAAC;AAAA,QAC/C,SAAS,OAAO;AACd,kBAAQ,MAAM,uCAAuC,KAAK;AAAA,QAC5D;AAAA,MACF;AAAA,IACF;AAGA,WAAO,KAAK,4BAA4B,SAAS;AAAA,EACnD;AAAA;AAAA,EAGA,MAAc,4BACZ,WACuB;AACvB,UAAM,YAAY,KAAK,IAAI;AAC3B,UAAM,UAAU;AAEhB,QAAI;AACF,aAAO,KAAK,IAAI,IAAI,YAAY,SAAS;AAEvC,cAAM,WAAW,MAAM,KAAK,IAAI,QAAQ;AAAA,UACtC,wBAAwB,SAAS;AAAA,QACnC;AACA,YAAI,UAAU;AAEZ,gBAAM,KAAK,IAAI,QAAQ,OAAO,eAAe,SAAS,EAAE;AACxD,gBAAM,KAAK,IAAI,QAAQ,OAAO,wBAAwB,SAAS,EAAE;AACjE,iBAAO;AAAA,QACT;AAGA,cAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,GAAG,CAAC;AAAA,MACzD;AAEA,YAAM,IAAI,MAAM,+BAA+B;AAAA,IACjD,UAAE;AAEA,YAAM,KAAK,IAAI,QAAQ,OAAO,eAAe,SAAS,EAAE;AACxD,YAAM,KAAK,IAAI,QAAQ,OAAO,wBAAwB,SAAS,EAAE;AAAA,IACnE;AAAA,EACF;AAAA;AAAA,EAGA,MAAc,2BACZ,SACkB;AAElB,QAAIC,mBAAkB,OAAO,KAAK,QAAQ,QAAQ;AAChD,YAAM,YAAY,QAAQ,IAAI,SAAS;AACvC,UAAI,CAAC,aAAa,CAAC,UAAU,WAAW,SAAS,EAAG,QAAO;AAG3D,YAAM,iBAAiB,MAAM,KAAK,IAAI,QAAQ;AAAA,QAC5C,eAAe,SAAS;AAAA,MAC1B;AACA,UAAI,CAAC,eAAgB,QAAO;AAG5B,YAAM,KAAK,IAAI,QAAQ;AAAA,QACrB,wBAAwB,SAAS;AAAA,QACjC,QAAQ;AAAA,MACV;AACA,aAAO;AAAA,IACT;AAGA,QAAIC,gBAAe,OAAO,GAAG;AAC3B,YAAM,YAAY,QAAQ,IAAI,SAAS;AACvC,UAAI,CAAC,aAAa,CAAC,UAAU,WAAW,SAAS,EAAG,QAAO;AAG3D,YAAM,iBAAiB,MAAM,KAAK,IAAI,QAAQ;AAAA,QAC5C,eAAe,SAAS;AAAA,MAC1B;AACA,UAAI,CAAC,eAAgB,QAAO;AAG5B,YAAM,cAA4B;AAAA,QAChC,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,OAAO,QAAQ,MAAM,WAAW;AAAA,QAClC;AAAA,MACF;AACA,YAAM,KAAK,IAAI,QAAQ;AAAA,QACrB,wBAAwB,SAAS;AAAA,QACjC;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,MACL,MACA;AAAA,IACE,UAAU;AAAA,IACV;AAAA,IACA,YAAY;AAAA,EACd,IAAkB,CAAC,GACnB;AACA,WAAO;AAAA,MACL,MAAM,MAEJ,SACA,KACA,KACmB;AAEnB,cAAM,eAAe,WAAW,SAAS,WAAW;AACpD,YAAI,cAAc;AAChB,iBAAO;AAAA,QACT;AAEA,cAAM,eAAe,IAAI,OAA2B;AAGpD,YAAI,gBAAgB,QAAQ,OAAO,iBAAiB,UAAU;AAC5D,gBAAM,IAAI;AAAA,YACR,uCAAuC,OAAO;AAAA,UAChD;AAAA,QACF;AAGA,YAAI,CAAC,yBAAyB,YAAY,GAAG;AAC3C,gBAAM,IAAI;AAAA,YACR,gCAAgC,OAAO;AAAA,UACzC;AAAA,QACF;AAEA,cAAM,YACJ;AAEF,gBAAQ,WAAW;AAAA,UACjB,KAAK,mBAAmB;AAEtB,kBAAM,uBAAuB;AAAA,cAC3B;AAAA,cACA;AAAA,cACA;AAAA,YACF;AACA,mBAAO,qBAAqB,SAAS,GAAG;AAAA,UAC1C;AAAA,UACA,KAAK,OAAO;AAEV,kBAAM,kBAAkB;AAAA,cACtB;AAAA,cACA;AAAA,cACA;AAAA,YACF;AACA,mBAAO,gBAAgB,SAAS,GAAG;AAAA,UACrC;AAAA,UACA;AACE,mBAAO,IAAI;AAAA,cACT;AAAA,cACA,EAAE,QAAQ,IAAI;AAAA,YAChB;AAAA,QACJ;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,OAAO,MAAM,MAAc,OAAwC,CAAC,GAAG;AACrE,WAAO,UAAS,SAAS,MAAM,IAAI;AAAA,EACrC;AAAA,EAEA,OAAO,SAAS,MAAc,OAAwC,CAAC,GAAG;AACxE,WAAO,UAAS,MAAM,MAAM,EAAE,GAAG,MAAM,WAAW,MAAM,CAAC;AAAA,EAC3D;AACF;","names":["JSONRPCMessageSchema","isJSONRPCError","isJSONRPCResponse","body","event","isJSONRPCResponse","JSONRPCMessageSchema","JSONRPCMessageSchema","isJSONRPCResponse","eventId","JSONRPCMessageSchema","isJSONRPCResponse","isJSONRPCError"]}