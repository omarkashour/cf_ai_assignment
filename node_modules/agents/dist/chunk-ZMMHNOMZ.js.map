{"version":3,"sources":["../src/mcp/client.ts","../src/core/events.ts","../src/mcp/client-connection.ts","../src/mcp/errors.ts","../src/mcp/sse-edge.ts","../src/mcp/streamable-http-edge.ts"],"sourcesContent":["import type { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport type { RequestOptions } from \"@modelcontextprotocol/sdk/shared/protocol.js\";\nimport type {\n  CallToolRequest,\n  CallToolResultSchema,\n  CompatibilityCallToolResultSchema,\n  GetPromptRequest,\n  Prompt,\n  ReadResourceRequest,\n  Resource,\n  ResourceTemplate,\n  Tool\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport { type ToolSet, jsonSchema } from \"ai\";\nimport { nanoid } from \"nanoid\";\nimport { Emitter, type Event, DisposableStore } from \"../core/events\";\nimport type { MCPObservabilityEvent } from \"../observability/mcp\";\nimport {\n  MCPClientConnection,\n  type MCPTransportOptions\n} from \"./client-connection\";\nimport { toErrorMessage } from \"./errors\";\nimport type { TransportType } from \"./types\";\n\nexport type MCPClientOAuthCallbackConfig = {\n  successRedirect?: string;\n  errorRedirect?: string;\n  customHandler?: (result: MCPClientOAuthResult) => Response;\n};\n\nexport type MCPClientOAuthResult = {\n  serverId: string;\n  authSuccess: boolean;\n  authError?: string;\n};\n\n/**\n * Utility class that aggregates multiple MCP clients into one\n */\nexport class MCPClientManager {\n  public mcpConnections: Record<string, MCPClientConnection> = {};\n  private _callbackUrls: string[] = [];\n  private _didWarnAboutUnstableGetAITools = false;\n  private _oauthCallbackConfig?: MCPClientOAuthCallbackConfig;\n  private _connectionDisposables = new Map<string, DisposableStore>();\n\n  private readonly _onObservabilityEvent = new Emitter<MCPObservabilityEvent>();\n  public readonly onObservabilityEvent: Event<MCPObservabilityEvent> =\n    this._onObservabilityEvent.event;\n\n  private readonly _onConnected = new Emitter<string>();\n  public readonly onConnected: Event<string> = this._onConnected.event;\n\n  /**\n   * @param _name Name of the MCP client\n   * @param _version Version of the MCP Client\n   * @param auth Auth paramters if being used to create a DurableObjectOAuthClientProvider\n   */\n  constructor(\n    private _name: string,\n    private _version: string\n  ) {}\n\n  /**\n   * Connect to and register an MCP server\n   *\n   * @param transportConfig Transport config\n   * @param clientConfig Client config\n   * @param capabilities Client capabilities (i.e. if the client supports roots/sampling)\n   */\n  async connect(\n    url: string,\n    options: {\n      // Allows you to reconnect to a server (in the case of an auth reconnect)\n      reconnect?: {\n        // server id\n        id: string;\n        oauthClientId?: string;\n        oauthCode?: string;\n      };\n      // we're overriding authProvider here because we want to be able to access the auth URL\n      transport?: MCPTransportOptions;\n      client?: ConstructorParameters<typeof Client>[1];\n    } = {}\n  ): Promise<{\n    id: string;\n    authUrl?: string;\n    clientId?: string;\n  }> {\n    const id = options.reconnect?.id ?? nanoid(8);\n\n    if (options.transport?.authProvider) {\n      options.transport.authProvider.serverId = id;\n      // reconnect with auth\n      if (options.reconnect?.oauthClientId) {\n        options.transport.authProvider.clientId =\n          options.reconnect?.oauthClientId;\n      }\n    }\n\n    // During OAuth reconnect, reuse existing connection to preserve state\n    if (!options.reconnect?.oauthCode || !this.mcpConnections[id]) {\n      const normalizedTransport = {\n        ...options.transport,\n        type: options.transport?.type ?? (\"auto\" as TransportType)\n      };\n\n      this.mcpConnections[id] = new MCPClientConnection(\n        new URL(url),\n        {\n          name: this._name,\n          version: this._version\n        },\n        {\n          client: options.client ?? {},\n          transport: normalizedTransport\n        }\n      );\n\n      // Pipe connection-level observability events to the manager-level emitter\n      // and track the subscription for cleanup.\n      const store = new DisposableStore();\n      // If we somehow already had disposables for this id, clear them first\n      const existing = this._connectionDisposables.get(id);\n      if (existing) existing.dispose();\n      this._connectionDisposables.set(id, store);\n      store.add(\n        this.mcpConnections[id].onObservabilityEvent((event) => {\n          this._onObservabilityEvent.fire(event);\n        })\n      );\n    }\n\n    // Initialize connection first\n    await this.mcpConnections[id].init();\n\n    // Handle OAuth completion if we have a reconnect code\n    if (options.reconnect?.oauthCode) {\n      try {\n        await this.mcpConnections[id].completeAuthorization(\n          options.reconnect.oauthCode\n        );\n        await this.mcpConnections[id].establishConnection();\n      } catch (error) {\n        this._onObservabilityEvent.fire({\n          type: \"mcp:client:connect\",\n          displayMessage: `Failed to complete OAuth reconnection for ${id} for ${url}`,\n          payload: {\n            url: url,\n            transport: options.transport?.type ?? \"auto\",\n            state: this.mcpConnections[id].connectionState,\n            error: toErrorMessage(error)\n          },\n          timestamp: Date.now(),\n          id\n        });\n        // Re-throw to signal failure to the caller\n        throw error;\n      }\n    }\n\n    // If connection is in authenticating state, return auth URL for OAuth flow\n    const authUrl = options.transport?.authProvider?.authUrl;\n    if (\n      this.mcpConnections[id].connectionState === \"authenticating\" &&\n      authUrl &&\n      options.transport?.authProvider?.redirectUrl\n    ) {\n      this._callbackUrls.push(\n        options.transport.authProvider.redirectUrl.toString()\n      );\n      return {\n        authUrl,\n        clientId: options.transport?.authProvider?.clientId,\n        id\n      };\n    }\n\n    return {\n      id\n    };\n  }\n\n  isCallbackRequest(req: Request): boolean {\n    return (\n      req.method === \"GET\" &&\n      !!this._callbackUrls.find((url) => {\n        return req.url.startsWith(url);\n      })\n    );\n  }\n\n  async handleCallbackRequest(req: Request) {\n    const url = new URL(req.url);\n    const urlMatch = this._callbackUrls.find((url) => {\n      return req.url.startsWith(url);\n    });\n    if (!urlMatch) {\n      throw new Error(\n        `No callback URI match found for the request url: ${req.url}. Was the request matched with \\`isCallbackRequest()\\`?`\n      );\n    }\n    const code = url.searchParams.get(\"code\");\n    const state = url.searchParams.get(\"state\");\n    const urlParams = urlMatch.split(\"/\");\n    const serverId = urlParams[urlParams.length - 1];\n    if (!code) {\n      throw new Error(\"Unauthorized: no code provided\");\n    }\n    if (!state) {\n      throw new Error(\"Unauthorized: no state provided\");\n    }\n\n    if (this.mcpConnections[serverId] === undefined) {\n      throw new Error(`Could not find serverId: ${serverId}`);\n    }\n\n    if (this.mcpConnections[serverId].connectionState !== \"authenticating\") {\n      throw new Error(\n        \"Failed to authenticate: the client isn't in the `authenticating` state\"\n      );\n    }\n\n    const conn = this.mcpConnections[serverId];\n    if (!conn.options.transport.authProvider) {\n      throw new Error(\n        \"Trying to finalize authentication for a server connection without an authProvider\"\n      );\n    }\n\n    // Get clientId from auth provider (stored during redirectToAuthorization) or fallback to state for backward compatibility\n    const clientId = conn.options.transport.authProvider.clientId || state;\n\n    // Set the OAuth credentials\n    conn.options.transport.authProvider.clientId = clientId;\n    conn.options.transport.authProvider.serverId = serverId;\n\n    try {\n      await conn.completeAuthorization(code);\n      return {\n        serverId,\n        authSuccess: true\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n\n      return {\n        serverId,\n        authSuccess: false,\n        authError: errorMessage\n      };\n    }\n  }\n\n  /**\n   * Establish connection in the background after OAuth completion\n   * This method is called asynchronously and doesn't block the OAuth callback response\n   * @param serverId The server ID to establish connection for\n   */\n  async establishConnection(serverId: string): Promise<void> {\n    const conn = this.mcpConnections[serverId];\n    if (!conn) {\n      this._onObservabilityEvent.fire({\n        type: \"mcp:client:preconnect\",\n        displayMessage: `Connection not found for serverId: ${serverId}`,\n        payload: { serverId },\n        timestamp: Date.now(),\n        id: nanoid()\n      });\n      return;\n    }\n\n    try {\n      await conn.establishConnection();\n      this._onConnected.fire(serverId);\n    } catch (error) {\n      const url = conn.url.toString();\n      this._onObservabilityEvent.fire({\n        type: \"mcp:client:connect\",\n        displayMessage: `Failed to establish connection to server ${serverId} with url ${url}`,\n        payload: {\n          url,\n          transport: conn.options.transport.type ?? \"auto\",\n          state: conn.connectionState,\n          error: toErrorMessage(error)\n        },\n        timestamp: Date.now(),\n        id: nanoid()\n      });\n    }\n  }\n\n  /**\n   * Register a callback URL for OAuth handling\n   * @param url The callback URL to register\n   */\n  registerCallbackUrl(url: string): void {\n    if (!this._callbackUrls.includes(url)) {\n      this._callbackUrls.push(url);\n    }\n  }\n\n  /**\n   * Unregister a callback URL\n   * @param serverId The server ID whose callback URL should be removed\n   */\n  unregisterCallbackUrl(serverId: string): void {\n    // Remove callback URLs that end with this serverId\n    this._callbackUrls = this._callbackUrls.filter(\n      (url) => !url.endsWith(`/${serverId}`)\n    );\n  }\n\n  /**\n   * Configure OAuth callback handling\n   * @param config OAuth callback configuration\n   */\n  configureOAuthCallback(config: MCPClientOAuthCallbackConfig): void {\n    this._oauthCallbackConfig = config;\n  }\n\n  /**\n   * Get the current OAuth callback configuration\n   * @returns The current OAuth callback configuration\n   */\n  getOAuthCallbackConfig(): MCPClientOAuthCallbackConfig | undefined {\n    return this._oauthCallbackConfig;\n  }\n\n  /**\n   * @returns namespaced list of tools\n   */\n  listTools(): NamespacedData[\"tools\"] {\n    return getNamespacedData(this.mcpConnections, \"tools\");\n  }\n\n  /**\n   * @returns a set of tools that you can use with the AI SDK\n   */\n  getAITools(): ToolSet {\n    return Object.fromEntries(\n      getNamespacedData(this.mcpConnections, \"tools\").map((tool) => {\n        return [\n          `tool_${tool.serverId.replace(/-/g, \"\")}_${tool.name}`,\n          {\n            description: tool.description,\n            execute: async (args) => {\n              const result = await this.callTool({\n                arguments: args,\n                name: tool.name,\n                serverId: tool.serverId\n              });\n              if (result.isError) {\n                // @ts-expect-error TODO we should fix this\n                throw new Error(result.content[0].text);\n              }\n              return result;\n            },\n            // @ts-expect-error drift between ai and mcp types\n            inputSchema: jsonSchema(tool.inputSchema),\n\n            outputSchema: tool.outputSchema\n              ? // @ts-expect-error drift between ai and mcp types\n                jsonSchema(tool.outputSchema)\n              : undefined\n          }\n        ];\n      })\n    );\n  }\n\n  /**\n   * @deprecated this has been renamed to getAITools(), and unstable_getAITools will be removed in the next major version\n   * @returns a set of tools that you can use with the AI SDK\n   */\n  unstable_getAITools(): ToolSet {\n    if (!this._didWarnAboutUnstableGetAITools) {\n      this._didWarnAboutUnstableGetAITools = true;\n      console.warn(\n        \"unstable_getAITools is deprecated, use getAITools instead. unstable_getAITools will be removed in the next major version.\"\n      );\n    }\n    return this.getAITools();\n  }\n\n  /**\n   * Closes all connections to MCP servers\n   */\n  async closeAllConnections() {\n    const ids = Object.keys(this.mcpConnections);\n    await Promise.all(\n      ids.map(async (id) => {\n        await this.mcpConnections[id].client.close();\n      })\n    );\n    // Dispose all per-connection subscriptions\n    for (const id of ids) {\n      const store = this._connectionDisposables.get(id);\n      if (store) store.dispose();\n      this._connectionDisposables.delete(id);\n      delete this.mcpConnections[id];\n    }\n  }\n\n  /**\n   * Closes a connection to an MCP server\n   * @param id The id of the connection to close\n   */\n  async closeConnection(id: string) {\n    if (!this.mcpConnections[id]) {\n      throw new Error(`Connection with id \"${id}\" does not exist.`);\n    }\n    await this.mcpConnections[id].client.close();\n    delete this.mcpConnections[id];\n\n    const store = this._connectionDisposables.get(id);\n    if (store) store.dispose();\n    this._connectionDisposables.delete(id);\n  }\n\n  /**\n   * Dispose the manager and all resources.\n   */\n  async dispose(): Promise<void> {\n    try {\n      await this.closeAllConnections();\n    } finally {\n      // Dispose manager-level emitters\n      this._onConnected.dispose();\n      this._onObservabilityEvent.dispose();\n    }\n  }\n\n  /**\n   * @returns namespaced list of prompts\n   */\n  listPrompts(): NamespacedData[\"prompts\"] {\n    return getNamespacedData(this.mcpConnections, \"prompts\");\n  }\n\n  /**\n   * @returns namespaced list of tools\n   */\n  listResources(): NamespacedData[\"resources\"] {\n    return getNamespacedData(this.mcpConnections, \"resources\");\n  }\n\n  /**\n   * @returns namespaced list of resource templates\n   */\n  listResourceTemplates(): NamespacedData[\"resourceTemplates\"] {\n    return getNamespacedData(this.mcpConnections, \"resourceTemplates\");\n  }\n\n  /**\n   * Namespaced version of callTool\n   */\n  async callTool(\n    params: CallToolRequest[\"params\"] & { serverId: string },\n    resultSchema?:\n      | typeof CallToolResultSchema\n      | typeof CompatibilityCallToolResultSchema,\n    options?: RequestOptions\n  ) {\n    const unqualifiedName = params.name.replace(`${params.serverId}.`, \"\");\n    return this.mcpConnections[params.serverId].client.callTool(\n      {\n        ...params,\n        name: unqualifiedName\n      },\n      resultSchema,\n      options\n    );\n  }\n\n  /**\n   * Namespaced version of readResource\n   */\n  readResource(\n    params: ReadResourceRequest[\"params\"] & { serverId: string },\n    options: RequestOptions\n  ) {\n    return this.mcpConnections[params.serverId].client.readResource(\n      params,\n      options\n    );\n  }\n\n  /**\n   * Namespaced version of getPrompt\n   */\n  getPrompt(\n    params: GetPromptRequest[\"params\"] & { serverId: string },\n    options: RequestOptions\n  ) {\n    return this.mcpConnections[params.serverId].client.getPrompt(\n      params,\n      options\n    );\n  }\n}\n\ntype NamespacedData = {\n  tools: (Tool & { serverId: string })[];\n  prompts: (Prompt & { serverId: string })[];\n  resources: (Resource & { serverId: string })[];\n  resourceTemplates: (ResourceTemplate & { serverId: string })[];\n};\n\nexport function getNamespacedData<T extends keyof NamespacedData>(\n  mcpClients: Record<string, MCPClientConnection>,\n  type: T\n): NamespacedData[T] {\n  const sets = Object.entries(mcpClients).map(([name, conn]) => {\n    return { data: conn[type], name };\n  });\n\n  const namespacedData = sets.flatMap(({ name: serverId, data }) => {\n    return data.map((item) => {\n      return {\n        ...item,\n        // we add a serverId so we can easily pull it out and send the tool call to the right server\n        serverId\n      };\n    });\n  });\n\n  return namespacedData as NamespacedData[T]; // Type assertion needed due to TS limitations with conditional return types\n}\n","export interface Disposable {\n  dispose(): void;\n}\n\nexport function toDisposable(fn: () => void): Disposable {\n  return { dispose: fn };\n}\n\nexport class DisposableStore implements Disposable {\n  private readonly _items: Disposable[] = [];\n\n  add<T extends Disposable>(d: T): T {\n    this._items.push(d);\n    return d;\n  }\n\n  dispose(): void {\n    while (this._items.length) {\n      try {\n        this._items.pop()!.dispose();\n      } catch {\n        // best-effort cleanup\n      }\n    }\n  }\n}\n\nexport type Event<T> = (listener: (e: T) => void) => Disposable;\n\nexport class Emitter<T> implements Disposable {\n  private _listeners: Set<(e: T) => void> = new Set();\n\n  readonly event: Event<T> = (listener) => {\n    this._listeners.add(listener);\n    return toDisposable(() => this._listeners.delete(listener));\n  };\n\n  fire(data: T): void {\n    for (const listener of [...this._listeners]) {\n      try {\n        listener(data);\n      } catch (err) {\n        // do not let one bad listener break others\n        console.error(\"Emitter listener error:\", err);\n      }\n    }\n  }\n\n  dispose(): void {\n    this._listeners.clear();\n  }\n}\n","import { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport type { SSEClientTransportOptions } from \"@modelcontextprotocol/sdk/client/sse.js\";\nimport type { StreamableHTTPClientTransportOptions } from \"@modelcontextprotocol/sdk/client/streamableHttp.js\";\n// Import types directly from MCP SDK\nimport type {\n  Prompt,\n  Resource,\n  Tool\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport {\n  type ClientCapabilities,\n  type ElicitRequest,\n  ElicitRequestSchema,\n  type ElicitResult,\n  type ListPromptsResult,\n  type ListResourceTemplatesResult,\n  type ListResourcesResult,\n  type ListToolsResult,\n  PromptListChangedNotificationSchema,\n  ResourceListChangedNotificationSchema,\n  type ResourceTemplate,\n  type ServerCapabilities,\n  ToolListChangedNotificationSchema\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport { nanoid } from \"nanoid\";\nimport { Emitter, type Event } from \"../core/events\";\nimport type { MCPObservabilityEvent } from \"../observability/mcp\";\nimport type { AgentsOAuthProvider } from \"./do-oauth-client-provider\";\nimport {\n  isTransportNotImplemented,\n  isUnauthorized,\n  toErrorMessage\n} from \"./errors\";\nimport { SSEEdgeClientTransport } from \"./sse-edge\";\nimport { StreamableHTTPEdgeClientTransport } from \"./streamable-http-edge\";\nimport type { BaseTransportType, TransportType } from \"./types\";\n\n/**\n * Connection state for MCP client connections\n */\nexport type MCPConnectionState =\n  | \"authenticating\"\n  | \"connecting\"\n  | \"ready\"\n  | \"discovering\"\n  | \"failed\";\n\nexport type MCPTransportOptions = (\n  | SSEClientTransportOptions\n  | StreamableHTTPClientTransportOptions\n) & {\n  authProvider?: AgentsOAuthProvider;\n  type?: TransportType;\n};\n\nexport class MCPClientConnection {\n  client: Client;\n  connectionState: MCPConnectionState = \"connecting\";\n  lastConnectedTransport: BaseTransportType | undefined;\n  instructions?: string;\n  tools: Tool[] = [];\n  prompts: Prompt[] = [];\n  resources: Resource[] = [];\n  resourceTemplates: ResourceTemplate[] = [];\n  serverCapabilities: ServerCapabilities | undefined;\n\n  private readonly _onObservabilityEvent = new Emitter<MCPObservabilityEvent>();\n  public readonly onObservabilityEvent: Event<MCPObservabilityEvent> =\n    this._onObservabilityEvent.event;\n\n  constructor(\n    public url: URL,\n    info: ConstructorParameters<typeof Client>[0],\n    public options: {\n      transport: MCPTransportOptions;\n      client: ConstructorParameters<typeof Client>[1];\n    } = { client: {}, transport: {} }\n  ) {\n    const clientOptions = {\n      ...options.client,\n      capabilities: {\n        ...options.client?.capabilities,\n        elicitation: {}\n      } as ClientCapabilities\n    };\n\n    this.client = new Client(info, clientOptions);\n  }\n\n  /**\n   * Initialize a client connection\n   *\n   * @returns\n   */\n  async init() {\n    const transportType = this.options.transport.type;\n    if (!transportType) {\n      throw new Error(\"Transport type must be specified\");\n    }\n\n    try {\n      await this.tryConnect(transportType);\n    } catch (e) {\n      if (isUnauthorized(e)) {\n        // unauthorized, we should wait for the user to authenticate\n        this.connectionState = \"authenticating\";\n        return;\n      }\n      // For explicit transport mismatches or other errors, mark as failed\n      // and do not throw to avoid bubbling errors to the client runtime.\n      this._onObservabilityEvent.fire({\n        type: \"mcp:client:connect\",\n        displayMessage: `Connection initialization failed for ${this.url.toString()}`,\n        payload: {\n          url: this.url.toString(),\n          transport: transportType,\n          state: this.connectionState,\n          error: toErrorMessage(e)\n        },\n        timestamp: Date.now(),\n        id: nanoid()\n      });\n      this.connectionState = \"failed\";\n      return;\n    }\n\n    await this.discoverAndRegister();\n  }\n\n  /**\n   * Finish OAuth by probing transports based on configured type.\n   * - Explicit: finish on that transport\n   * - Auto: try streamable-http, then sse on 404/405/Not Implemented\n   */\n  private async finishAuthProbe(code: string): Promise<void> {\n    if (!this.options.transport.authProvider) {\n      throw new Error(\"No auth provider configured\");\n    }\n\n    const configuredType = this.options.transport.type;\n    if (!configuredType) {\n      throw new Error(\"Transport type must be specified\");\n    }\n\n    const finishAuth = async (base: BaseTransportType) => {\n      const transport = this.getTransport(base);\n      await transport.finishAuth(code);\n    };\n\n    if (configuredType === \"sse\" || configuredType === \"streamable-http\") {\n      await finishAuth(configuredType);\n      return;\n    }\n\n    // For \"auto\" mode, try streamable-http first, then fall back to SSE\n    try {\n      await finishAuth(\"streamable-http\");\n    } catch (e) {\n      if (isTransportNotImplemented(e)) {\n        await finishAuth(\"sse\");\n        return;\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Complete OAuth authorization\n   */\n  async completeAuthorization(code: string): Promise<void> {\n    if (this.connectionState !== \"authenticating\") {\n      throw new Error(\n        \"Connection must be in authenticating state to complete authorization\"\n      );\n    }\n\n    try {\n      // Finish OAuth by probing transports per configuration\n      await this.finishAuthProbe(code);\n\n      // Mark as connecting\n      this.connectionState = \"connecting\";\n    } catch (error) {\n      this.connectionState = \"failed\";\n      throw error;\n    }\n  }\n\n  /**\n   * Establish connection after successful authorization\n   */\n  async establishConnection(): Promise<void> {\n    if (this.connectionState !== \"connecting\") {\n      throw new Error(\n        \"Connection must be in connecting state to establish connection\"\n      );\n    }\n\n    try {\n      const transportType = this.options.transport.type;\n      if (!transportType) {\n        throw new Error(\"Transport type must be specified\");\n      }\n      await this.tryConnect(transportType);\n\n      await this.discoverAndRegister();\n    } catch (error) {\n      this.connectionState = \"failed\";\n      throw error;\n    }\n  }\n\n  /**\n   * Discover server capabilities and register tools, resources, prompts, and templates\n   */\n  private async discoverAndRegister(): Promise<void> {\n    this.connectionState = \"discovering\";\n\n    this.serverCapabilities = this.client.getServerCapabilities();\n    if (!this.serverCapabilities) {\n      throw new Error(\"The MCP Server failed to return server capabilities\");\n    }\n\n    const [\n      instructionsResult,\n      toolsResult,\n      resourcesResult,\n      promptsResult,\n      resourceTemplatesResult\n    ] = await Promise.allSettled([\n      this.client.getInstructions(),\n      this.registerTools(),\n      this.registerResources(),\n      this.registerPrompts(),\n      this.registerResourceTemplates()\n    ]);\n\n    const operations = [\n      { name: \"instructions\", result: instructionsResult },\n      { name: \"tools\", result: toolsResult },\n      { name: \"resources\", result: resourcesResult },\n      { name: \"prompts\", result: promptsResult },\n      { name: \"resource templates\", result: resourceTemplatesResult }\n    ];\n\n    for (const { name, result } of operations) {\n      if (result.status === \"rejected\") {\n        const url = this.url.toString();\n        this._onObservabilityEvent.fire({\n          type: \"mcp:client:discover\",\n          displayMessage: `Failed to discover ${name} for ${url}`,\n          payload: {\n            url,\n            capability: name,\n            error: result.reason\n          },\n          timestamp: Date.now(),\n          id: nanoid()\n        });\n      }\n    }\n\n    this.instructions =\n      instructionsResult.status === \"fulfilled\"\n        ? instructionsResult.value\n        : undefined;\n    this.tools = toolsResult.status === \"fulfilled\" ? toolsResult.value : [];\n    this.resources =\n      resourcesResult.status === \"fulfilled\" ? resourcesResult.value : [];\n    this.prompts =\n      promptsResult.status === \"fulfilled\" ? promptsResult.value : [];\n    this.resourceTemplates =\n      resourceTemplatesResult.status === \"fulfilled\"\n        ? resourceTemplatesResult.value\n        : [];\n\n    this.connectionState = \"ready\";\n  }\n\n  /**\n   * Notification handler registration\n   */\n  async registerTools(): Promise<Tool[]> {\n    if (!this.serverCapabilities || !this.serverCapabilities.tools) {\n      return [];\n    }\n\n    if (this.serverCapabilities.tools.listChanged) {\n      this.client.setNotificationHandler(\n        ToolListChangedNotificationSchema,\n        async (_notification) => {\n          this.tools = await this.fetchTools();\n        }\n      );\n    }\n\n    return this.fetchTools();\n  }\n\n  async registerResources(): Promise<Resource[]> {\n    if (!this.serverCapabilities || !this.serverCapabilities.resources) {\n      return [];\n    }\n\n    if (this.serverCapabilities.resources.listChanged) {\n      this.client.setNotificationHandler(\n        ResourceListChangedNotificationSchema,\n        async (_notification) => {\n          this.resources = await this.fetchResources();\n        }\n      );\n    }\n\n    return this.fetchResources();\n  }\n\n  async registerPrompts(): Promise<Prompt[]> {\n    if (!this.serverCapabilities || !this.serverCapabilities.prompts) {\n      return [];\n    }\n\n    if (this.serverCapabilities.prompts.listChanged) {\n      this.client.setNotificationHandler(\n        PromptListChangedNotificationSchema,\n        async (_notification) => {\n          this.prompts = await this.fetchPrompts();\n        }\n      );\n    }\n\n    return this.fetchPrompts();\n  }\n\n  async registerResourceTemplates(): Promise<ResourceTemplate[]> {\n    if (!this.serverCapabilities || !this.serverCapabilities.resources) {\n      return [];\n    }\n\n    return this.fetchResourceTemplates();\n  }\n\n  async fetchTools() {\n    let toolsAgg: Tool[] = [];\n    let toolsResult: ListToolsResult = { tools: [] };\n    do {\n      toolsResult = await this.client\n        .listTools({\n          cursor: toolsResult.nextCursor\n        })\n        .catch(this._capabilityErrorHandler({ tools: [] }, \"tools/list\"));\n      toolsAgg = toolsAgg.concat(toolsResult.tools);\n    } while (toolsResult.nextCursor);\n    return toolsAgg;\n  }\n\n  async fetchResources() {\n    let resourcesAgg: Resource[] = [];\n    let resourcesResult: ListResourcesResult = { resources: [] };\n    do {\n      resourcesResult = await this.client\n        .listResources({\n          cursor: resourcesResult.nextCursor\n        })\n        .catch(\n          this._capabilityErrorHandler({ resources: [] }, \"resources/list\")\n        );\n      resourcesAgg = resourcesAgg.concat(resourcesResult.resources);\n    } while (resourcesResult.nextCursor);\n    return resourcesAgg;\n  }\n\n  async fetchPrompts() {\n    let promptsAgg: Prompt[] = [];\n    let promptsResult: ListPromptsResult = { prompts: [] };\n    do {\n      promptsResult = await this.client\n        .listPrompts({\n          cursor: promptsResult.nextCursor\n        })\n        .catch(this._capabilityErrorHandler({ prompts: [] }, \"prompts/list\"));\n      promptsAgg = promptsAgg.concat(promptsResult.prompts);\n    } while (promptsResult.nextCursor);\n    return promptsAgg;\n  }\n\n  async fetchResourceTemplates() {\n    let templatesAgg: ResourceTemplate[] = [];\n    let templatesResult: ListResourceTemplatesResult = {\n      resourceTemplates: []\n    };\n    do {\n      templatesResult = await this.client\n        .listResourceTemplates({\n          cursor: templatesResult.nextCursor\n        })\n        .catch(\n          this._capabilityErrorHandler(\n            { resourceTemplates: [] },\n            \"resources/templates/list\"\n          )\n        );\n      templatesAgg = templatesAgg.concat(templatesResult.resourceTemplates);\n    } while (templatesResult.nextCursor);\n    return templatesAgg;\n  }\n\n  /**\n   * Handle elicitation request from server\n   * Automatically uses the Agent's built-in elicitation handling if available\n   */\n  async handleElicitationRequest(\n    _request: ElicitRequest\n  ): Promise<ElicitResult> {\n    // Elicitation handling must be implemented by the platform\n    // For MCP servers, this should be handled by McpAgent.elicitInput()\n    throw new Error(\n      \"Elicitation handler must be implemented for your platform. Override handleElicitationRequest method.\"\n    );\n  }\n  /**\n   * Get the transport for the client\n   * @param transportType - The transport type to get\n   * @returns The transport for the client\n   */\n  getTransport(transportType: BaseTransportType) {\n    switch (transportType) {\n      case \"streamable-http\":\n        return new StreamableHTTPEdgeClientTransport(\n          this.url,\n          this.options.transport as StreamableHTTPClientTransportOptions\n        );\n      case \"sse\":\n        return new SSEEdgeClientTransport(\n          this.url,\n          this.options.transport as SSEClientTransportOptions\n        );\n      default:\n        throw new Error(`Unsupported transport type: ${transportType}`);\n    }\n  }\n\n  private async tryConnect(transportType: TransportType) {\n    const transports: BaseTransportType[] =\n      transportType === \"auto\" ? [\"streamable-http\", \"sse\"] : [transportType];\n\n    for (const currentTransportType of transports) {\n      const isLastTransport =\n        currentTransportType === transports[transports.length - 1];\n      const hasFallback =\n        transportType === \"auto\" &&\n        currentTransportType === \"streamable-http\" &&\n        !isLastTransport;\n\n      const transport = this.getTransport(currentTransportType);\n\n      try {\n        await this.client.connect(transport);\n        this.lastConnectedTransport = currentTransportType;\n        const url = this.url.toString();\n        this._onObservabilityEvent.fire({\n          type: \"mcp:client:connect\",\n          displayMessage: `Connected successfully using ${currentTransportType} transport for ${url}`,\n          payload: {\n            url,\n            transport: currentTransportType,\n            state: this.connectionState\n          },\n          timestamp: Date.now(),\n          id: nanoid()\n        });\n        break;\n      } catch (e) {\n        const error = e instanceof Error ? e : new Error(String(e));\n\n        // If unauthorized, bubble up for proper auth handling\n        if (isUnauthorized(error)) {\n          throw e;\n        }\n\n        if (hasFallback && isTransportNotImplemented(error)) {\n          // Try the next transport silently\n          const url = this.url.toString();\n          this._onObservabilityEvent.fire({\n            type: \"mcp:client:connect\",\n            displayMessage: `${currentTransportType} transport not available, trying ${transports[transports.indexOf(currentTransportType) + 1]} for ${url}`,\n            payload: {\n              url,\n              transport: currentTransportType,\n              state: this.connectionState\n            },\n            timestamp: Date.now(),\n            id: nanoid()\n          });\n          continue;\n        }\n\n        throw e;\n      }\n    }\n\n    // Set up elicitation request handler\n    this.client.setRequestHandler(\n      ElicitRequestSchema,\n      async (request: ElicitRequest) => {\n        return await this.handleElicitationRequest(request);\n      }\n    );\n  }\n\n  private _capabilityErrorHandler<T>(empty: T, method: string) {\n    return (e: { code: number }) => {\n      // server is badly behaved and returning invalid capabilities. This commonly occurs for resource templates\n      if (e.code === -32601) {\n        const url = this.url.toString();\n        this._onObservabilityEvent.fire({\n          type: \"mcp:client:discover\",\n          displayMessage: `The server advertised support for the capability ${method.split(\"/\")[0]}, but returned \"Method not found\" for '${method}' for ${url}`,\n          payload: {\n            url,\n            capability: method.split(\"/\")[0],\n            error: toErrorMessage(e)\n          },\n          timestamp: Date.now(),\n          id: nanoid()\n        });\n        return empty;\n      }\n      throw e;\n    };\n  }\n}\n","export function toErrorMessage(error: unknown): string {\n  return error instanceof Error ? error.message : String(error);\n}\n\nexport function isUnauthorized(error: unknown): boolean {\n  const msg = toErrorMessage(error);\n  return msg.includes(\"Unauthorized\") || msg.includes(\"401\");\n}\n\nexport function isTransportNotImplemented(error: unknown): boolean {\n  const msg = toErrorMessage(error);\n  // Treat common \"not implemented\" surfaces as transport not supported\n  return (\n    msg.includes(\"404\") ||\n    msg.includes(\"405\") ||\n    msg.includes(\"Not Implemented\") ||\n    msg.includes(\"not implemented\")\n  );\n}\n","import type { OAuthClientProvider } from \"@modelcontextprotocol/sdk/client/auth.js\";\nimport {\n  SSEClientTransport,\n  type SSEClientTransportOptions\n} from \"@modelcontextprotocol/sdk/client/sse.js\";\n\nexport class SSEEdgeClientTransport extends SSEClientTransport {\n  private authProvider: OAuthClientProvider | undefined;\n  /**\n   * Creates a new EdgeSSEClientTransport, which overrides fetch to be compatible with the CF workers environment\n   */\n  constructor(url: URL, options: SSEClientTransportOptions) {\n    const fetchOverride: typeof fetch = async (\n      fetchUrl: RequestInfo | URL,\n      fetchInit: RequestInit = {}\n    ) => {\n      // add auth headers\n      const headers = await this.authHeaders();\n      const workerOptions = {\n        ...fetchInit,\n        headers: {\n          ...options.requestInit?.headers,\n          ...fetchInit?.headers,\n          ...headers\n        }\n      };\n\n      // Remove unsupported properties\n      delete workerOptions.mode;\n\n      // Call the original fetch with fixed options\n      return (\n        (options.eventSourceInit?.fetch?.(\n          fetchUrl as URL | string,\n          // @ts-expect-error Expects FetchLikeInit from EventSource but is compatible with RequestInit\n          workerOptions\n        ) as Promise<Response>) || fetch(fetchUrl, workerOptions)\n      );\n    };\n\n    super(url, {\n      ...options,\n      eventSourceInit: {\n        ...options.eventSourceInit,\n        fetch: fetchOverride\n      }\n    });\n    this.authProvider = options.authProvider;\n  }\n\n  async authHeaders() {\n    if (this.authProvider) {\n      const tokens = await this.authProvider.tokens();\n      if (tokens) {\n        return {\n          Authorization: `Bearer ${tokens.access_token}`\n        };\n      }\n    }\n  }\n}\n","import type { OAuthClientProvider } from \"@modelcontextprotocol/sdk/client/auth.js\";\nimport {\n  StreamableHTTPClientTransport,\n  type StreamableHTTPClientTransportOptions\n} from \"@modelcontextprotocol/sdk/client/streamableHttp.js\";\n\nexport class StreamableHTTPEdgeClientTransport extends StreamableHTTPClientTransport {\n  private authProvider: OAuthClientProvider | undefined;\n\n  /**\n   * Creates a new StreamableHTTPEdgeClientTransport, which overrides fetch to be compatible with the CF workers environment\n   */\n  constructor(url: URL, options: StreamableHTTPClientTransportOptions) {\n    const fetchOverride: typeof fetch = async (\n      fetchUrl: RequestInfo | URL,\n      fetchInit: RequestInit = {}\n    ) => {\n      // add auth headers\n      const headers = await this.authHeaders();\n      const workerOptions = {\n        ...fetchInit,\n        headers: {\n          ...options.requestInit?.headers,\n          ...fetchInit?.headers,\n          ...headers\n        }\n      };\n\n      // Remove unsupported properties\n      delete workerOptions.mode;\n\n      // Call the original fetch with fixed options\n      return (\n        // @ts-expect-error Custom fetch function for Cloudflare Workers compatibility\n        (options.requestInit?.fetch?.(\n          fetchUrl as URL | string,\n          workerOptions\n        ) as Promise<Response>) || fetch(fetchUrl, workerOptions)\n      );\n    };\n\n    super(url, {\n      ...options,\n      requestInit: {\n        ...options.requestInit,\n        // @ts-expect-error Custom fetch override for Cloudflare Workers\n        fetch: fetchOverride\n      }\n    });\n    this.authProvider = options.authProvider;\n  }\n\n  async authHeaders() {\n    if (this.authProvider) {\n      const tokens = await this.authProvider.tokens();\n      if (tokens) {\n        return {\n          Authorization: `Bearer ${tokens.access_token}`\n        };\n      }\n    }\n  }\n}\n"],"mappings":"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","names":["nanoid","nanoid","url"]}