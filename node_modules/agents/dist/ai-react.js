import "./chunk-BER7KXUJ.js";
import "./chunk-PR4QN5HX.js";

// src/ai-react.tsx
import { useChat } from "@ai-sdk/react";
import { getToolName, isToolUIPart } from "ai";
import { DefaultChatTransport } from "ai";
import { nanoid } from "nanoid";
import { use, useCallback, useEffect, useMemo, useRef } from "react";
var requestCache = /* @__PURE__ */ new Map();
function detectToolsRequiringConfirmation(tools) {
  if (!tools) return [];
  return Object.entries(tools).filter(([_name, tool]) => !tool.execute).map(([name]) => name);
}
function useAgentChat(options) {
  const {
    agent,
    getInitialMessages,
    messages: optionsInitialMessages,
    experimental_automaticToolResolution,
    tools,
    toolsRequiringConfirmation: manualToolsRequiringConfirmation,
    autoSendAfterAllConfirmationsResolved = true,
    ...rest
  } = options;
  const toolsRequiringConfirmation = manualToolsRequiringConfirmation ?? detectToolsRequiringConfirmation(tools);
  const agentUrl = new URL(
    `${// @ts-expect-error we're using a protected _url property that includes query params
    (agent._url || agent._pkurl)?.replace("ws://", "http://").replace("wss://", "https://")}`
  );
  agentUrl.searchParams.delete("_pk");
  const agentUrlString = agentUrl.toString();
  const agentRef = useRef(agent);
  useEffect(() => {
    agentRef.current = agent;
  }, [agent]);
  async function defaultGetInitialMessagesFetch({
    url
  }) {
    const getMessagesUrl = new URL(url);
    getMessagesUrl.pathname += "/get-messages";
    const response = await fetch(getMessagesUrl.toString(), {
      credentials: options.credentials,
      headers: options.headers
    });
    if (!response.ok) {
      console.warn(
        `Failed to fetch initial messages: ${response.status} ${response.statusText}`
      );
      return [];
    }
    const text = await response.text();
    if (!text.trim()) {
      return [];
    }
    try {
      return JSON.parse(text);
    } catch (error) {
      console.warn("Failed to parse initial messages JSON:", error);
      return [];
    }
  }
  const getInitialMessagesFetch = getInitialMessages || defaultGetInitialMessagesFetch;
  function doGetInitialMessages(getInitialMessagesOptions) {
    if (requestCache.has(agentUrlString)) {
      return requestCache.get(agentUrlString);
    }
    const promise = getInitialMessagesFetch(getInitialMessagesOptions);
    requestCache.set(agentUrlString, promise);
    return promise;
  }
  const initialMessagesPromise = getInitialMessages === null ? null : doGetInitialMessages({
    agent: agent.agent,
    name: agent.name,
    url: agentUrlString
  });
  const initialMessages = initialMessagesPromise ? use(initialMessagesPromise) : optionsInitialMessages ?? [];
  useEffect(() => {
    if (!initialMessagesPromise) {
      return;
    }
    requestCache.set(agentUrlString, initialMessagesPromise);
    return () => {
      if (requestCache.get(agentUrlString) === initialMessagesPromise) {
        requestCache.delete(agentUrlString);
      }
    };
  }, [agentUrlString, initialMessagesPromise]);
  const aiFetch = useCallback(
    async (request, options2 = {}) => {
      const {
        method,
        keepalive,
        headers,
        body,
        redirect,
        integrity,
        signal,
        credentials,
        mode,
        referrer,
        referrerPolicy,
        window
      } = options2;
      const id = nanoid(8);
      const abortController = new AbortController();
      let controller;
      const currentAgent = agentRef.current;
      signal?.addEventListener("abort", () => {
        currentAgent.send(
          JSON.stringify({
            id,
            type: "cf_agent_chat_request_cancel" /* CF_AGENT_CHAT_REQUEST_CANCEL */
          })
        );
        abortController.abort();
        controller.close();
      });
      currentAgent.addEventListener(
        "message",
        (event) => {
          let data;
          try {
            data = JSON.parse(event.data);
          } catch (_error) {
            return;
          }
          if (data.type === "cf_agent_use_chat_response" /* CF_AGENT_USE_CHAT_RESPONSE */) {
            if (data.id === id) {
              if (data.error) {
                controller.error(new Error(data.body));
                abortController.abort();
              } else {
                if (data.body?.trim()) {
                  controller.enqueue(
                    new TextEncoder().encode(`data: ${data.body}

`)
                  );
                }
                if (data.done) {
                  controller.close();
                  abortController.abort();
                }
              }
            }
          }
        },
        { signal: abortController.signal }
      );
      const stream = new ReadableStream({
        start(c) {
          controller = c;
        }
      });
      currentAgent.send(
        JSON.stringify({
          id,
          init: {
            body,
            credentials,
            headers,
            integrity,
            keepalive,
            method,
            mode,
            redirect,
            referrer,
            referrerPolicy,
            window
          },
          type: "cf_agent_use_chat_request" /* CF_AGENT_USE_CHAT_REQUEST */,
          url: request.toString()
        })
      );
      return new Response(stream);
    },
    []
  );
  const customTransport = useMemo(
    () => ({
      sendMessages: async (options2) => {
        const transport = new DefaultChatTransport({
          api: agentUrlString,
          fetch: aiFetch
        });
        return transport.sendMessages(options2);
      },
      reconnectToStream: async (options2) => {
        const transport = new DefaultChatTransport({
          api: agentUrlString,
          fetch: aiFetch
        });
        return transport.reconnectToStream(options2);
      }
    }),
    [agentUrlString, aiFetch]
  );
  const useChatHelpers = useChat({
    ...rest,
    messages: initialMessages,
    transport: customTransport,
    id: agent._pk
  });
  const processedToolCalls = useRef(/* @__PURE__ */ new Set());
  const lastMessage = useChatHelpers.messages[useChatHelpers.messages.length - 1];
  const pendingConfirmations = (() => {
    if (!lastMessage || lastMessage.role !== "assistant") {
      return { messageId: void 0, toolCallIds: /* @__PURE__ */ new Set() };
    }
    const pendingIds = /* @__PURE__ */ new Set();
    for (const part of lastMessage.parts ?? []) {
      if (isToolUIPart(part) && part.state === "input-available" && toolsRequiringConfirmation.includes(getToolName(part))) {
        pendingIds.add(part.toolCallId);
      }
    }
    return { messageId: lastMessage.id, toolCallIds: pendingIds };
  })();
  const pendingConfirmationsRef = useRef(pendingConfirmations);
  pendingConfirmationsRef.current = pendingConfirmations;
  useEffect(() => {
    if (!experimental_automaticToolResolution) {
      return;
    }
    const lastMessage2 = useChatHelpers.messages[useChatHelpers.messages.length - 1];
    if (!lastMessage2 || lastMessage2.role !== "assistant") {
      return;
    }
    const toolCalls = lastMessage2.parts.filter(
      (part) => isToolUIPart(part) && part.state === "input-available" && !processedToolCalls.current.has(part.toolCallId)
    );
    if (toolCalls.length > 0) {
      (async () => {
        const toolCallsToResolve = toolCalls.filter(
          (part) => isToolUIPart(part) && !toolsRequiringConfirmation.includes(getToolName(part)) && tools?.[getToolName(part)]?.execute
          // Only execute if client has execute function
        );
        if (toolCallsToResolve.length > 0) {
          for (const part of toolCallsToResolve) {
            if (isToolUIPart(part)) {
              processedToolCalls.current.add(part.toolCallId);
              let toolOutput = null;
              const toolName = getToolName(part);
              const tool = tools?.[toolName];
              if (tool?.execute && part.input) {
                try {
                  toolOutput = await tool.execute(part.input);
                } catch (error) {
                  toolOutput = `Error executing tool: ${error instanceof Error ? error.message : String(error)}`;
                }
              }
              await useChatHelpers.addToolResult({
                toolCallId: part.toolCallId,
                tool: toolName,
                output: toolOutput
              });
            }
          }
          if (pendingConfirmationsRef.current.toolCallIds.size === 0) {
            useChatHelpers.sendMessage();
          }
        }
      })();
    }
  }, [
    useChatHelpers.messages,
    experimental_automaticToolResolution,
    useChatHelpers.addToolResult,
    useChatHelpers.sendMessage,
    toolsRequiringConfirmation
  ]);
  useEffect(() => {
    function onClearHistory(event) {
      if (typeof event.data !== "string") return;
      let data;
      try {
        data = JSON.parse(event.data);
      } catch (_error) {
        return;
      }
      if (data.type === "cf_agent_chat_clear" /* CF_AGENT_CHAT_CLEAR */) {
        useChatHelpers.setMessages([]);
      }
    }
    function onMessages(event) {
      if (typeof event.data !== "string") return;
      let data;
      try {
        data = JSON.parse(event.data);
      } catch (_error) {
        return;
      }
      if (data.type === "cf_agent_chat_messages" /* CF_AGENT_CHAT_MESSAGES */) {
        useChatHelpers.setMessages(data.messages);
      }
    }
    agent.addEventListener("message", onClearHistory);
    agent.addEventListener("message", onMessages);
    return () => {
      agent.removeEventListener("message", onClearHistory);
      agent.removeEventListener("message", onMessages);
    };
  }, [agent, useChatHelpers.setMessages]);
  const addToolResultAndSendMessage = async (args) => {
    const { toolCallId } = args;
    await useChatHelpers.addToolResult(args);
    if (!autoSendAfterAllConfirmationsResolved) {
      useChatHelpers.sendMessage();
      return;
    }
    const pending = pendingConfirmationsRef.current?.toolCallIds;
    if (!pending) {
      useChatHelpers.sendMessage();
      return;
    }
    const wasLast = pending.size === 1 && pending.has(toolCallId);
    if (pending.has(toolCallId)) {
      pending.delete(toolCallId);
    }
    if (wasLast || pending.size === 0) {
      useChatHelpers.sendMessage();
    }
  };
  return {
    ...useChatHelpers,
    addToolResult: addToolResultAndSendMessage,
    clearHistory: () => {
      useChatHelpers.setMessages([]);
      agent.send(
        JSON.stringify({
          type: "cf_agent_chat_clear" /* CF_AGENT_CHAT_CLEAR */
        })
      );
    },
    setMessages: (messages) => {
      useChatHelpers.setMessages(messages);
      agent.send(
        JSON.stringify({
          messages: Array.isArray(messages) ? messages : [],
          type: "cf_agent_chat_messages" /* CF_AGENT_CHAT_MESSAGES */
        })
      );
    }
  };
}
export {
  detectToolsRequiringConfirmation,
  useAgentChat
};
//# sourceMappingURL=ai-react.js.map