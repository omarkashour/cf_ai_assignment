{"version":3,"sources":["../src/react.tsx"],"sourcesContent":["import type { PartySocket } from \"partysocket\";\nimport { usePartySocket } from \"partysocket/react\";\nimport { useCallback, useRef, use, useMemo, useEffect } from \"react\";\nimport type { Agent, MCPServersState, RPCRequest, RPCResponse } from \"./\";\nimport type { StreamOptions } from \"./client\";\nimport type { Method, RPCMethod } from \"./serializable\";\nimport { MessageType } from \"./ai-types\";\n\n/**\n * Convert a camelCase string to a kebab-case string\n * @param str The string to convert\n * @returns The kebab-case string\n */\nfunction camelCaseToKebabCase(str: string): string {\n  // If string is all uppercase, convert to lowercase\n  if (str === str.toUpperCase() && str !== str.toLowerCase()) {\n    return str.toLowerCase().replace(/_/g, \"-\");\n  }\n\n  // Otherwise handle camelCase to kebab-case\n  let kebabified = str.replace(\n    /[A-Z]/g,\n    (letter) => `-${letter.toLowerCase()}`\n  );\n  kebabified = kebabified.startsWith(\"-\") ? kebabified.slice(1) : kebabified;\n  // Convert any remaining underscores to hyphens and remove trailing -'s\n  return kebabified.replace(/_/g, \"-\").replace(/-$/, \"\");\n}\n\ntype QueryObject = Record<string, string | null>;\n\nconst queryCache = new Map<\n  unknown[],\n  {\n    promise: Promise<QueryObject>;\n    refCount: number;\n    expiresAt: number;\n    cacheTtl?: number;\n  }\n>();\n\nfunction arraysEqual(a: unknown[], b: unknown[]): boolean {\n  if (a === b) return true;\n  if (a.length !== b.length) return false;\n\n  for (let i = 0; i < a.length; i++) {\n    if (!Object.is(a[i], b[i])) return false;\n  }\n  return true;\n}\n\nfunction findCacheEntry(\n  targetKey: unknown[]\n): Promise<QueryObject> | undefined {\n  for (const [existingKey, entry] of queryCache.entries()) {\n    if (arraysEqual(existingKey, targetKey)) {\n      // Check if entry has expired\n      if (Date.now() > entry.expiresAt) {\n        queryCache.delete(existingKey);\n        return undefined;\n      }\n      entry.refCount++;\n      return entry.promise;\n    }\n  }\n  return undefined;\n}\n\nfunction setCacheEntry(\n  key: unknown[],\n  value: Promise<QueryObject>,\n  cacheTtl?: number\n): void {\n  // Remove any existing entry with matching members\n  for (const [existingKey] of queryCache.entries()) {\n    if (arraysEqual(existingKey, key)) {\n      queryCache.delete(existingKey);\n      break;\n    }\n  }\n\n  const expiresAt = cacheTtl\n    ? Date.now() + cacheTtl\n    : Date.now() + 5 * 60 * 1000; // Default 5 minutes\n  queryCache.set(key, { promise: value, refCount: 1, expiresAt, cacheTtl });\n}\n\nfunction decrementCacheEntry(targetKey: unknown[]): boolean {\n  for (const [existingKey, entry] of queryCache.entries()) {\n    if (arraysEqual(existingKey, targetKey)) {\n      entry.refCount--;\n      if (entry.refCount <= 0) {\n        queryCache.delete(existingKey);\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction createCacheKey(\n  agentNamespace: string,\n  name: string | undefined,\n  deps: unknown[]\n): unknown[] {\n  return [agentNamespace, name || \"default\", ...deps];\n}\n\n/**\n * Options for the useAgent hook\n * @template State Type of the Agent's state\n */\nexport type UseAgentOptions<State = unknown> = Omit<\n  Parameters<typeof usePartySocket>[0],\n  \"party\" | \"room\" | \"query\"\n> & {\n  /** Name of the agent to connect to */\n  agent: string;\n  /** Name of the specific Agent instance */\n  name?: string;\n  /** Query parameters - can be static object or async function */\n  query?: QueryObject | (() => Promise<QueryObject>);\n  /** Dependencies for async query caching */\n  queryDeps?: unknown[];\n  /** Cache TTL in milliseconds for auth tokens/time-sensitive data */\n  cacheTtl?: number;\n  /** Called when the Agent's state is updated */\n  onStateUpdate?: (state: State, source: \"server\" | \"client\") => void;\n  /** Called when MCP server state is updated */\n  onMcpUpdate?: (mcpServers: MCPServersState) => void;\n};\n\ntype AllOptional<T> = T extends [infer A, ...infer R]\n  ? undefined extends A\n    ? AllOptional<R>\n    : false\n  : true; // no params means optional by default\n\ntype RPCMethods<T> = {\n  [K in keyof T as T[K] extends RPCMethod<T[K]> ? K : never]: RPCMethod<T[K]>;\n};\n\ntype OptionalParametersMethod<T extends RPCMethod> =\n  AllOptional<Parameters<T>> extends true ? T : never;\n\n// all methods of the Agent, excluding the ones that are declared in the base Agent class\n// biome-ignore lint: suppressions/parse\ntype AgentMethods<T> = Omit<RPCMethods<T>, keyof Agent<any, any>>;\n\ntype OptionalAgentMethods<T> = {\n  [K in keyof AgentMethods<T> as AgentMethods<T>[K] extends OptionalParametersMethod<\n    AgentMethods<T>[K]\n  >\n    ? K\n    : never]: OptionalParametersMethod<AgentMethods<T>[K]>;\n};\n\ntype RequiredAgentMethods<T> = Omit<\n  AgentMethods<T>,\n  keyof OptionalAgentMethods<T>\n>;\n\ntype AgentPromiseReturnType<T, K extends keyof AgentMethods<T>> =\n  // biome-ignore lint: suppressions/parse\n  ReturnType<AgentMethods<T>[K]> extends Promise<any>\n    ? ReturnType<AgentMethods<T>[K]>\n    : Promise<ReturnType<AgentMethods<T>[K]>>;\n\ntype OptionalArgsAgentMethodCall<AgentT> = <\n  K extends keyof OptionalAgentMethods<AgentT>\n>(\n  method: K,\n  args?: Parameters<OptionalAgentMethods<AgentT>[K]>,\n  streamOptions?: StreamOptions\n) => AgentPromiseReturnType<AgentT, K>;\n\ntype RequiredArgsAgentMethodCall<AgentT> = <\n  K extends keyof RequiredAgentMethods<AgentT>\n>(\n  method: K,\n  args: Parameters<RequiredAgentMethods<AgentT>[K]>,\n  streamOptions?: StreamOptions\n) => AgentPromiseReturnType<AgentT, K>;\n\ntype AgentMethodCall<AgentT> = OptionalArgsAgentMethodCall<AgentT> &\n  RequiredArgsAgentMethodCall<AgentT>;\n\ntype UntypedAgentMethodCall = <T = unknown>(\n  method: string,\n  args?: unknown[],\n  streamOptions?: StreamOptions\n) => Promise<T>;\n\ntype AgentStub<T> = {\n  [K in keyof AgentMethods<T>]: (\n    ...args: Parameters<AgentMethods<T>[K]>\n  ) => AgentPromiseReturnType<AgentMethods<T>, K>;\n};\n\n// we neet to use Method instead of RPCMethod here for retro-compatibility\ntype UntypedAgentStub = Record<string, Method>;\n\n/**\n * React hook for connecting to an Agent\n */\nexport function useAgent<State = unknown>(\n  options: UseAgentOptions<State>\n): PartySocket & {\n  agent: string;\n  name: string;\n  setState: (state: State) => void;\n  call: UntypedAgentMethodCall;\n  stub: UntypedAgentStub;\n};\nexport function useAgent<\n  AgentT extends {\n    get state(): State;\n  },\n  State\n>(\n  options: UseAgentOptions<State>\n): PartySocket & {\n  agent: string;\n  name: string;\n  setState: (state: State) => void;\n  call: AgentMethodCall<AgentT>;\n  stub: AgentStub<AgentT>;\n};\nexport function useAgent<State>(\n  options: UseAgentOptions<unknown>\n): PartySocket & {\n  agent: string;\n  name: string;\n  setState: (state: State) => void;\n  call: UntypedAgentMethodCall | AgentMethodCall<unknown>;\n  stub: UntypedAgentStub;\n} {\n  const agentNamespace = camelCaseToKebabCase(options.agent);\n  const { query, queryDeps, cacheTtl, ...restOptions } = options;\n\n  // Keep track of pending RPC calls\n  const pendingCallsRef = useRef(\n    new Map<\n      string,\n      {\n        resolve: (value: unknown) => void;\n        reject: (error: Error) => void;\n        stream?: StreamOptions;\n      }\n    >()\n  );\n\n  // Handle both sync and async query patterns\n  const cacheKey = useMemo(() => {\n    const deps = queryDeps || [];\n    return createCacheKey(agentNamespace, options.name, deps);\n  }, [agentNamespace, options.name, queryDeps]);\n\n  const queryPromise = useMemo(() => {\n    if (!query || typeof query !== \"function\") {\n      return null;\n    }\n\n    const existingPromise = findCacheEntry(cacheKey);\n    if (existingPromise) {\n      return existingPromise;\n    }\n\n    const promise = query().catch((error) => {\n      console.error(\n        `[useAgent] Query failed for agent \"${options.agent}\":`,\n        error\n      );\n      decrementCacheEntry(cacheKey); // Remove failed promise from cache\n      throw error; // Re-throw for Suspense error boundary\n    });\n\n    setCacheEntry(cacheKey, promise, cacheTtl);\n\n    return promise;\n  }, [cacheKey, query, options.agent, cacheTtl]);\n\n  let resolvedQuery: QueryObject | undefined;\n\n  if (query) {\n    if (typeof query === \"function\") {\n      // Use React's use() to resolve the promise\n      const queryResult = use(queryPromise!);\n\n      // Check for non-primitive values and warn\n      if (queryResult) {\n        for (const [key, value] of Object.entries(queryResult)) {\n          if (\n            value !== null &&\n            value !== undefined &&\n            typeof value !== \"string\" &&\n            typeof value !== \"number\" &&\n            typeof value !== \"boolean\"\n          ) {\n            console.warn(\n              `[useAgent] Query parameter \"${key}\" is an object and will be converted to \"[object Object]\". ` +\n                \"Query parameters should be string, number, boolean, or null.\"\n            );\n          }\n        }\n        resolvedQuery = queryResult;\n      }\n    } else {\n      // Sync query - use directly\n      resolvedQuery = query;\n    }\n  }\n\n  // Cleanup cache on unmount\n  useEffect(() => {\n    return () => {\n      if (queryPromise) {\n        decrementCacheEntry(cacheKey);\n      }\n    };\n  }, [cacheKey, queryPromise]);\n\n  const agent = usePartySocket({\n    party: agentNamespace,\n    prefix: \"agents\",\n    room: options.name || \"default\",\n    query: resolvedQuery,\n    ...restOptions,\n    onMessage: (message) => {\n      if (typeof message.data === \"string\") {\n        let parsedMessage: Record<string, unknown>;\n        try {\n          parsedMessage = JSON.parse(message.data);\n        } catch (_error) {\n          // silently ignore invalid messages for now\n          // TODO: log errors with log levels\n          return options.onMessage?.(message);\n        }\n        if (parsedMessage.type === MessageType.CF_AGENT_STATE) {\n          options.onStateUpdate?.(parsedMessage.state as State, \"server\");\n          return;\n        }\n        if (parsedMessage.type === MessageType.CF_AGENT_MCP_SERVERS) {\n          options.onMcpUpdate?.(parsedMessage.mcp as MCPServersState);\n          return;\n        }\n        if (parsedMessage.type === MessageType.RPC) {\n          const response = parsedMessage as RPCResponse;\n          const pending = pendingCallsRef.current.get(response.id);\n          if (!pending) return;\n\n          if (!response.success) {\n            pending.reject(new Error(response.error));\n            pendingCallsRef.current.delete(response.id);\n            pending.stream?.onError?.(response.error);\n            return;\n          }\n\n          // Handle streaming responses\n          if (\"done\" in response) {\n            if (response.done) {\n              pending.resolve(response.result);\n              pendingCallsRef.current.delete(response.id);\n              pending.stream?.onDone?.(response.result);\n            } else {\n              pending.stream?.onChunk?.(response.result);\n            }\n          } else {\n            // Non-streaming response\n            pending.resolve(response.result);\n            pendingCallsRef.current.delete(response.id);\n          }\n          return;\n        }\n      }\n      options.onMessage?.(message);\n    }\n  }) as PartySocket & {\n    agent: string;\n    name: string;\n    setState: (state: State) => void;\n    call: UntypedAgentMethodCall;\n    stub: UntypedAgentStub;\n  };\n  // Create the call method\n  const call = useCallback(\n    <T = unknown,>(\n      method: string,\n      args: unknown[] = [],\n      streamOptions?: StreamOptions\n    ): Promise<T> => {\n      return new Promise((resolve, reject) => {\n        const id = Math.random().toString(36).slice(2);\n        pendingCallsRef.current.set(id, {\n          reject,\n          resolve: resolve as (value: unknown) => void,\n          stream: streamOptions\n        });\n\n        const request: RPCRequest = {\n          args,\n          id,\n          method,\n          type: MessageType.RPC\n        };\n\n        agent.send(JSON.stringify(request));\n      });\n    },\n    [agent]\n  );\n\n  agent.setState = (state: State) => {\n    agent.send(JSON.stringify({ state, type: MessageType.CF_AGENT_STATE }));\n    options.onStateUpdate?.(state, \"client\");\n  };\n\n  agent.call = call;\n  agent.agent = agentNamespace;\n  agent.name = options.name || \"default\";\n  // biome-ignore lint: suppressions/parse\n  agent.stub = new Proxy<any>(\n    {},\n    {\n      get: (_target, method) => {\n        return (...args: unknown[]) => {\n          return call(method as string, args);\n        };\n      }\n    }\n  );\n\n  // warn if agent isn't in lowercase\n  if (agent.agent !== agent.agent.toLowerCase()) {\n    console.warn(\n      `Agent name: ${agent.agent} should probably be in lowercase. Received: ${agent.agent}`\n    );\n  }\n\n  return agent;\n}\n"],"mappings":"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","names":[]}