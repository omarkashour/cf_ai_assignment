import "./chunk-BER7KXUJ.js";
import "./chunk-PR4QN5HX.js";

// src/react.tsx
import { usePartySocket } from "partysocket/react";
import { useCallback, useRef, use, useMemo, useEffect } from "react";
function camelCaseToKebabCase(str) {
  if (str === str.toUpperCase() && str !== str.toLowerCase()) {
    return str.toLowerCase().replace(/_/g, "-");
  }
  let kebabified = str.replace(
    /[A-Z]/g,
    (letter) => `-${letter.toLowerCase()}`
  );
  kebabified = kebabified.startsWith("-") ? kebabified.slice(1) : kebabified;
  return kebabified.replace(/_/g, "-").replace(/-$/, "");
}
var queryCache = /* @__PURE__ */ new Map();
function arraysEqual(a, b) {
  if (a === b) return true;
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (!Object.is(a[i], b[i])) return false;
  }
  return true;
}
function findCacheEntry(targetKey) {
  for (const [existingKey, entry] of queryCache.entries()) {
    if (arraysEqual(existingKey, targetKey)) {
      if (Date.now() > entry.expiresAt) {
        queryCache.delete(existingKey);
        return void 0;
      }
      entry.refCount++;
      return entry.promise;
    }
  }
  return void 0;
}
function setCacheEntry(key, value, cacheTtl) {
  for (const [existingKey] of queryCache.entries()) {
    if (arraysEqual(existingKey, key)) {
      queryCache.delete(existingKey);
      break;
    }
  }
  const expiresAt = cacheTtl ? Date.now() + cacheTtl : Date.now() + 5 * 60 * 1e3;
  queryCache.set(key, { promise: value, refCount: 1, expiresAt, cacheTtl });
}
function decrementCacheEntry(targetKey) {
  for (const [existingKey, entry] of queryCache.entries()) {
    if (arraysEqual(existingKey, targetKey)) {
      entry.refCount--;
      if (entry.refCount <= 0) {
        queryCache.delete(existingKey);
      }
      return true;
    }
  }
  return false;
}
function createCacheKey(agentNamespace, name, deps) {
  return [agentNamespace, name || "default", ...deps];
}
function useAgent(options) {
  const agentNamespace = camelCaseToKebabCase(options.agent);
  const { query, queryDeps, cacheTtl, ...restOptions } = options;
  const pendingCallsRef = useRef(
    /* @__PURE__ */ new Map()
  );
  const cacheKey = useMemo(() => {
    const deps = queryDeps || [];
    return createCacheKey(agentNamespace, options.name, deps);
  }, [agentNamespace, options.name, queryDeps]);
  const queryPromise = useMemo(() => {
    if (!query || typeof query !== "function") {
      return null;
    }
    const existingPromise = findCacheEntry(cacheKey);
    if (existingPromise) {
      return existingPromise;
    }
    const promise = query().catch((error) => {
      console.error(
        `[useAgent] Query failed for agent "${options.agent}":`,
        error
      );
      decrementCacheEntry(cacheKey);
      throw error;
    });
    setCacheEntry(cacheKey, promise, cacheTtl);
    return promise;
  }, [cacheKey, query, options.agent, cacheTtl]);
  let resolvedQuery;
  if (query) {
    if (typeof query === "function") {
      const queryResult = use(queryPromise);
      if (queryResult) {
        for (const [key, value] of Object.entries(queryResult)) {
          if (value !== null && value !== void 0 && typeof value !== "string" && typeof value !== "number" && typeof value !== "boolean") {
            console.warn(
              `[useAgent] Query parameter "${key}" is an object and will be converted to "[object Object]". Query parameters should be string, number, boolean, or null.`
            );
          }
        }
        resolvedQuery = queryResult;
      }
    } else {
      resolvedQuery = query;
    }
  }
  useEffect(() => {
    return () => {
      if (queryPromise) {
        decrementCacheEntry(cacheKey);
      }
    };
  }, [cacheKey, queryPromise]);
  const agent = usePartySocket({
    party: agentNamespace,
    prefix: "agents",
    room: options.name || "default",
    query: resolvedQuery,
    ...restOptions,
    onMessage: (message) => {
      if (typeof message.data === "string") {
        let parsedMessage;
        try {
          parsedMessage = JSON.parse(message.data);
        } catch (_error) {
          return options.onMessage?.(message);
        }
        if (parsedMessage.type === "cf_agent_state" /* CF_AGENT_STATE */) {
          options.onStateUpdate?.(parsedMessage.state, "server");
          return;
        }
        if (parsedMessage.type === "cf_agent_mcp_servers" /* CF_AGENT_MCP_SERVERS */) {
          options.onMcpUpdate?.(parsedMessage.mcp);
          return;
        }
        if (parsedMessage.type === "rpc" /* RPC */) {
          const response = parsedMessage;
          const pending = pendingCallsRef.current.get(response.id);
          if (!pending) return;
          if (!response.success) {
            pending.reject(new Error(response.error));
            pendingCallsRef.current.delete(response.id);
            pending.stream?.onError?.(response.error);
            return;
          }
          if ("done" in response) {
            if (response.done) {
              pending.resolve(response.result);
              pendingCallsRef.current.delete(response.id);
              pending.stream?.onDone?.(response.result);
            } else {
              pending.stream?.onChunk?.(response.result);
            }
          } else {
            pending.resolve(response.result);
            pendingCallsRef.current.delete(response.id);
          }
          return;
        }
      }
      options.onMessage?.(message);
    }
  });
  const call = useCallback(
    (method, args = [], streamOptions) => {
      return new Promise((resolve, reject) => {
        const id = Math.random().toString(36).slice(2);
        pendingCallsRef.current.set(id, {
          reject,
          resolve,
          stream: streamOptions
        });
        const request = {
          args,
          id,
          method,
          type: "rpc" /* RPC */
        };
        agent.send(JSON.stringify(request));
      });
    },
    [agent]
  );
  agent.setState = (state) => {
    agent.send(JSON.stringify({ state, type: "cf_agent_state" /* CF_AGENT_STATE */ }));
    options.onStateUpdate?.(state, "client");
  };
  agent.call = call;
  agent.agent = agentNamespace;
  agent.name = options.name || "default";
  agent.stub = new Proxy(
    {},
    {
      get: (_target, method) => {
        return (...args) => {
          return call(method, args);
        };
      }
    }
  );
  if (agent.agent !== agent.agent.toLowerCase()) {
    console.warn(
      `Agent name: ${agent.agent} should probably be in lowercase. Received: ${agent.agent}`
    );
  }
  return agent;
}
export {
  useAgent
};
//# sourceMappingURL=react.js.map