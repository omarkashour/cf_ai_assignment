{"version":3,"sources":["../src/index.ts","../src/observability/index.ts"],"sourcesContent":["import type { env } from \"cloudflare:workers\";\nimport { AsyncLocalStorage } from \"node:async_hooks\";\nimport type { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport type { SSEClientTransportOptions } from \"@modelcontextprotocol/sdk/client/sse.js\";\n\nimport type {\n  Prompt,\n  Resource,\n  ServerCapabilities,\n  Tool\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport { parseCronExpression } from \"cron-schedule\";\nimport { nanoid } from \"nanoid\";\nimport { EmailMessage } from \"cloudflare:email\";\nimport {\n  type Connection,\n  type ConnectionContext,\n  type PartyServerOptions,\n  Server,\n  type WSMessage,\n  getServerByName,\n  routePartykitRequest\n} from \"partyserver\";\nimport { camelCaseToKebabCase } from \"./client\";\nimport { MCPClientManager, type MCPClientOAuthResult } from \"./mcp/client\";\nimport type { MCPConnectionState } from \"./mcp/client-connection\";\nimport { DurableObjectOAuthClientProvider } from \"./mcp/do-oauth-client-provider\";\nimport type { TransportType } from \"./mcp/types\";\nimport { genericObservability, type Observability } from \"./observability\";\nimport { DisposableStore } from \"./core/events\";\nimport { MessageType } from \"./ai-types\";\n\nexport type { Connection, ConnectionContext, WSMessage } from \"partyserver\";\n\n/**\n * RPC request message from client\n */\nexport type RPCRequest = {\n  type: \"rpc\";\n  id: string;\n  method: string;\n  args: unknown[];\n};\n\n/**\n * State update message from client\n */\nexport type StateUpdateMessage = {\n  type: MessageType.CF_AGENT_STATE;\n  state: unknown;\n};\n\n/**\n * RPC response message to client\n */\nexport type RPCResponse = {\n  type: MessageType.RPC;\n  id: string;\n} & (\n  | {\n      success: true;\n      result: unknown;\n      done?: false;\n    }\n  | {\n      success: true;\n      result: unknown;\n      done: true;\n    }\n  | {\n      success: false;\n      error: string;\n    }\n);\n\n/**\n * Type guard for RPC request messages\n */\nfunction isRPCRequest(msg: unknown): msg is RPCRequest {\n  return (\n    typeof msg === \"object\" &&\n    msg !== null &&\n    \"type\" in msg &&\n    msg.type === MessageType.RPC &&\n    \"id\" in msg &&\n    typeof msg.id === \"string\" &&\n    \"method\" in msg &&\n    typeof msg.method === \"string\" &&\n    \"args\" in msg &&\n    Array.isArray((msg as RPCRequest).args)\n  );\n}\n\n/**\n * Type guard for state update messages\n */\nfunction isStateUpdateMessage(msg: unknown): msg is StateUpdateMessage {\n  return (\n    typeof msg === \"object\" &&\n    msg !== null &&\n    \"type\" in msg &&\n    msg.type === MessageType.CF_AGENT_STATE &&\n    \"state\" in msg\n  );\n}\n\n/**\n * Metadata for a callable method\n */\nexport type CallableMetadata = {\n  /** Optional description of what the method does */\n  description?: string;\n  /** Whether the method supports streaming responses */\n  streaming?: boolean;\n};\n\nconst callableMetadata = new Map<Function, CallableMetadata>();\n\n/**\n * Decorator that marks a method as callable by clients\n * @param metadata Optional metadata about the callable method\n */\nexport function callable(metadata: CallableMetadata = {}) {\n  return function callableDecorator<This, Args extends unknown[], Return>(\n    target: (this: This, ...args: Args) => Return,\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: later\n    context: ClassMethodDecoratorContext\n  ) {\n    if (!callableMetadata.has(target)) {\n      callableMetadata.set(target, metadata);\n    }\n\n    return target;\n  };\n}\n\nlet didWarnAboutUnstableCallable = false;\n\n/**\n * Decorator that marks a method as callable by clients\n * @deprecated this has been renamed to callable, and unstable_callable will be removed in the next major version\n * @param metadata Optional metadata about the callable method\n */\nexport const unstable_callable = (metadata: CallableMetadata = {}) => {\n  if (!didWarnAboutUnstableCallable) {\n    didWarnAboutUnstableCallable = true;\n    console.warn(\n      \"unstable_callable is deprecated, use callable instead. unstable_callable will be removed in the next major version.\"\n    );\n  }\n  callable(metadata);\n};\n\nexport type QueueItem<T = string> = {\n  id: string;\n  payload: T;\n  callback: keyof Agent<unknown>;\n  created_at: number;\n};\n\n/**\n * Represents a scheduled task within an Agent\n * @template T Type of the payload data\n */\nexport type Schedule<T = string> = {\n  /** Unique identifier for the schedule */\n  id: string;\n  /** Name of the method to be called */\n  callback: string;\n  /** Data to be passed to the callback */\n  payload: T;\n} & (\n  | {\n      /** Type of schedule for one-time execution at a specific time */\n      type: \"scheduled\";\n      /** Timestamp when the task should execute */\n      time: number;\n    }\n  | {\n      /** Type of schedule for delayed execution */\n      type: \"delayed\";\n      /** Timestamp when the task should execute */\n      time: number;\n      /** Number of seconds to delay execution */\n      delayInSeconds: number;\n    }\n  | {\n      /** Type of schedule for recurring execution based on cron expression */\n      type: \"cron\";\n      /** Timestamp for the next execution */\n      time: number;\n      /** Cron expression defining the schedule */\n      cron: string;\n    }\n);\n\nfunction getNextCronTime(cron: string) {\n  const interval = parseCronExpression(cron);\n  return interval.getNextDate();\n}\n\nexport type { TransportType } from \"./mcp/types\";\n\n/**\n * MCP Server state update message from server -> Client\n */\nexport type MCPServerMessage = {\n  type: MessageType.CF_AGENT_MCP_SERVERS;\n  mcp: MCPServersState;\n};\n\nexport type MCPServersState = {\n  servers: {\n    [id: string]: MCPServer;\n  };\n  tools: Tool[];\n  prompts: Prompt[];\n  resources: Resource[];\n};\n\nexport type MCPServer = {\n  name: string;\n  server_url: string;\n  auth_url: string | null;\n  // This state is specifically about the temporary process of getting a token (if needed).\n  // Scope outside of that can't be relied upon because when the DO sleeps, there's no way\n  // to communicate a change to a non-ready state.\n  state: MCPConnectionState;\n  instructions: string | null;\n  capabilities: ServerCapabilities | null;\n};\n\n/**\n * MCP Server data stored in DO SQL for resuming MCP Server connections\n */\ntype MCPServerRow = {\n  id: string;\n  name: string;\n  server_url: string;\n  client_id: string | null;\n  auth_url: string | null;\n  callback_url: string;\n  server_options: string;\n};\n\nconst STATE_ROW_ID = \"cf_state_row_id\";\nconst STATE_WAS_CHANGED = \"cf_state_was_changed\";\n\nconst DEFAULT_STATE = {} as unknown;\n\nconst agentContext = new AsyncLocalStorage<{\n  agent: Agent<unknown, unknown>;\n  connection: Connection | undefined;\n  request: Request | undefined;\n  email: AgentEmail | undefined;\n}>();\n\nexport function getCurrentAgent<\n  T extends Agent<unknown, unknown> = Agent<unknown, unknown>\n>(): {\n  agent: T | undefined;\n  connection: Connection | undefined;\n  request: Request | undefined;\n  email: AgentEmail | undefined;\n} {\n  const store = agentContext.getStore() as\n    | {\n        agent: T;\n        connection: Connection | undefined;\n        request: Request | undefined;\n        email: AgentEmail | undefined;\n      }\n    | undefined;\n  if (!store) {\n    return {\n      agent: undefined,\n      connection: undefined,\n      request: undefined,\n      email: undefined\n    };\n  }\n  return store;\n}\n\n/**\n * Wraps a method to run within the agent context, ensuring getCurrentAgent() works properly\n * @param agent The agent instance\n * @param method The method to wrap\n * @returns A wrapped method that runs within the agent context\n */\n\n// biome-ignore lint/suspicious/noExplicitAny: I can't typescript\nfunction withAgentContext<T extends (...args: any[]) => any>(\n  method: T\n): (this: Agent<unknown, unknown>, ...args: Parameters<T>) => ReturnType<T> {\n  return function (...args: Parameters<T>): ReturnType<T> {\n    const { connection, request, email, agent } = getCurrentAgent();\n\n    if (agent === this) {\n      // already wrapped, so we can just call the method\n      return method.apply(this, args);\n    }\n    // not wrapped, so we need to wrap it\n    return agentContext.run({ agent: this, connection, request, email }, () => {\n      return method.apply(this, args);\n    });\n  };\n}\n\n/**\n * Base class for creating Agent implementations\n * @template Env Environment type containing bindings\n * @template State State type to store within the Agent\n */\nexport class Agent<\n  Env = typeof env,\n  State = unknown,\n  Props extends Record<string, unknown> = Record<string, unknown>\n> extends Server<Env, Props> {\n  private _state = DEFAULT_STATE as State;\n  private _disposables = new DisposableStore();\n\n  private _ParentClass: typeof Agent<Env, State> =\n    Object.getPrototypeOf(this).constructor;\n\n  readonly mcp: MCPClientManager = new MCPClientManager(\n    this._ParentClass.name,\n    \"0.0.1\"\n  );\n\n  /**\n   * Initial state for the Agent\n   * Override to provide default state values\n   */\n  initialState: State = DEFAULT_STATE as State;\n\n  /**\n   * Current state of the Agent\n   */\n  get state(): State {\n    if (this._state !== DEFAULT_STATE) {\n      // state was previously set, and populated internal state\n      return this._state;\n    }\n    // looks like this is the first time the state is being accessed\n    // check if the state was set in a previous life\n    const wasChanged = this.sql<{ state: \"true\" | undefined }>`\n        SELECT state FROM cf_agents_state WHERE id = ${STATE_WAS_CHANGED}\n      `;\n\n    // ok, let's pick up the actual state from the db\n    const result = this.sql<{ state: State | undefined }>`\n      SELECT state FROM cf_agents_state WHERE id = ${STATE_ROW_ID}\n    `;\n\n    if (\n      wasChanged[0]?.state === \"true\" ||\n      // we do this check for people who updated their code before we shipped wasChanged\n      result[0]?.state\n    ) {\n      const state = result[0]?.state as string; // could be null?\n\n      this._state = JSON.parse(state);\n      return this._state;\n    }\n\n    // ok, this is the first time the state is being accessed\n    // and the state was not set in a previous life\n    // so we need to set the initial state (if provided)\n    if (this.initialState === DEFAULT_STATE) {\n      // no initial state provided, so we return undefined\n      return undefined as State;\n    }\n    // initial state provided, so we set the state,\n    // update db and return the initial state\n    this.setState(this.initialState);\n    return this.initialState;\n  }\n\n  /**\n   * Agent configuration options\n   */\n  static options = {\n    /** Whether the Agent should hibernate when inactive */\n    hibernate: true // default to hibernate\n  };\n\n  /**\n   * The observability implementation to use for the Agent\n   */\n  observability?: Observability = genericObservability;\n\n  /**\n   * Execute SQL queries against the Agent's database\n   * @template T Type of the returned rows\n   * @param strings SQL query template strings\n   * @param values Values to be inserted into the query\n   * @returns Array of query results\n   */\n  sql<T = Record<string, string | number | boolean | null>>(\n    strings: TemplateStringsArray,\n    ...values: (string | number | boolean | null)[]\n  ) {\n    let query = \"\";\n    try {\n      // Construct the SQL query with placeholders\n      query = strings.reduce(\n        (acc, str, i) => acc + str + (i < values.length ? \"?\" : \"\"),\n        \"\"\n      );\n\n      // Execute the SQL query with the provided values\n      return [...this.ctx.storage.sql.exec(query, ...values)] as T[];\n    } catch (e) {\n      console.error(`failed to execute sql query: ${query}`, e);\n      throw this.onError(e);\n    }\n  }\n  constructor(ctx: AgentContext, env: Env) {\n    super(ctx, env);\n\n    if (!wrappedClasses.has(this.constructor)) {\n      // Auto-wrap custom methods with agent context\n      this._autoWrapCustomMethods();\n      wrappedClasses.add(this.constructor);\n    }\n\n    // Broadcast server state after background connects (for OAuth servers)\n    this._disposables.add(\n      this.mcp.onConnected(async () => {\n        this.broadcastMcpServers();\n      })\n    );\n\n    // Emit MCP observability events\n    this._disposables.add(\n      this.mcp.onObservabilityEvent((event) => {\n        this.observability?.emit(event);\n      })\n    );\n\n    this.sql`\n      CREATE TABLE IF NOT EXISTS cf_agents_state (\n        id TEXT PRIMARY KEY NOT NULL,\n        state TEXT\n      )\n    `;\n\n    this.sql`\n      CREATE TABLE IF NOT EXISTS cf_agents_queues (\n        id TEXT PRIMARY KEY NOT NULL,\n        payload TEXT,\n        callback TEXT,\n        created_at INTEGER DEFAULT (unixepoch())\n      )\n    `;\n\n    void this.ctx.blockConcurrencyWhile(async () => {\n      return this._tryCatch(async () => {\n        // Create alarms table if it doesn't exist\n        this.sql`\n        CREATE TABLE IF NOT EXISTS cf_agents_schedules (\n          id TEXT PRIMARY KEY NOT NULL DEFAULT (randomblob(9)),\n          callback TEXT,\n          payload TEXT,\n          type TEXT NOT NULL CHECK(type IN ('scheduled', 'delayed', 'cron')),\n          time INTEGER,\n          delayInSeconds INTEGER,\n          cron TEXT,\n          created_at INTEGER DEFAULT (unixepoch())\n        )\n      `;\n\n        // execute any pending alarms and schedule the next alarm\n        await this.alarm();\n      });\n    });\n\n    this.sql`\n      CREATE TABLE IF NOT EXISTS cf_agents_mcp_servers (\n        id TEXT PRIMARY KEY NOT NULL,\n        name TEXT NOT NULL,\n        server_url TEXT NOT NULL,\n        callback_url TEXT NOT NULL,\n        client_id TEXT,\n        auth_url TEXT,\n        server_options TEXT\n      )\n    `;\n\n    const _onRequest = this.onRequest.bind(this);\n    this.onRequest = (request: Request) => {\n      return agentContext.run(\n        { agent: this, connection: undefined, request, email: undefined },\n        async () => {\n          if (this.mcp.isCallbackRequest(request)) {\n            const result = await this.mcp.handleCallbackRequest(request);\n            this.broadcastMcpServers();\n\n            if (result.authSuccess) {\n              // Start background connection if auth was successful\n              this.mcp\n                .establishConnection(result.serverId)\n                .catch((error) => {\n                  console.error(\"Background connection failed:\", error);\n                })\n                .finally(() => {\n                  // Broadcast after background connection resolves (success/failure)\n                  this.broadcastMcpServers();\n                });\n            }\n\n            // Handle OAuth callback response using MCPClientManager configuration\n            return this.handleOAuthCallbackResponse(result, request);\n          }\n\n          return this._tryCatch(() => _onRequest(request));\n        }\n      );\n    };\n\n    const _onMessage = this.onMessage.bind(this);\n    this.onMessage = async (connection: Connection, message: WSMessage) => {\n      return agentContext.run(\n        { agent: this, connection, request: undefined, email: undefined },\n        async () => {\n          if (typeof message !== \"string\") {\n            return this._tryCatch(() => _onMessage(connection, message));\n          }\n\n          let parsed: unknown;\n          try {\n            parsed = JSON.parse(message);\n          } catch (_e) {\n            // silently fail and let the onMessage handler handle it\n            return this._tryCatch(() => _onMessage(connection, message));\n          }\n\n          if (isStateUpdateMessage(parsed)) {\n            this._setStateInternal(parsed.state as State, connection);\n            return;\n          }\n\n          if (isRPCRequest(parsed)) {\n            try {\n              const { id, method, args } = parsed;\n\n              // Check if method exists and is callable\n              const methodFn = this[method as keyof this];\n              if (typeof methodFn !== \"function\") {\n                throw new Error(`Method ${method} does not exist`);\n              }\n\n              if (!this._isCallable(method)) {\n                throw new Error(`Method ${method} is not callable`);\n              }\n\n              const metadata = callableMetadata.get(methodFn as Function);\n\n              // For streaming methods, pass a StreamingResponse object\n              if (metadata?.streaming) {\n                const stream = new StreamingResponse(connection, id);\n                await methodFn.apply(this, [stream, ...args]);\n                return;\n              }\n\n              // For regular methods, execute and send response\n              const result = await methodFn.apply(this, args);\n\n              this.observability?.emit(\n                {\n                  displayMessage: `RPC call to ${method}`,\n                  id: nanoid(),\n                  payload: {\n                    method,\n                    streaming: metadata?.streaming\n                  },\n                  timestamp: Date.now(),\n                  type: \"rpc\"\n                },\n                this.ctx\n              );\n\n              const response: RPCResponse = {\n                done: true,\n                id,\n                result,\n                success: true,\n                type: MessageType.RPC\n              };\n              connection.send(JSON.stringify(response));\n            } catch (e) {\n              // Send error response\n              const response: RPCResponse = {\n                error:\n                  e instanceof Error ? e.message : \"Unknown error occurred\",\n                id: parsed.id,\n                success: false,\n                type: MessageType.RPC\n              };\n              connection.send(JSON.stringify(response));\n              console.error(\"RPC error:\", e);\n            }\n            return;\n          }\n\n          return this._tryCatch(() => _onMessage(connection, message));\n        }\n      );\n    };\n\n    const _onConnect = this.onConnect.bind(this);\n    this.onConnect = (connection: Connection, ctx: ConnectionContext) => {\n      // TODO: This is a hack to ensure the state is sent after the connection is established\n      // must fix this\n      return agentContext.run(\n        { agent: this, connection, request: ctx.request, email: undefined },\n        () => {\n          if (this.state) {\n            connection.send(\n              JSON.stringify({\n                state: this.state,\n                type: MessageType.CF_AGENT_STATE\n              })\n            );\n          }\n\n          connection.send(\n            JSON.stringify({\n              mcp: this.getMcpServers(),\n              type: MessageType.CF_AGENT_MCP_SERVERS\n            })\n          );\n\n          this.observability?.emit(\n            {\n              displayMessage: \"Connection established\",\n              id: nanoid(),\n              payload: {\n                connectionId: connection.id\n              },\n              timestamp: Date.now(),\n              type: \"connect\"\n            },\n            this.ctx\n          );\n          return this._tryCatch(() => _onConnect(connection, ctx));\n        }\n      );\n    };\n\n    const _onStart = this.onStart.bind(this);\n    this.onStart = async (props?: Props) => {\n      return agentContext.run(\n        {\n          agent: this,\n          connection: undefined,\n          request: undefined,\n          email: undefined\n        },\n        async () => {\n          await this._tryCatch(() => {\n            const servers = this.sql<MCPServerRow>`\n            SELECT id, name, server_url, client_id, auth_url, callback_url, server_options FROM cf_agents_mcp_servers;\n          `;\n\n            this.broadcastMcpServers();\n\n            // from DO storage, reconnect to all servers not currently in the oauth flow using our saved auth information\n            if (servers && Array.isArray(servers) && servers.length > 0) {\n              // Restore callback URLs for OAuth-enabled servers\n              servers.forEach((server) => {\n                if (server.callback_url) {\n                  // Register the full redirect URL including serverId to avoid ambiguous matches\n                  this.mcp.registerCallbackUrl(\n                    `${server.callback_url}/${server.id}`\n                  );\n                }\n              });\n\n              servers.forEach((server) => {\n                this._connectToMcpServerInternal(\n                  server.name,\n                  server.server_url,\n                  server.callback_url,\n                  server.server_options\n                    ? JSON.parse(server.server_options)\n                    : undefined,\n                  {\n                    id: server.id,\n                    oauthClientId: server.client_id ?? undefined\n                  }\n                )\n                  .then(() => {\n                    // Broadcast updated MCP servers state after each server connects\n                    this.broadcastMcpServers();\n                  })\n                  .catch((error) => {\n                    console.error(\n                      `Error connecting to MCP server: ${server.name} (${server.server_url})`,\n                      error\n                    );\n                    // Still broadcast even if connection fails, so clients know about the failure\n                    this.broadcastMcpServers();\n                  });\n              });\n            }\n            return _onStart(props);\n          });\n        }\n      );\n    };\n  }\n\n  private _setStateInternal(\n    state: State,\n    source: Connection | \"server\" = \"server\"\n  ) {\n    this._state = state;\n    this.sql`\n    INSERT OR REPLACE INTO cf_agents_state (id, state)\n    VALUES (${STATE_ROW_ID}, ${JSON.stringify(state)})\n  `;\n    this.sql`\n    INSERT OR REPLACE INTO cf_agents_state (id, state)\n    VALUES (${STATE_WAS_CHANGED}, ${JSON.stringify(true)})\n  `;\n    this.broadcast(\n      JSON.stringify({\n        state: state,\n        type: MessageType.CF_AGENT_STATE\n      }),\n      source !== \"server\" ? [source.id] : []\n    );\n    return this._tryCatch(() => {\n      const { connection, request, email } = agentContext.getStore() || {};\n      return agentContext.run(\n        { agent: this, connection, request, email },\n        async () => {\n          this.observability?.emit(\n            {\n              displayMessage: \"State updated\",\n              id: nanoid(),\n              payload: {},\n              timestamp: Date.now(),\n              type: \"state:update\"\n            },\n            this.ctx\n          );\n          return this.onStateUpdate(state, source);\n        }\n      );\n    });\n  }\n\n  /**\n   * Update the Agent's state\n   * @param state New state to set\n   */\n  setState(state: State) {\n    this._setStateInternal(state, \"server\");\n  }\n\n  /**\n   * Called when the Agent's state is updated\n   * @param state Updated state\n   * @param source Source of the state update (\"server\" or a client connection)\n   */\n  // biome-ignore lint/correctness/noUnusedFunctionParameters: overridden later\n  onStateUpdate(state: State | undefined, source: Connection | \"server\") {\n    // override this to handle state updates\n  }\n\n  /**\n   * Called when the Agent receives an email via routeAgentEmail()\n   * Override this method to handle incoming emails\n   * @param email Email message to process\n   */\n  async _onEmail(email: AgentEmail) {\n    // nb: we use this roundabout way of getting to onEmail\n    // because of https://github.com/cloudflare/workerd/issues/4499\n    return agentContext.run(\n      { agent: this, connection: undefined, request: undefined, email: email },\n      async () => {\n        if (\"onEmail\" in this && typeof this.onEmail === \"function\") {\n          return this._tryCatch(() =>\n            (this.onEmail as (email: AgentEmail) => Promise<void>)(email)\n          );\n        } else {\n          console.log(\"Received email from:\", email.from, \"to:\", email.to);\n          console.log(\"Subject:\", email.headers.get(\"subject\"));\n          console.log(\n            \"Implement onEmail(email: AgentEmail): Promise<void> in your agent to process emails\"\n          );\n        }\n      }\n    );\n  }\n\n  /**\n   * Reply to an email\n   * @param email The email to reply to\n   * @param options Options for the reply\n   * @returns void\n   */\n  async replyToEmail(\n    email: AgentEmail,\n    options: {\n      fromName: string;\n      subject?: string | undefined;\n      body: string;\n      contentType?: string;\n      headers?: Record<string, string>;\n    }\n  ): Promise<void> {\n    return this._tryCatch(async () => {\n      const agentName = camelCaseToKebabCase(this._ParentClass.name);\n      const agentId = this.name;\n\n      const { createMimeMessage } = await import(\"mimetext\");\n      const msg = createMimeMessage();\n      msg.setSender({ addr: email.to, name: options.fromName });\n      msg.setRecipient(email.from);\n      msg.setSubject(\n        options.subject || `Re: ${email.headers.get(\"subject\")}` || \"No subject\"\n      );\n      msg.addMessage({\n        contentType: options.contentType || \"text/plain\",\n        data: options.body\n      });\n\n      const domain = email.from.split(\"@\")[1];\n      const messageId = `<${agentId}@${domain}>`;\n      msg.setHeader(\"In-Reply-To\", email.headers.get(\"Message-ID\")!);\n      msg.setHeader(\"Message-ID\", messageId);\n      msg.setHeader(\"X-Agent-Name\", agentName);\n      msg.setHeader(\"X-Agent-ID\", agentId);\n\n      if (options.headers) {\n        for (const [key, value] of Object.entries(options.headers)) {\n          msg.setHeader(key, value);\n        }\n      }\n      await email.reply({\n        from: email.to,\n        raw: msg.asRaw(),\n        to: email.from\n      });\n    });\n  }\n\n  private async _tryCatch<T>(fn: () => T | Promise<T>) {\n    try {\n      return await fn();\n    } catch (e) {\n      throw this.onError(e);\n    }\n  }\n\n  /**\n   * Automatically wrap custom methods with agent context\n   * This ensures getCurrentAgent() works in all custom methods without decorators\n   */\n  private _autoWrapCustomMethods() {\n    // Collect all methods from base prototypes (Agent and Server)\n    const basePrototypes = [Agent.prototype, Server.prototype];\n    const baseMethods = new Set<string>();\n    for (const baseProto of basePrototypes) {\n      let proto = baseProto;\n      while (proto && proto !== Object.prototype) {\n        const methodNames = Object.getOwnPropertyNames(proto);\n        for (const methodName of methodNames) {\n          baseMethods.add(methodName);\n        }\n        proto = Object.getPrototypeOf(proto);\n      }\n    }\n    // Get all methods from the current instance's prototype chain\n    let proto = Object.getPrototypeOf(this);\n    let depth = 0;\n    while (proto && proto !== Object.prototype && depth < 10) {\n      const methodNames = Object.getOwnPropertyNames(proto);\n      for (const methodName of methodNames) {\n        const descriptor = Object.getOwnPropertyDescriptor(proto, methodName);\n\n        // Skip if it's a private method, a base method, a getter, or not a function,\n        if (\n          baseMethods.has(methodName) ||\n          methodName.startsWith(\"_\") ||\n          !descriptor ||\n          !!descriptor.get ||\n          typeof descriptor.value !== \"function\"\n        ) {\n          continue;\n        }\n\n        // Now, methodName is confirmed to be a custom method/function\n        // Wrap the custom method with context\n        const wrappedFunction = withAgentContext(\n          // biome-ignore lint/suspicious/noExplicitAny: I can't typescript\n          this[methodName as keyof this] as (...args: any[]) => any\n          // biome-ignore lint/suspicious/noExplicitAny: I can't typescript\n        ) as any;\n\n        // if the method is callable, copy the metadata from the original method\n        if (this._isCallable(methodName)) {\n          callableMetadata.set(\n            wrappedFunction,\n            callableMetadata.get(this[methodName as keyof this] as Function)!\n          );\n        }\n\n        // set the wrapped function on the prototype\n        this.constructor.prototype[methodName as keyof this] = wrappedFunction;\n      }\n\n      proto = Object.getPrototypeOf(proto);\n      depth++;\n    }\n  }\n\n  override onError(\n    connection: Connection,\n    error: unknown\n  ): void | Promise<void>;\n  override onError(error: unknown): void | Promise<void>;\n  override onError(connectionOrError: Connection | unknown, error?: unknown) {\n    let theError: unknown;\n    if (connectionOrError && error) {\n      theError = error;\n      // this is a websocket connection error\n      console.error(\n        \"Error on websocket connection:\",\n        (connectionOrError as Connection).id,\n        theError\n      );\n      console.error(\n        \"Override onError(connection, error) to handle websocket connection errors\"\n      );\n    } else {\n      theError = connectionOrError;\n      // this is a server error\n      console.error(\"Error on server:\", theError);\n      console.error(\"Override onError(error) to handle server errors\");\n    }\n    throw theError;\n  }\n\n  /**\n   * Render content (not implemented in base class)\n   */\n  render() {\n    throw new Error(\"Not implemented\");\n  }\n\n  /**\n   * Queue a task to be executed in the future\n   * @param payload Payload to pass to the callback\n   * @param callback Name of the method to call\n   * @returns The ID of the queued task\n   */\n  async queue<T = unknown>(callback: keyof this, payload: T): Promise<string> {\n    const id = nanoid(9);\n    if (typeof callback !== \"string\") {\n      throw new Error(\"Callback must be a string\");\n    }\n\n    if (typeof this[callback] !== \"function\") {\n      throw new Error(`this.${callback} is not a function`);\n    }\n\n    this.sql`\n      INSERT OR REPLACE INTO cf_agents_queues (id, payload, callback)\n      VALUES (${id}, ${JSON.stringify(payload)}, ${callback})\n    `;\n\n    void this._flushQueue().catch((e) => {\n      console.error(\"Error flushing queue:\", e);\n    });\n\n    return id;\n  }\n\n  private _flushingQueue = false;\n\n  private async _flushQueue() {\n    if (this._flushingQueue) {\n      return;\n    }\n    this._flushingQueue = true;\n    while (true) {\n      const result = this.sql<QueueItem<string>>`\n      SELECT * FROM cf_agents_queues\n      ORDER BY created_at ASC\n    `;\n\n      if (!result || result.length === 0) {\n        break;\n      }\n\n      for (const row of result || []) {\n        const callback = this[row.callback as keyof Agent<Env>];\n        if (!callback) {\n          console.error(`callback ${row.callback} not found`);\n          continue;\n        }\n        const { connection, request, email } = agentContext.getStore() || {};\n        await agentContext.run(\n          {\n            agent: this,\n            connection,\n            request,\n            email\n          },\n          async () => {\n            // TODO: add retries and backoff\n            await (\n              callback as (\n                payload: unknown,\n                queueItem: QueueItem<string>\n              ) => Promise<void>\n            ).bind(this)(JSON.parse(row.payload as string), row);\n            await this.dequeue(row.id);\n          }\n        );\n      }\n    }\n    this._flushingQueue = false;\n  }\n\n  /**\n   * Dequeue a task by ID\n   * @param id ID of the task to dequeue\n   */\n  async dequeue(id: string) {\n    this.sql`DELETE FROM cf_agents_queues WHERE id = ${id}`;\n  }\n\n  /**\n   * Dequeue all tasks\n   */\n  async dequeueAll() {\n    this.sql`DELETE FROM cf_agents_queues`;\n  }\n\n  /**\n   * Dequeue all tasks by callback\n   * @param callback Name of the callback to dequeue\n   */\n  async dequeueAllByCallback(callback: string) {\n    this.sql`DELETE FROM cf_agents_queues WHERE callback = ${callback}`;\n  }\n\n  /**\n   * Get a queued task by ID\n   * @param id ID of the task to get\n   * @returns The task or undefined if not found\n   */\n  async getQueue(id: string): Promise<QueueItem<string> | undefined> {\n    const result = this.sql<QueueItem<string>>`\n      SELECT * FROM cf_agents_queues WHERE id = ${id}\n    `;\n    return result\n      ? { ...result[0], payload: JSON.parse(result[0].payload) }\n      : undefined;\n  }\n\n  /**\n   * Get all queues by key and value\n   * @param key Key to filter by\n   * @param value Value to filter by\n   * @returns Array of matching QueueItem objects\n   */\n  async getQueues(key: string, value: string): Promise<QueueItem<string>[]> {\n    const result = this.sql<QueueItem<string>>`\n      SELECT * FROM cf_agents_queues\n    `;\n    return result.filter((row) => JSON.parse(row.payload)[key] === value);\n  }\n\n  /**\n   * Schedule a task to be executed in the future\n   * @template T Type of the payload data\n   * @param when When to execute the task (Date, seconds delay, or cron expression)\n   * @param callback Name of the method to call\n   * @param payload Data to pass to the callback\n   * @returns Schedule object representing the scheduled task\n   */\n  async schedule<T = string>(\n    when: Date | string | number,\n    callback: keyof this,\n    payload?: T\n  ): Promise<Schedule<T>> {\n    const id = nanoid(9);\n\n    const emitScheduleCreate = (schedule: Schedule<T>) =>\n      this.observability?.emit(\n        {\n          displayMessage: `Schedule ${schedule.id} created`,\n          id: nanoid(),\n          payload: {\n            callback: callback as string,\n            id: id\n          },\n          timestamp: Date.now(),\n          type: \"schedule:create\"\n        },\n        this.ctx\n      );\n\n    if (typeof callback !== \"string\") {\n      throw new Error(\"Callback must be a string\");\n    }\n\n    if (typeof this[callback] !== \"function\") {\n      throw new Error(`this.${callback} is not a function`);\n    }\n\n    if (when instanceof Date) {\n      const timestamp = Math.floor(when.getTime() / 1000);\n      this.sql`\n        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, time)\n        VALUES (${id}, ${callback}, ${JSON.stringify(\n          payload\n        )}, 'scheduled', ${timestamp})\n      `;\n\n      await this._scheduleNextAlarm();\n\n      const schedule: Schedule<T> = {\n        callback: callback,\n        id,\n        payload: payload as T,\n        time: timestamp,\n        type: \"scheduled\"\n      };\n\n      emitScheduleCreate(schedule);\n\n      return schedule;\n    }\n    if (typeof when === \"number\") {\n      const time = new Date(Date.now() + when * 1000);\n      const timestamp = Math.floor(time.getTime() / 1000);\n\n      this.sql`\n        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, delayInSeconds, time)\n        VALUES (${id}, ${callback}, ${JSON.stringify(\n          payload\n        )}, 'delayed', ${when}, ${timestamp})\n      `;\n\n      await this._scheduleNextAlarm();\n\n      const schedule: Schedule<T> = {\n        callback: callback,\n        delayInSeconds: when,\n        id,\n        payload: payload as T,\n        time: timestamp,\n        type: \"delayed\"\n      };\n\n      emitScheduleCreate(schedule);\n\n      return schedule;\n    }\n    if (typeof when === \"string\") {\n      const nextExecutionTime = getNextCronTime(when);\n      const timestamp = Math.floor(nextExecutionTime.getTime() / 1000);\n\n      this.sql`\n        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, cron, time)\n        VALUES (${id}, ${callback}, ${JSON.stringify(\n          payload\n        )}, 'cron', ${when}, ${timestamp})\n      `;\n\n      await this._scheduleNextAlarm();\n\n      const schedule: Schedule<T> = {\n        callback: callback,\n        cron: when,\n        id,\n        payload: payload as T,\n        time: timestamp,\n        type: \"cron\"\n      };\n\n      emitScheduleCreate(schedule);\n\n      return schedule;\n    }\n    throw new Error(\"Invalid schedule type\");\n  }\n\n  /**\n   * Get a scheduled task by ID\n   * @template T Type of the payload data\n   * @param id ID of the scheduled task\n   * @returns The Schedule object or undefined if not found\n   */\n  async getSchedule<T = string>(id: string): Promise<Schedule<T> | undefined> {\n    const result = this.sql<Schedule<string>>`\n      SELECT * FROM cf_agents_schedules WHERE id = ${id}\n    `;\n    if (!result) {\n      console.error(`schedule ${id} not found`);\n      return undefined;\n    }\n\n    return { ...result[0], payload: JSON.parse(result[0].payload) as T };\n  }\n\n  /**\n   * Get scheduled tasks matching the given criteria\n   * @template T Type of the payload data\n   * @param criteria Criteria to filter schedules\n   * @returns Array of matching Schedule objects\n   */\n  getSchedules<T = string>(\n    criteria: {\n      id?: string;\n      type?: \"scheduled\" | \"delayed\" | \"cron\";\n      timeRange?: { start?: Date; end?: Date };\n    } = {}\n  ): Schedule<T>[] {\n    let query = \"SELECT * FROM cf_agents_schedules WHERE 1=1\";\n    const params = [];\n\n    if (criteria.id) {\n      query += \" AND id = ?\";\n      params.push(criteria.id);\n    }\n\n    if (criteria.type) {\n      query += \" AND type = ?\";\n      params.push(criteria.type);\n    }\n\n    if (criteria.timeRange) {\n      query += \" AND time >= ? AND time <= ?\";\n      const start = criteria.timeRange.start || new Date(0);\n      const end = criteria.timeRange.end || new Date(999999999999999);\n      params.push(\n        Math.floor(start.getTime() / 1000),\n        Math.floor(end.getTime() / 1000)\n      );\n    }\n\n    const result = this.ctx.storage.sql\n      .exec(query, ...params)\n      .toArray()\n      .map((row) => ({\n        ...row,\n        payload: JSON.parse(row.payload as string) as T\n      })) as Schedule<T>[];\n\n    return result;\n  }\n\n  /**\n   * Cancel a scheduled task\n   * @param id ID of the task to cancel\n   * @returns true if the task was cancelled, false otherwise\n   */\n  async cancelSchedule(id: string): Promise<boolean> {\n    const schedule = await this.getSchedule(id);\n    if (schedule) {\n      this.observability?.emit(\n        {\n          displayMessage: `Schedule ${id} cancelled`,\n          id: nanoid(),\n          payload: {\n            callback: schedule.callback,\n            id: schedule.id\n          },\n          timestamp: Date.now(),\n          type: \"schedule:cancel\"\n        },\n        this.ctx\n      );\n    }\n    this.sql`DELETE FROM cf_agents_schedules WHERE id = ${id}`;\n\n    await this._scheduleNextAlarm();\n    return true;\n  }\n\n  private async _scheduleNextAlarm() {\n    // Find the next schedule that needs to be executed\n    const result = this.sql`\n      SELECT time FROM cf_agents_schedules\n      WHERE time > ${Math.floor(Date.now() / 1000)}\n      ORDER BY time ASC\n      LIMIT 1\n    `;\n    if (!result) return;\n\n    if (result.length > 0 && \"time\" in result[0]) {\n      const nextTime = (result[0].time as number) * 1000;\n      await this.ctx.storage.setAlarm(nextTime);\n    }\n  }\n\n  /**\n   * Method called when an alarm fires.\n   * Executes any scheduled tasks that are due.\n   *\n   * @remarks\n   * To schedule a task, please use the `this.schedule` method instead.\n   * See {@link https://developers.cloudflare.com/agents/api-reference/schedule-tasks/}\n   */\n  public readonly alarm = async () => {\n    const now = Math.floor(Date.now() / 1000);\n\n    // Get all schedules that should be executed now\n    const result = this.sql<Schedule<string>>`\n      SELECT * FROM cf_agents_schedules WHERE time <= ${now}\n    `;\n\n    if (result && Array.isArray(result)) {\n      for (const row of result) {\n        const callback = this[row.callback as keyof Agent<Env>];\n        if (!callback) {\n          console.error(`callback ${row.callback} not found`);\n          continue;\n        }\n        await agentContext.run(\n          {\n            agent: this,\n            connection: undefined,\n            request: undefined,\n            email: undefined\n          },\n          async () => {\n            try {\n              this.observability?.emit(\n                {\n                  displayMessage: `Schedule ${row.id} executed`,\n                  id: nanoid(),\n                  payload: {\n                    callback: row.callback,\n                    id: row.id\n                  },\n                  timestamp: Date.now(),\n                  type: \"schedule:execute\"\n                },\n                this.ctx\n              );\n\n              await (\n                callback as (\n                  payload: unknown,\n                  schedule: Schedule<unknown>\n                ) => Promise<void>\n              ).bind(this)(JSON.parse(row.payload as string), row);\n            } catch (e) {\n              console.error(`error executing callback \"${row.callback}\"`, e);\n            }\n          }\n        );\n        if (row.type === \"cron\") {\n          // Update next execution time for cron schedules\n          const nextExecutionTime = getNextCronTime(row.cron);\n          const nextTimestamp = Math.floor(nextExecutionTime.getTime() / 1000);\n\n          this.sql`\n          UPDATE cf_agents_schedules SET time = ${nextTimestamp} WHERE id = ${row.id}\n        `;\n        } else {\n          // Delete one-time schedules after execution\n          this.sql`\n          DELETE FROM cf_agents_schedules WHERE id = ${row.id}\n        `;\n        }\n      }\n    }\n\n    // Schedule the next alarm\n    await this._scheduleNextAlarm();\n  };\n\n  /**\n   * Destroy the Agent, removing all state and scheduled tasks\n   */\n  async destroy() {\n    // drop all tables\n    this.sql`DROP TABLE IF EXISTS cf_agents_state`;\n    this.sql`DROP TABLE IF EXISTS cf_agents_schedules`;\n    this.sql`DROP TABLE IF EXISTS cf_agents_mcp_servers`;\n    this.sql`DROP TABLE IF EXISTS cf_agents_queues`;\n\n    // delete all alarms\n    await this.ctx.storage.deleteAlarm();\n    await this.ctx.storage.deleteAll();\n    this._disposables.dispose();\n    await this.mcp.dispose?.();\n    this.ctx.abort(\"destroyed\"); // enforce that the agent is evicted\n\n    this.observability?.emit(\n      {\n        displayMessage: \"Agent destroyed\",\n        id: nanoid(),\n        payload: {},\n        timestamp: Date.now(),\n        type: \"destroy\"\n      },\n      this.ctx\n    );\n  }\n\n  /**\n   * Get all methods marked as callable on this Agent\n   * @returns A map of method names to their metadata\n   */\n  private _isCallable(method: string): boolean {\n    return callableMetadata.has(this[method as keyof this] as Function);\n  }\n\n  /**\n   * Connect to a new MCP Server\n   *\n   * @param serverName Name of the MCP server\n   * @param url MCP Server SSE URL\n   * @param callbackHost Base host for the agent, used for the redirect URI. If not provided, will be derived from the current request.\n   * @param agentsPrefix agents routing prefix if not using `agents`\n   * @param options MCP client and transport options\n   * @returns authUrl\n   */\n  async addMcpServer(\n    serverName: string,\n    url: string,\n    callbackHost?: string,\n    agentsPrefix = \"agents\",\n    options?: {\n      client?: ConstructorParameters<typeof Client>[1];\n      transport?: {\n        headers?: HeadersInit;\n        type?: TransportType;\n      };\n    }\n  ): Promise<{ id: string; authUrl: string | undefined }> {\n    // If callbackHost is not provided, derive it from the current request\n    let resolvedCallbackHost = callbackHost;\n    if (!resolvedCallbackHost) {\n      const { request } = getCurrentAgent();\n      if (!request) {\n        throw new Error(\n          \"callbackHost is required when not called within a request context\"\n        );\n      }\n\n      // Extract the origin from the request\n      const requestUrl = new URL(request.url);\n      resolvedCallbackHost = `${requestUrl.protocol}//${requestUrl.host}`;\n    }\n\n    const callbackUrl = `${resolvedCallbackHost}/${agentsPrefix}/${camelCaseToKebabCase(this._ParentClass.name)}/${this.name}/callback`;\n\n    const result = await this._connectToMcpServerInternal(\n      serverName,\n      url,\n      callbackUrl,\n      options\n    );\n\n    this.sql`\n        INSERT\n        OR REPLACE INTO cf_agents_mcp_servers (id, name, server_url, client_id, auth_url, callback_url, server_options)\n      VALUES (\n        ${result.id},\n        ${serverName},\n        ${url},\n        ${result.clientId ?? null},\n        ${result.authUrl ?? null},\n        ${callbackUrl},\n        ${options ? JSON.stringify(options) : null}\n        );\n    `;\n\n    this.broadcastMcpServers();\n\n    return result;\n  }\n\n  private async _connectToMcpServerInternal(\n    _serverName: string,\n    url: string,\n    callbackUrl: string,\n    // it's important that any options here are serializable because we put them into our sqlite DB for reconnection purposes\n    options?: {\n      client?: ConstructorParameters<typeof Client>[1];\n      /**\n       * We don't expose the normal set of transport options because:\n       * 1) we can't serialize things like the auth provider or a fetch function into the DB for reconnection purposes\n       * 2) We probably want these options to be agnostic to the transport type (SSE vs Streamable)\n       *\n       * This has the limitation that you can't override fetch, but I think headers should handle nearly all cases needed (i.e. non-standard bearer auth).\n       */\n      transport?: {\n        headers?: HeadersInit;\n        type?: TransportType;\n      };\n    },\n    reconnect?: {\n      id: string;\n      oauthClientId?: string;\n    }\n  ): Promise<{\n    id: string;\n    authUrl: string | undefined;\n    clientId: string | undefined;\n  }> {\n    const authProvider = new DurableObjectOAuthClientProvider(\n      this.ctx.storage,\n      this.name,\n      callbackUrl\n    );\n\n    if (reconnect) {\n      authProvider.serverId = reconnect.id;\n      if (reconnect.oauthClientId) {\n        authProvider.clientId = reconnect.oauthClientId;\n      }\n    }\n\n    // Use the transport type specified in options, or default to \"auto\"\n    const transportType: TransportType = options?.transport?.type ?? \"auto\";\n\n    // allows passing through transport headers if necessary\n    // this handles some non-standard bearer auth setups (i.e. MCP server behind CF access instead of OAuth)\n    let headerTransportOpts: SSEClientTransportOptions = {};\n    if (options?.transport?.headers) {\n      headerTransportOpts = {\n        eventSourceInit: {\n          fetch: (url, init) =>\n            fetch(url, {\n              ...init,\n              headers: options?.transport?.headers\n            })\n        },\n        requestInit: {\n          headers: options?.transport?.headers\n        }\n      };\n    }\n\n    const { id, authUrl, clientId } = await this.mcp.connect(url, {\n      client: options?.client,\n      reconnect,\n      transport: {\n        ...headerTransportOpts,\n        authProvider,\n        type: transportType\n      }\n    });\n\n    return {\n      authUrl,\n      clientId,\n      id\n    };\n  }\n\n  async removeMcpServer(id: string) {\n    this.mcp.closeConnection(id);\n    this.mcp.unregisterCallbackUrl(id);\n    this.sql`\n      DELETE FROM cf_agents_mcp_servers WHERE id = ${id};\n    `;\n    this.broadcastMcpServers();\n  }\n\n  getMcpServers(): MCPServersState {\n    const mcpState: MCPServersState = {\n      prompts: this.mcp.listPrompts(),\n      resources: this.mcp.listResources(),\n      servers: {},\n      tools: this.mcp.listTools()\n    };\n\n    const servers = this.sql<MCPServerRow>`\n      SELECT id, name, server_url, client_id, auth_url, callback_url, server_options FROM cf_agents_mcp_servers;\n    `;\n\n    if (servers && Array.isArray(servers) && servers.length > 0) {\n      for (const server of servers) {\n        const serverConn = this.mcp.mcpConnections[server.id];\n        mcpState.servers[server.id] = {\n          auth_url: server.auth_url,\n          capabilities: serverConn?.serverCapabilities ?? null,\n          instructions: serverConn?.instructions ?? null,\n          name: server.name,\n          server_url: server.server_url,\n          // mark as \"authenticating\" because the server isn't automatically connected, so it's pending authenticating\n          state: serverConn?.connectionState ?? \"authenticating\"\n        };\n      }\n    }\n\n    return mcpState;\n  }\n\n  private broadcastMcpServers() {\n    this.broadcast(\n      JSON.stringify({\n        mcp: this.getMcpServers(),\n        type: MessageType.CF_AGENT_MCP_SERVERS\n      })\n    );\n  }\n\n  /**\n   * Handle OAuth callback response using MCPClientManager configuration\n   * @param result OAuth callback result\n   * @param request The original request (needed for base URL)\n   * @returns Response for the OAuth callback\n   */\n  private handleOAuthCallbackResponse(\n    result: MCPClientOAuthResult,\n    request: Request\n  ): Response {\n    const config = this.mcp.getOAuthCallbackConfig();\n\n    // Use custom handler if configured\n    if (config?.customHandler) {\n      return config.customHandler(result);\n    }\n\n    // Use redirect URLs if configured\n    if (config?.successRedirect && result.authSuccess) {\n      return Response.redirect(config.successRedirect);\n    }\n\n    if (config?.errorRedirect && !result.authSuccess) {\n      return Response.redirect(\n        `${config.errorRedirect}?error=${encodeURIComponent(result.authError || \"Unknown error\")}`\n      );\n    }\n\n    // Default behavior - redirect to base URL\n    const baseUrl = new URL(request.url).origin;\n    return Response.redirect(baseUrl);\n  }\n}\n\n// A set of classes that have been wrapped with agent context\nconst wrappedClasses = new Set<typeof Agent.prototype.constructor>();\n\n/**\n * Namespace for creating Agent instances\n * @template Agentic Type of the Agent class\n */\nexport type AgentNamespace<Agentic extends Agent<unknown>> =\n  DurableObjectNamespace<Agentic>;\n\n/**\n * Agent's durable context\n */\nexport type AgentContext = DurableObjectState;\n\n/**\n * Configuration options for Agent routing\n */\nexport type AgentOptions<Env> = PartyServerOptions<Env> & {\n  /**\n   * Whether to enable CORS for the Agent\n   */\n  cors?: boolean | HeadersInit | undefined;\n};\n\n/**\n * Route a request to the appropriate Agent\n * @param request Request to route\n * @param env Environment containing Agent bindings\n * @param options Routing options\n * @returns Response from the Agent or undefined if no route matched\n */\nexport async function routeAgentRequest<Env>(\n  request: Request,\n  env: Env,\n  options?: AgentOptions<Env>\n) {\n  const corsHeaders =\n    options?.cors === true\n      ? {\n          \"Access-Control-Allow-Credentials\": \"true\",\n          \"Access-Control-Allow-Methods\": \"GET, POST, HEAD, OPTIONS\",\n          \"Access-Control-Allow-Origin\": \"*\",\n          \"Access-Control-Max-Age\": \"86400\"\n        }\n      : options?.cors;\n\n  if (request.method === \"OPTIONS\") {\n    if (corsHeaders) {\n      return new Response(null, {\n        headers: corsHeaders\n      });\n    }\n    console.warn(\n      \"Received an OPTIONS request, but cors was not enabled. Pass `cors: true` or `cors: { ...custom cors headers }` to routeAgentRequest to enable CORS.\"\n    );\n  }\n\n  let response = await routePartykitRequest(\n    request,\n    env as Record<string, unknown>,\n    {\n      prefix: \"agents\",\n      ...(options as PartyServerOptions<Record<string, unknown>>)\n    }\n  );\n\n  if (\n    response &&\n    corsHeaders &&\n    request.headers.get(\"upgrade\")?.toLowerCase() !== \"websocket\" &&\n    request.headers.get(\"Upgrade\")?.toLowerCase() !== \"websocket\"\n  ) {\n    response = new Response(response.body, {\n      headers: {\n        ...response.headers,\n        ...corsHeaders\n      }\n    });\n  }\n  return response;\n}\n\nexport type EmailResolver<Env> = (\n  email: ForwardableEmailMessage,\n  env: Env\n) => Promise<{\n  agentName: string;\n  agentId: string;\n} | null>;\n\n/**\n * Create a resolver that uses the message-id header to determine the agent to route the email to\n * @returns A function that resolves the agent to route the email to\n */\nexport function createHeaderBasedEmailResolver<Env>(): EmailResolver<Env> {\n  return async (email: ForwardableEmailMessage, _env: Env) => {\n    const messageId = email.headers.get(\"message-id\");\n    if (messageId) {\n      const messageIdMatch = messageId.match(/<([^@]+)@([^>]+)>/);\n      if (messageIdMatch) {\n        const [, agentId, domain] = messageIdMatch;\n        const agentName = domain.split(\".\")[0];\n        return { agentName, agentId };\n      }\n    }\n\n    const references = email.headers.get(\"references\");\n    if (references) {\n      const referencesMatch = references.match(\n        /<([A-Za-z0-9+/]{43}=)@([^>]+)>/\n      );\n      if (referencesMatch) {\n        const [, base64Id, domain] = referencesMatch;\n        const agentId = Buffer.from(base64Id, \"base64\").toString(\"hex\");\n        const agentName = domain.split(\".\")[0];\n        return { agentName, agentId };\n      }\n    }\n\n    const agentName = email.headers.get(\"x-agent-name\");\n    const agentId = email.headers.get(\"x-agent-id\");\n    if (agentName && agentId) {\n      return { agentName, agentId };\n    }\n\n    return null;\n  };\n}\n\n/**\n * Create a resolver that uses the email address to determine the agent to route the email to\n * @param defaultAgentName The default agent name to use if the email address does not contain a sub-address\n * @returns A function that resolves the agent to route the email to\n */\nexport function createAddressBasedEmailResolver<Env>(\n  defaultAgentName: string\n): EmailResolver<Env> {\n  return async (email: ForwardableEmailMessage, _env: Env) => {\n    const emailMatch = email.to.match(/^([^+@]+)(?:\\+([^@]+))?@(.+)$/);\n    if (!emailMatch) {\n      return null;\n    }\n\n    const [, localPart, subAddress] = emailMatch;\n\n    if (subAddress) {\n      return {\n        agentName: localPart,\n        agentId: subAddress\n      };\n    }\n\n    // Option 2: Use defaultAgentName namespace, localPart as agentId\n    // Common for catch-all email routing to a single EmailAgent namespace\n    return {\n      agentName: defaultAgentName,\n      agentId: localPart\n    };\n  };\n}\n\n/**\n * Create a resolver that uses the agentName and agentId to determine the agent to route the email to\n * @param agentName The name of the agent to route the email to\n * @param agentId The id of the agent to route the email to\n * @returns A function that resolves the agent to route the email to\n */\nexport function createCatchAllEmailResolver<Env>(\n  agentName: string,\n  agentId: string\n): EmailResolver<Env> {\n  return async () => ({ agentName, agentId });\n}\n\nexport type EmailRoutingOptions<Env> = AgentOptions<Env> & {\n  resolver: EmailResolver<Env>;\n};\n\n// Cache the agent namespace map for email routing\n// This maps both kebab-case and original names to namespaces\nconst agentMapCache = new WeakMap<\n  Record<string, unknown>,\n  Record<string, unknown>\n>();\n\n/**\n * Route an email to the appropriate Agent\n * @param email The email to route\n * @param env The environment containing the Agent bindings\n * @param options The options for routing the email\n * @returns A promise that resolves when the email has been routed\n */\nexport async function routeAgentEmail<Env>(\n  email: ForwardableEmailMessage,\n  env: Env,\n  options: EmailRoutingOptions<Env>\n): Promise<void> {\n  const routingInfo = await options.resolver(email, env);\n\n  if (!routingInfo) {\n    console.warn(\"No routing information found for email, dropping message\");\n    return;\n  }\n\n  // Build a map that includes both original names and kebab-case versions\n  if (!agentMapCache.has(env as Record<string, unknown>)) {\n    const map: Record<string, unknown> = {};\n    for (const [key, value] of Object.entries(env as Record<string, unknown>)) {\n      if (\n        value &&\n        typeof value === \"object\" &&\n        \"idFromName\" in value &&\n        typeof value.idFromName === \"function\"\n      ) {\n        // Add both the original name and kebab-case version\n        map[key] = value;\n        map[camelCaseToKebabCase(key)] = value;\n      }\n    }\n    agentMapCache.set(env as Record<string, unknown>, map);\n  }\n\n  const agentMap = agentMapCache.get(env as Record<string, unknown>)!;\n  const namespace = agentMap[routingInfo.agentName];\n\n  if (!namespace) {\n    // Provide helpful error message listing available agents\n    const availableAgents = Object.keys(agentMap)\n      .filter((key) => !key.includes(\"-\")) // Show only original names, not kebab-case duplicates\n      .join(\", \");\n    throw new Error(\n      `Agent namespace '${routingInfo.agentName}' not found in environment. Available agents: ${availableAgents}`\n    );\n  }\n\n  const agent = await getAgentByName(\n    namespace as unknown as AgentNamespace<Agent<Env>>,\n    routingInfo.agentId\n  );\n\n  // let's make a serialisable version of the email\n  const serialisableEmail: AgentEmail = {\n    getRaw: async () => {\n      const reader = email.raw.getReader();\n      const chunks: Uint8Array[] = [];\n\n      let done = false;\n      while (!done) {\n        const { value, done: readerDone } = await reader.read();\n        done = readerDone;\n        if (value) {\n          chunks.push(value);\n        }\n      }\n\n      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);\n      const combined = new Uint8Array(totalLength);\n      let offset = 0;\n      for (const chunk of chunks) {\n        combined.set(chunk, offset);\n        offset += chunk.length;\n      }\n\n      return combined;\n    },\n    headers: email.headers,\n    rawSize: email.rawSize,\n    setReject: (reason: string) => {\n      email.setReject(reason);\n    },\n    forward: (rcptTo: string, headers?: Headers) => {\n      return email.forward(rcptTo, headers);\n    },\n    reply: (options: { from: string; to: string; raw: string }) => {\n      return email.reply(\n        new EmailMessage(options.from, options.to, options.raw)\n      );\n    },\n    from: email.from,\n    to: email.to\n  };\n\n  await agent._onEmail(serialisableEmail);\n}\n\nexport type AgentEmail = {\n  from: string;\n  to: string;\n  getRaw: () => Promise<Uint8Array>;\n  headers: Headers;\n  rawSize: number;\n  setReject: (reason: string) => void;\n  forward: (rcptTo: string, headers?: Headers) => Promise<void>;\n  reply: (options: { from: string; to: string; raw: string }) => Promise<void>;\n};\n\nexport type EmailSendOptions = {\n  to: string;\n  subject: string;\n  body: string;\n  contentType?: string;\n  headers?: Record<string, string>;\n  includeRoutingHeaders?: boolean;\n  agentName?: string;\n  agentId?: string;\n  domain?: string;\n};\n\n/**\n * Get or create an Agent by name\n * @template Env Environment type containing bindings\n * @template T Type of the Agent class\n * @param namespace Agent namespace\n * @param name Name of the Agent instance\n * @param options Options for Agent creation\n * @returns Promise resolving to an Agent instance stub\n */\nexport async function getAgentByName<\n  Env,\n  T extends Agent<Env>,\n  Props extends Record<string, unknown> = Record<string, unknown>\n>(\n  namespace: AgentNamespace<T>,\n  name: string,\n  options?: {\n    jurisdiction?: DurableObjectJurisdiction;\n    locationHint?: DurableObjectLocationHint;\n    props?: Props;\n  }\n) {\n  return getServerByName<Env, T>(namespace, name, options);\n}\n\n/**\n * A wrapper for streaming responses in callable methods\n */\nexport class StreamingResponse {\n  private _connection: Connection;\n  private _id: string;\n  private _closed = false;\n\n  constructor(connection: Connection, id: string) {\n    this._connection = connection;\n    this._id = id;\n  }\n\n  /**\n   * Send a chunk of data to the client\n   * @param chunk The data to send\n   */\n  send(chunk: unknown) {\n    if (this._closed) {\n      throw new Error(\"StreamingResponse is already closed\");\n    }\n    const response: RPCResponse = {\n      done: false,\n      id: this._id,\n      result: chunk,\n      success: true,\n      type: MessageType.RPC\n    };\n    this._connection.send(JSON.stringify(response));\n  }\n\n  /**\n   * End the stream and send the final chunk (if any)\n   * @param finalChunk Optional final chunk of data to send\n   */\n  end(finalChunk?: unknown) {\n    if (this._closed) {\n      throw new Error(\"StreamingResponse is already closed\");\n    }\n    this._closed = true;\n    const response: RPCResponse = {\n      done: true,\n      id: this._id,\n      result: finalChunk,\n      success: true,\n      type: MessageType.RPC\n    };\n    this._connection.send(JSON.stringify(response));\n  }\n}\n","import { getCurrentAgent } from \"../index\";\nimport type { AgentObservabilityEvent } from \"./agent\";\nimport type { MCPObservabilityEvent } from \"./mcp\";\n\n/**\n * Union of all observability event types from different domains\n */\nexport type ObservabilityEvent =\n  | AgentObservabilityEvent\n  | MCPObservabilityEvent;\n\nexport interface Observability {\n  /**\n   * Emit an event for the Agent's observability implementation to handle.\n   * @param event - The event to emit\n   * @param ctx - The execution context of the invocation (optional)\n   */\n  emit(event: ObservabilityEvent, ctx?: DurableObjectState): void;\n}\n\n/**\n * A generic observability implementation that logs events to the console.\n */\nexport const genericObservability: Observability = {\n  emit(event) {\n    // In local mode, we display a pretty-print version of the event for easier debugging.\n    if (isLocalMode()) {\n      console.log(event.displayMessage);\n      return;\n    }\n\n    console.log(event);\n  }\n};\n\nlet localMode = false;\n\nfunction isLocalMode() {\n  if (localMode) {\n    return true;\n  }\n  const { request } = getCurrentAgent();\n  if (!request) {\n    return false;\n  }\n\n  const url = new URL(request.url);\n  localMode = url.hostname === \"localhost\";\n  return localMode;\n}\n"],"mappings":"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","names":["ctx","proto","url","agentId","agentName","options"]}