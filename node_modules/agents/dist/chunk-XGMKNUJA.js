import {
  DisposableStore,
  MCPClientManager
} from "./chunk-ZMMHNOMZ.js";
import {
  DurableObjectOAuthClientProvider
} from "./chunk-C2OEBJZ2.js";
import {
  camelCaseToKebabCase
} from "./chunk-QEVM4BVL.js";

// src/index.ts
import { AsyncLocalStorage } from "async_hooks";
import { parseCronExpression } from "cron-schedule";
import { nanoid } from "nanoid";
import { EmailMessage } from "cloudflare:email";
import {
  Server,
  getServerByName,
  routePartykitRequest
} from "partyserver";
function isRPCRequest(msg) {
  return typeof msg === "object" && msg !== null && "type" in msg && msg.type === "rpc" /* RPC */ && "id" in msg && typeof msg.id === "string" && "method" in msg && typeof msg.method === "string" && "args" in msg && Array.isArray(msg.args);
}
function isStateUpdateMessage(msg) {
  return typeof msg === "object" && msg !== null && "type" in msg && msg.type === "cf_agent_state" /* CF_AGENT_STATE */ && "state" in msg;
}
var callableMetadata = /* @__PURE__ */ new Map();
function callable(metadata = {}) {
  return function callableDecorator(target, context) {
    if (!callableMetadata.has(target)) {
      callableMetadata.set(target, metadata);
    }
    return target;
  };
}
var didWarnAboutUnstableCallable = false;
var unstable_callable = (metadata = {}) => {
  if (!didWarnAboutUnstableCallable) {
    didWarnAboutUnstableCallable = true;
    console.warn(
      "unstable_callable is deprecated, use callable instead. unstable_callable will be removed in the next major version."
    );
  }
  callable(metadata);
};
function getNextCronTime(cron) {
  const interval = parseCronExpression(cron);
  return interval.getNextDate();
}
var STATE_ROW_ID = "cf_state_row_id";
var STATE_WAS_CHANGED = "cf_state_was_changed";
var DEFAULT_STATE = {};
var agentContext = new AsyncLocalStorage();
function getCurrentAgent() {
  const store = agentContext.getStore();
  if (!store) {
    return {
      agent: void 0,
      connection: void 0,
      request: void 0,
      email: void 0
    };
  }
  return store;
}
function withAgentContext(method) {
  return function(...args) {
    const { connection, request, email, agent } = getCurrentAgent();
    if (agent === this) {
      return method.apply(this, args);
    }
    return agentContext.run({ agent: this, connection, request, email }, () => {
      return method.apply(this, args);
    });
  };
}
var _Agent = class _Agent extends Server {
  constructor(ctx, env) {
    super(ctx, env);
    this._state = DEFAULT_STATE;
    this._disposables = new DisposableStore();
    this._ParentClass = Object.getPrototypeOf(this).constructor;
    this.mcp = new MCPClientManager(
      this._ParentClass.name,
      "0.0.1"
    );
    /**
     * Initial state for the Agent
     * Override to provide default state values
     */
    this.initialState = DEFAULT_STATE;
    /**
     * The observability implementation to use for the Agent
     */
    this.observability = genericObservability;
    this._flushingQueue = false;
    /**
     * Method called when an alarm fires.
     * Executes any scheduled tasks that are due.
     *
     * @remarks
     * To schedule a task, please use the `this.schedule` method instead.
     * See {@link https://developers.cloudflare.com/agents/api-reference/schedule-tasks/}
     */
    this.alarm = async () => {
      const now = Math.floor(Date.now() / 1e3);
      const result = this.sql`
      SELECT * FROM cf_agents_schedules WHERE time <= ${now}
    `;
      if (result && Array.isArray(result)) {
        for (const row of result) {
          const callback = this[row.callback];
          if (!callback) {
            console.error(`callback ${row.callback} not found`);
            continue;
          }
          await agentContext.run(
            {
              agent: this,
              connection: void 0,
              request: void 0,
              email: void 0
            },
            async () => {
              try {
                this.observability?.emit(
                  {
                    displayMessage: `Schedule ${row.id} executed`,
                    id: nanoid(),
                    payload: {
                      callback: row.callback,
                      id: row.id
                    },
                    timestamp: Date.now(),
                    type: "schedule:execute"
                  },
                  this.ctx
                );
                await callback.bind(this)(JSON.parse(row.payload), row);
              } catch (e) {
                console.error(`error executing callback "${row.callback}"`, e);
              }
            }
          );
          if (row.type === "cron") {
            const nextExecutionTime = getNextCronTime(row.cron);
            const nextTimestamp = Math.floor(nextExecutionTime.getTime() / 1e3);
            this.sql`
          UPDATE cf_agents_schedules SET time = ${nextTimestamp} WHERE id = ${row.id}
        `;
          } else {
            this.sql`
          DELETE FROM cf_agents_schedules WHERE id = ${row.id}
        `;
          }
        }
      }
      await this._scheduleNextAlarm();
    };
    if (!wrappedClasses.has(this.constructor)) {
      this._autoWrapCustomMethods();
      wrappedClasses.add(this.constructor);
    }
    this._disposables.add(
      this.mcp.onConnected(async () => {
        this.broadcastMcpServers();
      })
    );
    this._disposables.add(
      this.mcp.onObservabilityEvent((event) => {
        this.observability?.emit(event);
      })
    );
    this.sql`
      CREATE TABLE IF NOT EXISTS cf_agents_state (
        id TEXT PRIMARY KEY NOT NULL,
        state TEXT
      )
    `;
    this.sql`
      CREATE TABLE IF NOT EXISTS cf_agents_queues (
        id TEXT PRIMARY KEY NOT NULL,
        payload TEXT,
        callback TEXT,
        created_at INTEGER DEFAULT (unixepoch())
      )
    `;
    void this.ctx.blockConcurrencyWhile(async () => {
      return this._tryCatch(async () => {
        this.sql`
        CREATE TABLE IF NOT EXISTS cf_agents_schedules (
          id TEXT PRIMARY KEY NOT NULL DEFAULT (randomblob(9)),
          callback TEXT,
          payload TEXT,
          type TEXT NOT NULL CHECK(type IN ('scheduled', 'delayed', 'cron')),
          time INTEGER,
          delayInSeconds INTEGER,
          cron TEXT,
          created_at INTEGER DEFAULT (unixepoch())
        )
      `;
        await this.alarm();
      });
    });
    this.sql`
      CREATE TABLE IF NOT EXISTS cf_agents_mcp_servers (
        id TEXT PRIMARY KEY NOT NULL,
        name TEXT NOT NULL,
        server_url TEXT NOT NULL,
        callback_url TEXT NOT NULL,
        client_id TEXT,
        auth_url TEXT,
        server_options TEXT
      )
    `;
    const _onRequest = this.onRequest.bind(this);
    this.onRequest = (request) => {
      return agentContext.run(
        { agent: this, connection: void 0, request, email: void 0 },
        async () => {
          if (this.mcp.isCallbackRequest(request)) {
            const result = await this.mcp.handleCallbackRequest(request);
            this.broadcastMcpServers();
            if (result.authSuccess) {
              this.mcp.establishConnection(result.serverId).catch((error) => {
                console.error("Background connection failed:", error);
              }).finally(() => {
                this.broadcastMcpServers();
              });
            }
            return this.handleOAuthCallbackResponse(result, request);
          }
          return this._tryCatch(() => _onRequest(request));
        }
      );
    };
    const _onMessage = this.onMessage.bind(this);
    this.onMessage = async (connection, message) => {
      return agentContext.run(
        { agent: this, connection, request: void 0, email: void 0 },
        async () => {
          if (typeof message !== "string") {
            return this._tryCatch(() => _onMessage(connection, message));
          }
          let parsed;
          try {
            parsed = JSON.parse(message);
          } catch (_e) {
            return this._tryCatch(() => _onMessage(connection, message));
          }
          if (isStateUpdateMessage(parsed)) {
            this._setStateInternal(parsed.state, connection);
            return;
          }
          if (isRPCRequest(parsed)) {
            try {
              const { id, method, args } = parsed;
              const methodFn = this[method];
              if (typeof methodFn !== "function") {
                throw new Error(`Method ${method} does not exist`);
              }
              if (!this._isCallable(method)) {
                throw new Error(`Method ${method} is not callable`);
              }
              const metadata = callableMetadata.get(methodFn);
              if (metadata?.streaming) {
                const stream = new StreamingResponse(connection, id);
                await methodFn.apply(this, [stream, ...args]);
                return;
              }
              const result = await methodFn.apply(this, args);
              this.observability?.emit(
                {
                  displayMessage: `RPC call to ${method}`,
                  id: nanoid(),
                  payload: {
                    method,
                    streaming: metadata?.streaming
                  },
                  timestamp: Date.now(),
                  type: "rpc"
                },
                this.ctx
              );
              const response = {
                done: true,
                id,
                result,
                success: true,
                type: "rpc" /* RPC */
              };
              connection.send(JSON.stringify(response));
            } catch (e) {
              const response = {
                error: e instanceof Error ? e.message : "Unknown error occurred",
                id: parsed.id,
                success: false,
                type: "rpc" /* RPC */
              };
              connection.send(JSON.stringify(response));
              console.error("RPC error:", e);
            }
            return;
          }
          return this._tryCatch(() => _onMessage(connection, message));
        }
      );
    };
    const _onConnect = this.onConnect.bind(this);
    this.onConnect = (connection, ctx2) => {
      return agentContext.run(
        { agent: this, connection, request: ctx2.request, email: void 0 },
        () => {
          if (this.state) {
            connection.send(
              JSON.stringify({
                state: this.state,
                type: "cf_agent_state" /* CF_AGENT_STATE */
              })
            );
          }
          connection.send(
            JSON.stringify({
              mcp: this.getMcpServers(),
              type: "cf_agent_mcp_servers" /* CF_AGENT_MCP_SERVERS */
            })
          );
          this.observability?.emit(
            {
              displayMessage: "Connection established",
              id: nanoid(),
              payload: {
                connectionId: connection.id
              },
              timestamp: Date.now(),
              type: "connect"
            },
            this.ctx
          );
          return this._tryCatch(() => _onConnect(connection, ctx2));
        }
      );
    };
    const _onStart = this.onStart.bind(this);
    this.onStart = async (props) => {
      return agentContext.run(
        {
          agent: this,
          connection: void 0,
          request: void 0,
          email: void 0
        },
        async () => {
          await this._tryCatch(() => {
            const servers = this.sql`
            SELECT id, name, server_url, client_id, auth_url, callback_url, server_options FROM cf_agents_mcp_servers;
          `;
            this.broadcastMcpServers();
            if (servers && Array.isArray(servers) && servers.length > 0) {
              servers.forEach((server) => {
                if (server.callback_url) {
                  this.mcp.registerCallbackUrl(
                    `${server.callback_url}/${server.id}`
                  );
                }
              });
              servers.forEach((server) => {
                this._connectToMcpServerInternal(
                  server.name,
                  server.server_url,
                  server.callback_url,
                  server.server_options ? JSON.parse(server.server_options) : void 0,
                  {
                    id: server.id,
                    oauthClientId: server.client_id ?? void 0
                  }
                ).then(() => {
                  this.broadcastMcpServers();
                }).catch((error) => {
                  console.error(
                    `Error connecting to MCP server: ${server.name} (${server.server_url})`,
                    error
                  );
                  this.broadcastMcpServers();
                });
              });
            }
            return _onStart(props);
          });
        }
      );
    };
  }
  /**
   * Current state of the Agent
   */
  get state() {
    if (this._state !== DEFAULT_STATE) {
      return this._state;
    }
    const wasChanged = this.sql`
        SELECT state FROM cf_agents_state WHERE id = ${STATE_WAS_CHANGED}
      `;
    const result = this.sql`
      SELECT state FROM cf_agents_state WHERE id = ${STATE_ROW_ID}
    `;
    if (wasChanged[0]?.state === "true" || // we do this check for people who updated their code before we shipped wasChanged
    result[0]?.state) {
      const state = result[0]?.state;
      this._state = JSON.parse(state);
      return this._state;
    }
    if (this.initialState === DEFAULT_STATE) {
      return void 0;
    }
    this.setState(this.initialState);
    return this.initialState;
  }
  /**
   * Execute SQL queries against the Agent's database
   * @template T Type of the returned rows
   * @param strings SQL query template strings
   * @param values Values to be inserted into the query
   * @returns Array of query results
   */
  sql(strings, ...values) {
    let query = "";
    try {
      query = strings.reduce(
        (acc, str, i) => acc + str + (i < values.length ? "?" : ""),
        ""
      );
      return [...this.ctx.storage.sql.exec(query, ...values)];
    } catch (e) {
      console.error(`failed to execute sql query: ${query}`, e);
      throw this.onError(e);
    }
  }
  _setStateInternal(state, source = "server") {
    this._state = state;
    this.sql`
    INSERT OR REPLACE INTO cf_agents_state (id, state)
    VALUES (${STATE_ROW_ID}, ${JSON.stringify(state)})
  `;
    this.sql`
    INSERT OR REPLACE INTO cf_agents_state (id, state)
    VALUES (${STATE_WAS_CHANGED}, ${JSON.stringify(true)})
  `;
    this.broadcast(
      JSON.stringify({
        state,
        type: "cf_agent_state" /* CF_AGENT_STATE */
      }),
      source !== "server" ? [source.id] : []
    );
    return this._tryCatch(() => {
      const { connection, request, email } = agentContext.getStore() || {};
      return agentContext.run(
        { agent: this, connection, request, email },
        async () => {
          this.observability?.emit(
            {
              displayMessage: "State updated",
              id: nanoid(),
              payload: {},
              timestamp: Date.now(),
              type: "state:update"
            },
            this.ctx
          );
          return this.onStateUpdate(state, source);
        }
      );
    });
  }
  /**
   * Update the Agent's state
   * @param state New state to set
   */
  setState(state) {
    this._setStateInternal(state, "server");
  }
  /**
   * Called when the Agent's state is updated
   * @param state Updated state
   * @param source Source of the state update ("server" or a client connection)
   */
  // biome-ignore lint/correctness/noUnusedFunctionParameters: overridden later
  onStateUpdate(state, source) {
  }
  /**
   * Called when the Agent receives an email via routeAgentEmail()
   * Override this method to handle incoming emails
   * @param email Email message to process
   */
  async _onEmail(email) {
    return agentContext.run(
      { agent: this, connection: void 0, request: void 0, email },
      async () => {
        if ("onEmail" in this && typeof this.onEmail === "function") {
          return this._tryCatch(
            () => this.onEmail(email)
          );
        } else {
          console.log("Received email from:", email.from, "to:", email.to);
          console.log("Subject:", email.headers.get("subject"));
          console.log(
            "Implement onEmail(email: AgentEmail): Promise<void> in your agent to process emails"
          );
        }
      }
    );
  }
  /**
   * Reply to an email
   * @param email The email to reply to
   * @param options Options for the reply
   * @returns void
   */
  async replyToEmail(email, options) {
    return this._tryCatch(async () => {
      const agentName = camelCaseToKebabCase(this._ParentClass.name);
      const agentId = this.name;
      const { createMimeMessage } = await import("mimetext");
      const msg = createMimeMessage();
      msg.setSender({ addr: email.to, name: options.fromName });
      msg.setRecipient(email.from);
      msg.setSubject(
        options.subject || `Re: ${email.headers.get("subject")}` || "No subject"
      );
      msg.addMessage({
        contentType: options.contentType || "text/plain",
        data: options.body
      });
      const domain = email.from.split("@")[1];
      const messageId = `<${agentId}@${domain}>`;
      msg.setHeader("In-Reply-To", email.headers.get("Message-ID"));
      msg.setHeader("Message-ID", messageId);
      msg.setHeader("X-Agent-Name", agentName);
      msg.setHeader("X-Agent-ID", agentId);
      if (options.headers) {
        for (const [key, value] of Object.entries(options.headers)) {
          msg.setHeader(key, value);
        }
      }
      await email.reply({
        from: email.to,
        raw: msg.asRaw(),
        to: email.from
      });
    });
  }
  async _tryCatch(fn) {
    try {
      return await fn();
    } catch (e) {
      throw this.onError(e);
    }
  }
  /**
   * Automatically wrap custom methods with agent context
   * This ensures getCurrentAgent() works in all custom methods without decorators
   */
  _autoWrapCustomMethods() {
    const basePrototypes = [_Agent.prototype, Server.prototype];
    const baseMethods = /* @__PURE__ */ new Set();
    for (const baseProto of basePrototypes) {
      let proto2 = baseProto;
      while (proto2 && proto2 !== Object.prototype) {
        const methodNames = Object.getOwnPropertyNames(proto2);
        for (const methodName of methodNames) {
          baseMethods.add(methodName);
        }
        proto2 = Object.getPrototypeOf(proto2);
      }
    }
    let proto = Object.getPrototypeOf(this);
    let depth = 0;
    while (proto && proto !== Object.prototype && depth < 10) {
      const methodNames = Object.getOwnPropertyNames(proto);
      for (const methodName of methodNames) {
        const descriptor = Object.getOwnPropertyDescriptor(proto, methodName);
        if (baseMethods.has(methodName) || methodName.startsWith("_") || !descriptor || !!descriptor.get || typeof descriptor.value !== "function") {
          continue;
        }
        const wrappedFunction = withAgentContext(
          // biome-ignore lint/suspicious/noExplicitAny: I can't typescript
          this[methodName]
          // biome-ignore lint/suspicious/noExplicitAny: I can't typescript
        );
        if (this._isCallable(methodName)) {
          callableMetadata.set(
            wrappedFunction,
            callableMetadata.get(this[methodName])
          );
        }
        this.constructor.prototype[methodName] = wrappedFunction;
      }
      proto = Object.getPrototypeOf(proto);
      depth++;
    }
  }
  onError(connectionOrError, error) {
    let theError;
    if (connectionOrError && error) {
      theError = error;
      console.error(
        "Error on websocket connection:",
        connectionOrError.id,
        theError
      );
      console.error(
        "Override onError(connection, error) to handle websocket connection errors"
      );
    } else {
      theError = connectionOrError;
      console.error("Error on server:", theError);
      console.error("Override onError(error) to handle server errors");
    }
    throw theError;
  }
  /**
   * Render content (not implemented in base class)
   */
  render() {
    throw new Error("Not implemented");
  }
  /**
   * Queue a task to be executed in the future
   * @param payload Payload to pass to the callback
   * @param callback Name of the method to call
   * @returns The ID of the queued task
   */
  async queue(callback, payload) {
    const id = nanoid(9);
    if (typeof callback !== "string") {
      throw new Error("Callback must be a string");
    }
    if (typeof this[callback] !== "function") {
      throw new Error(`this.${callback} is not a function`);
    }
    this.sql`
      INSERT OR REPLACE INTO cf_agents_queues (id, payload, callback)
      VALUES (${id}, ${JSON.stringify(payload)}, ${callback})
    `;
    void this._flushQueue().catch((e) => {
      console.error("Error flushing queue:", e);
    });
    return id;
  }
  async _flushQueue() {
    if (this._flushingQueue) {
      return;
    }
    this._flushingQueue = true;
    while (true) {
      const result = this.sql`
      SELECT * FROM cf_agents_queues
      ORDER BY created_at ASC
    `;
      if (!result || result.length === 0) {
        break;
      }
      for (const row of result || []) {
        const callback = this[row.callback];
        if (!callback) {
          console.error(`callback ${row.callback} not found`);
          continue;
        }
        const { connection, request, email } = agentContext.getStore() || {};
        await agentContext.run(
          {
            agent: this,
            connection,
            request,
            email
          },
          async () => {
            await callback.bind(this)(JSON.parse(row.payload), row);
            await this.dequeue(row.id);
          }
        );
      }
    }
    this._flushingQueue = false;
  }
  /**
   * Dequeue a task by ID
   * @param id ID of the task to dequeue
   */
  async dequeue(id) {
    this.sql`DELETE FROM cf_agents_queues WHERE id = ${id}`;
  }
  /**
   * Dequeue all tasks
   */
  async dequeueAll() {
    this.sql`DELETE FROM cf_agents_queues`;
  }
  /**
   * Dequeue all tasks by callback
   * @param callback Name of the callback to dequeue
   */
  async dequeueAllByCallback(callback) {
    this.sql`DELETE FROM cf_agents_queues WHERE callback = ${callback}`;
  }
  /**
   * Get a queued task by ID
   * @param id ID of the task to get
   * @returns The task or undefined if not found
   */
  async getQueue(id) {
    const result = this.sql`
      SELECT * FROM cf_agents_queues WHERE id = ${id}
    `;
    return result ? { ...result[0], payload: JSON.parse(result[0].payload) } : void 0;
  }
  /**
   * Get all queues by key and value
   * @param key Key to filter by
   * @param value Value to filter by
   * @returns Array of matching QueueItem objects
   */
  async getQueues(key, value) {
    const result = this.sql`
      SELECT * FROM cf_agents_queues
    `;
    return result.filter((row) => JSON.parse(row.payload)[key] === value);
  }
  /**
   * Schedule a task to be executed in the future
   * @template T Type of the payload data
   * @param when When to execute the task (Date, seconds delay, or cron expression)
   * @param callback Name of the method to call
   * @param payload Data to pass to the callback
   * @returns Schedule object representing the scheduled task
   */
  async schedule(when, callback, payload) {
    const id = nanoid(9);
    const emitScheduleCreate = (schedule) => this.observability?.emit(
      {
        displayMessage: `Schedule ${schedule.id} created`,
        id: nanoid(),
        payload: {
          callback,
          id
        },
        timestamp: Date.now(),
        type: "schedule:create"
      },
      this.ctx
    );
    if (typeof callback !== "string") {
      throw new Error("Callback must be a string");
    }
    if (typeof this[callback] !== "function") {
      throw new Error(`this.${callback} is not a function`);
    }
    if (when instanceof Date) {
      const timestamp = Math.floor(when.getTime() / 1e3);
      this.sql`
        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, time)
        VALUES (${id}, ${callback}, ${JSON.stringify(
        payload
      )}, 'scheduled', ${timestamp})
      `;
      await this._scheduleNextAlarm();
      const schedule = {
        callback,
        id,
        payload,
        time: timestamp,
        type: "scheduled"
      };
      emitScheduleCreate(schedule);
      return schedule;
    }
    if (typeof when === "number") {
      const time = new Date(Date.now() + when * 1e3);
      const timestamp = Math.floor(time.getTime() / 1e3);
      this.sql`
        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, delayInSeconds, time)
        VALUES (${id}, ${callback}, ${JSON.stringify(
        payload
      )}, 'delayed', ${when}, ${timestamp})
      `;
      await this._scheduleNextAlarm();
      const schedule = {
        callback,
        delayInSeconds: when,
        id,
        payload,
        time: timestamp,
        type: "delayed"
      };
      emitScheduleCreate(schedule);
      return schedule;
    }
    if (typeof when === "string") {
      const nextExecutionTime = getNextCronTime(when);
      const timestamp = Math.floor(nextExecutionTime.getTime() / 1e3);
      this.sql`
        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, cron, time)
        VALUES (${id}, ${callback}, ${JSON.stringify(
        payload
      )}, 'cron', ${when}, ${timestamp})
      `;
      await this._scheduleNextAlarm();
      const schedule = {
        callback,
        cron: when,
        id,
        payload,
        time: timestamp,
        type: "cron"
      };
      emitScheduleCreate(schedule);
      return schedule;
    }
    throw new Error("Invalid schedule type");
  }
  /**
   * Get a scheduled task by ID
   * @template T Type of the payload data
   * @param id ID of the scheduled task
   * @returns The Schedule object or undefined if not found
   */
  async getSchedule(id) {
    const result = this.sql`
      SELECT * FROM cf_agents_schedules WHERE id = ${id}
    `;
    if (!result) {
      console.error(`schedule ${id} not found`);
      return void 0;
    }
    return { ...result[0], payload: JSON.parse(result[0].payload) };
  }
  /**
   * Get scheduled tasks matching the given criteria
   * @template T Type of the payload data
   * @param criteria Criteria to filter schedules
   * @returns Array of matching Schedule objects
   */
  getSchedules(criteria = {}) {
    let query = "SELECT * FROM cf_agents_schedules WHERE 1=1";
    const params = [];
    if (criteria.id) {
      query += " AND id = ?";
      params.push(criteria.id);
    }
    if (criteria.type) {
      query += " AND type = ?";
      params.push(criteria.type);
    }
    if (criteria.timeRange) {
      query += " AND time >= ? AND time <= ?";
      const start = criteria.timeRange.start || /* @__PURE__ */ new Date(0);
      const end = criteria.timeRange.end || /* @__PURE__ */ new Date(999999999999999);
      params.push(
        Math.floor(start.getTime() / 1e3),
        Math.floor(end.getTime() / 1e3)
      );
    }
    const result = this.ctx.storage.sql.exec(query, ...params).toArray().map((row) => ({
      ...row,
      payload: JSON.parse(row.payload)
    }));
    return result;
  }
  /**
   * Cancel a scheduled task
   * @param id ID of the task to cancel
   * @returns true if the task was cancelled, false otherwise
   */
  async cancelSchedule(id) {
    const schedule = await this.getSchedule(id);
    if (schedule) {
      this.observability?.emit(
        {
          displayMessage: `Schedule ${id} cancelled`,
          id: nanoid(),
          payload: {
            callback: schedule.callback,
            id: schedule.id
          },
          timestamp: Date.now(),
          type: "schedule:cancel"
        },
        this.ctx
      );
    }
    this.sql`DELETE FROM cf_agents_schedules WHERE id = ${id}`;
    await this._scheduleNextAlarm();
    return true;
  }
  async _scheduleNextAlarm() {
    const result = this.sql`
      SELECT time FROM cf_agents_schedules
      WHERE time > ${Math.floor(Date.now() / 1e3)}
      ORDER BY time ASC
      LIMIT 1
    `;
    if (!result) return;
    if (result.length > 0 && "time" in result[0]) {
      const nextTime = result[0].time * 1e3;
      await this.ctx.storage.setAlarm(nextTime);
    }
  }
  /**
   * Destroy the Agent, removing all state and scheduled tasks
   */
  async destroy() {
    this.sql`DROP TABLE IF EXISTS cf_agents_state`;
    this.sql`DROP TABLE IF EXISTS cf_agents_schedules`;
    this.sql`DROP TABLE IF EXISTS cf_agents_mcp_servers`;
    this.sql`DROP TABLE IF EXISTS cf_agents_queues`;
    await this.ctx.storage.deleteAlarm();
    await this.ctx.storage.deleteAll();
    this._disposables.dispose();
    await this.mcp.dispose?.();
    this.ctx.abort("destroyed");
    this.observability?.emit(
      {
        displayMessage: "Agent destroyed",
        id: nanoid(),
        payload: {},
        timestamp: Date.now(),
        type: "destroy"
      },
      this.ctx
    );
  }
  /**
   * Get all methods marked as callable on this Agent
   * @returns A map of method names to their metadata
   */
  _isCallable(method) {
    return callableMetadata.has(this[method]);
  }
  /**
   * Connect to a new MCP Server
   *
   * @param serverName Name of the MCP server
   * @param url MCP Server SSE URL
   * @param callbackHost Base host for the agent, used for the redirect URI. If not provided, will be derived from the current request.
   * @param agentsPrefix agents routing prefix if not using `agents`
   * @param options MCP client and transport options
   * @returns authUrl
   */
  async addMcpServer(serverName, url, callbackHost, agentsPrefix = "agents", options) {
    let resolvedCallbackHost = callbackHost;
    if (!resolvedCallbackHost) {
      const { request } = getCurrentAgent();
      if (!request) {
        throw new Error(
          "callbackHost is required when not called within a request context"
        );
      }
      const requestUrl = new URL(request.url);
      resolvedCallbackHost = `${requestUrl.protocol}//${requestUrl.host}`;
    }
    const callbackUrl = `${resolvedCallbackHost}/${agentsPrefix}/${camelCaseToKebabCase(this._ParentClass.name)}/${this.name}/callback`;
    const result = await this._connectToMcpServerInternal(
      serverName,
      url,
      callbackUrl,
      options
    );
    this.sql`
        INSERT
        OR REPLACE INTO cf_agents_mcp_servers (id, name, server_url, client_id, auth_url, callback_url, server_options)
      VALUES (
        ${result.id},
        ${serverName},
        ${url},
        ${result.clientId ?? null},
        ${result.authUrl ?? null},
        ${callbackUrl},
        ${options ? JSON.stringify(options) : null}
        );
    `;
    this.broadcastMcpServers();
    return result;
  }
  async _connectToMcpServerInternal(_serverName, url, callbackUrl, options, reconnect) {
    const authProvider = new DurableObjectOAuthClientProvider(
      this.ctx.storage,
      this.name,
      callbackUrl
    );
    if (reconnect) {
      authProvider.serverId = reconnect.id;
      if (reconnect.oauthClientId) {
        authProvider.clientId = reconnect.oauthClientId;
      }
    }
    const transportType = options?.transport?.type ?? "auto";
    let headerTransportOpts = {};
    if (options?.transport?.headers) {
      headerTransportOpts = {
        eventSourceInit: {
          fetch: (url2, init) => fetch(url2, {
            ...init,
            headers: options?.transport?.headers
          })
        },
        requestInit: {
          headers: options?.transport?.headers
        }
      };
    }
    const { id, authUrl, clientId } = await this.mcp.connect(url, {
      client: options?.client,
      reconnect,
      transport: {
        ...headerTransportOpts,
        authProvider,
        type: transportType
      }
    });
    return {
      authUrl,
      clientId,
      id
    };
  }
  async removeMcpServer(id) {
    this.mcp.closeConnection(id);
    this.mcp.unregisterCallbackUrl(id);
    this.sql`
      DELETE FROM cf_agents_mcp_servers WHERE id = ${id};
    `;
    this.broadcastMcpServers();
  }
  getMcpServers() {
    const mcpState = {
      prompts: this.mcp.listPrompts(),
      resources: this.mcp.listResources(),
      servers: {},
      tools: this.mcp.listTools()
    };
    const servers = this.sql`
      SELECT id, name, server_url, client_id, auth_url, callback_url, server_options FROM cf_agents_mcp_servers;
    `;
    if (servers && Array.isArray(servers) && servers.length > 0) {
      for (const server of servers) {
        const serverConn = this.mcp.mcpConnections[server.id];
        mcpState.servers[server.id] = {
          auth_url: server.auth_url,
          capabilities: serverConn?.serverCapabilities ?? null,
          instructions: serverConn?.instructions ?? null,
          name: server.name,
          server_url: server.server_url,
          // mark as "authenticating" because the server isn't automatically connected, so it's pending authenticating
          state: serverConn?.connectionState ?? "authenticating"
        };
      }
    }
    return mcpState;
  }
  broadcastMcpServers() {
    this.broadcast(
      JSON.stringify({
        mcp: this.getMcpServers(),
        type: "cf_agent_mcp_servers" /* CF_AGENT_MCP_SERVERS */
      })
    );
  }
  /**
   * Handle OAuth callback response using MCPClientManager configuration
   * @param result OAuth callback result
   * @param request The original request (needed for base URL)
   * @returns Response for the OAuth callback
   */
  handleOAuthCallbackResponse(result, request) {
    const config = this.mcp.getOAuthCallbackConfig();
    if (config?.customHandler) {
      return config.customHandler(result);
    }
    if (config?.successRedirect && result.authSuccess) {
      return Response.redirect(config.successRedirect);
    }
    if (config?.errorRedirect && !result.authSuccess) {
      return Response.redirect(
        `${config.errorRedirect}?error=${encodeURIComponent(result.authError || "Unknown error")}`
      );
    }
    const baseUrl = new URL(request.url).origin;
    return Response.redirect(baseUrl);
  }
};
/**
 * Agent configuration options
 */
_Agent.options = {
  /** Whether the Agent should hibernate when inactive */
  hibernate: true
  // default to hibernate
};
var Agent = _Agent;
var wrappedClasses = /* @__PURE__ */ new Set();
async function routeAgentRequest(request, env, options) {
  const corsHeaders = options?.cors === true ? {
    "Access-Control-Allow-Credentials": "true",
    "Access-Control-Allow-Methods": "GET, POST, HEAD, OPTIONS",
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Max-Age": "86400"
  } : options?.cors;
  if (request.method === "OPTIONS") {
    if (corsHeaders) {
      return new Response(null, {
        headers: corsHeaders
      });
    }
    console.warn(
      "Received an OPTIONS request, but cors was not enabled. Pass `cors: true` or `cors: { ...custom cors headers }` to routeAgentRequest to enable CORS."
    );
  }
  let response = await routePartykitRequest(
    request,
    env,
    {
      prefix: "agents",
      ...options
    }
  );
  if (response && corsHeaders && request.headers.get("upgrade")?.toLowerCase() !== "websocket" && request.headers.get("Upgrade")?.toLowerCase() !== "websocket") {
    response = new Response(response.body, {
      headers: {
        ...response.headers,
        ...corsHeaders
      }
    });
  }
  return response;
}
function createHeaderBasedEmailResolver() {
  return async (email, _env) => {
    const messageId = email.headers.get("message-id");
    if (messageId) {
      const messageIdMatch = messageId.match(/<([^@]+)@([^>]+)>/);
      if (messageIdMatch) {
        const [, agentId2, domain] = messageIdMatch;
        const agentName2 = domain.split(".")[0];
        return { agentName: agentName2, agentId: agentId2 };
      }
    }
    const references = email.headers.get("references");
    if (references) {
      const referencesMatch = references.match(
        /<([A-Za-z0-9+/]{43}=)@([^>]+)>/
      );
      if (referencesMatch) {
        const [, base64Id, domain] = referencesMatch;
        const agentId2 = Buffer.from(base64Id, "base64").toString("hex");
        const agentName2 = domain.split(".")[0];
        return { agentName: agentName2, agentId: agentId2 };
      }
    }
    const agentName = email.headers.get("x-agent-name");
    const agentId = email.headers.get("x-agent-id");
    if (agentName && agentId) {
      return { agentName, agentId };
    }
    return null;
  };
}
function createAddressBasedEmailResolver(defaultAgentName) {
  return async (email, _env) => {
    const emailMatch = email.to.match(/^([^+@]+)(?:\+([^@]+))?@(.+)$/);
    if (!emailMatch) {
      return null;
    }
    const [, localPart, subAddress] = emailMatch;
    if (subAddress) {
      return {
        agentName: localPart,
        agentId: subAddress
      };
    }
    return {
      agentName: defaultAgentName,
      agentId: localPart
    };
  };
}
function createCatchAllEmailResolver(agentName, agentId) {
  return async () => ({ agentName, agentId });
}
var agentMapCache = /* @__PURE__ */ new WeakMap();
async function routeAgentEmail(email, env, options) {
  const routingInfo = await options.resolver(email, env);
  if (!routingInfo) {
    console.warn("No routing information found for email, dropping message");
    return;
  }
  if (!agentMapCache.has(env)) {
    const map = {};
    for (const [key, value] of Object.entries(env)) {
      if (value && typeof value === "object" && "idFromName" in value && typeof value.idFromName === "function") {
        map[key] = value;
        map[camelCaseToKebabCase(key)] = value;
      }
    }
    agentMapCache.set(env, map);
  }
  const agentMap = agentMapCache.get(env);
  const namespace = agentMap[routingInfo.agentName];
  if (!namespace) {
    const availableAgents = Object.keys(agentMap).filter((key) => !key.includes("-")).join(", ");
    throw new Error(
      `Agent namespace '${routingInfo.agentName}' not found in environment. Available agents: ${availableAgents}`
    );
  }
  const agent = await getAgentByName(
    namespace,
    routingInfo.agentId
  );
  const serialisableEmail = {
    getRaw: async () => {
      const reader = email.raw.getReader();
      const chunks = [];
      let done = false;
      while (!done) {
        const { value, done: readerDone } = await reader.read();
        done = readerDone;
        if (value) {
          chunks.push(value);
        }
      }
      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
      const combined = new Uint8Array(totalLength);
      let offset = 0;
      for (const chunk of chunks) {
        combined.set(chunk, offset);
        offset += chunk.length;
      }
      return combined;
    },
    headers: email.headers,
    rawSize: email.rawSize,
    setReject: (reason) => {
      email.setReject(reason);
    },
    forward: (rcptTo, headers) => {
      return email.forward(rcptTo, headers);
    },
    reply: (options2) => {
      return email.reply(
        new EmailMessage(options2.from, options2.to, options2.raw)
      );
    },
    from: email.from,
    to: email.to
  };
  await agent._onEmail(serialisableEmail);
}
async function getAgentByName(namespace, name, options) {
  return getServerByName(namespace, name, options);
}
var StreamingResponse = class {
  constructor(connection, id) {
    this._closed = false;
    this._connection = connection;
    this._id = id;
  }
  /**
   * Send a chunk of data to the client
   * @param chunk The data to send
   */
  send(chunk) {
    if (this._closed) {
      throw new Error("StreamingResponse is already closed");
    }
    const response = {
      done: false,
      id: this._id,
      result: chunk,
      success: true,
      type: "rpc" /* RPC */
    };
    this._connection.send(JSON.stringify(response));
  }
  /**
   * End the stream and send the final chunk (if any)
   * @param finalChunk Optional final chunk of data to send
   */
  end(finalChunk) {
    if (this._closed) {
      throw new Error("StreamingResponse is already closed");
    }
    this._closed = true;
    const response = {
      done: true,
      id: this._id,
      result: finalChunk,
      success: true,
      type: "rpc" /* RPC */
    };
    this._connection.send(JSON.stringify(response));
  }
};

// src/observability/index.ts
var genericObservability = {
  emit(event) {
    if (isLocalMode()) {
      console.log(event.displayMessage);
      return;
    }
    console.log(event);
  }
};
var localMode = false;
function isLocalMode() {
  if (localMode) {
    return true;
  }
  const { request } = getCurrentAgent();
  if (!request) {
    return false;
  }
  const url = new URL(request.url);
  localMode = url.hostname === "localhost";
  return localMode;
}

export {
  genericObservability,
  callable,
  unstable_callable,
  getCurrentAgent,
  Agent,
  routeAgentRequest,
  createHeaderBasedEmailResolver,
  createAddressBasedEmailResolver,
  createCatchAllEmailResolver,
  routeAgentEmail,
  getAgentByName,
  StreamingResponse
};
//# sourceMappingURL=chunk-XGMKNUJA.js.map