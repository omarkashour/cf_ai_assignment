{"version":3,"sources":["../src/ai-chat-agent.ts"],"sourcesContent":["import {\n  getToolName,\n  isToolUIPart,\n  parsePartialJson,\n  type UIMessage as ChatMessage,\n  type DynamicToolUIPart,\n  type ProviderMetadata,\n  type ReasoningUIPart,\n  type StreamTextOnFinishCallback,\n  type TextUIPart,\n  type ToolSet,\n  type ToolUIPart,\n  type UIMessageChunk\n} from \"ai\";\nimport { Agent, type AgentContext, type Connection, type WSMessage } from \"./\";\nimport {\n  MessageType,\n  type IncomingMessage,\n  type OutgoingMessage\n} from \"./ai-types\";\nimport { autoTransformMessages } from \"./ai-chat-v5-migration\";\n\nconst decoder = new TextDecoder();\n\n/**\n * Extension of Agent with built-in chat capabilities\n * @template Env Environment type containing bindings\n */\nexport class AIChatAgent<Env = unknown, State = unknown> extends Agent<\n  Env,\n  State\n> {\n  /**\n   * Map of message `id`s to `AbortController`s\n   * useful to propagate request cancellation signals for any external calls made by the agent\n   */\n  private _chatMessageAbortControllers: Map<string, AbortController>;\n  /** Array of chat messages for the current conversation */\n  messages: ChatMessage[];\n  constructor(ctx: AgentContext, env: Env) {\n    super(ctx, env);\n    this.sql`create table if not exists cf_ai_chat_agent_messages (\n      id text primary key,\n      message text not null,\n      created_at datetime default current_timestamp\n    )`;\n\n    // Load messages and automatically transform them to v5 format\n    const rawMessages = this._loadMessagesFromDb();\n\n    // Automatic migration following https://jhak.im/blog/ai-sdk-migration-handling-previously-saved-messages\n    this.messages = autoTransformMessages(rawMessages);\n\n    this._chatMessageAbortControllers = new Map();\n  }\n\n  private _broadcastChatMessage(message: OutgoingMessage, exclude?: string[]) {\n    this.broadcast(JSON.stringify(message), exclude);\n  }\n\n  private _loadMessagesFromDb(): ChatMessage[] {\n    const rows =\n      this.sql`select * from cf_ai_chat_agent_messages order by created_at` ||\n      [];\n    return rows\n      .map((row) => {\n        try {\n          return JSON.parse(row.message as string);\n        } catch (error) {\n          console.error(`Failed to parse message ${row.id}:`, error);\n          return null;\n        }\n      })\n      .filter((msg): msg is ChatMessage => msg !== null);\n  }\n\n  override async onMessage(connection: Connection, message: WSMessage) {\n    if (typeof message === \"string\") {\n      let data: IncomingMessage;\n      try {\n        data = JSON.parse(message) as IncomingMessage;\n      } catch (_error) {\n        // silently ignore invalid messages for now\n        // TODO: log errors with log levels\n        return;\n      }\n      if (\n        data.type === MessageType.CF_AGENT_USE_CHAT_REQUEST &&\n        data.init.method === \"POST\"\n      ) {\n        const {\n          // method,\n          // keepalive,\n          // headers,\n          body // we're reading this\n          //\n          // // these might not exist?\n          // dispatcher,\n          // duplex\n        } = data.init;\n        const { messages } = JSON.parse(body as string);\n\n        // Automatically transform any incoming messages\n        const transformedMessages = autoTransformMessages(messages);\n\n        this._broadcastChatMessage(\n          {\n            messages: transformedMessages,\n            type: MessageType.CF_AGENT_CHAT_MESSAGES\n          },\n          [connection.id]\n        );\n\n        await this.persistMessages(transformedMessages, [connection.id]);\n\n        this.observability?.emit(\n          {\n            displayMessage: \"Chat message request\",\n            id: data.id,\n            payload: {},\n            timestamp: Date.now(),\n            type: \"message:request\"\n          },\n          this.ctx\n        );\n\n        const chatMessageId = data.id;\n        const abortSignal = this._getAbortSignal(chatMessageId);\n\n        return this._tryCatchChat(async () => {\n          const response = await this.onChatMessage(\n            async (_finishResult) => {\n              this._removeAbortController(chatMessageId);\n\n              this.observability?.emit(\n                {\n                  displayMessage: \"Chat message response\",\n                  id: data.id,\n                  payload: {},\n                  timestamp: Date.now(),\n                  type: \"message:response\"\n                },\n                this.ctx\n              );\n\n              // Note: Message persistence now happens in the _reply method\n              // after the complete response text has been accumulated\n            },\n            abortSignal ? { abortSignal } : undefined\n          );\n\n          if (response) {\n            await this._reply(data.id, response);\n          } else {\n            // Log a warning for observability\n            console.warn(\n              `[AIChatAgent] onChatMessage returned no response for chatMessageId: ${chatMessageId}`\n            );\n            // Send a fallback message to the client\n            this._broadcastChatMessage(\n              {\n                body: \"No response was generated by the agent.\",\n                done: true,\n                id: data.id,\n                type: MessageType.CF_AGENT_USE_CHAT_RESPONSE\n              },\n              [connection.id]\n            );\n          }\n        });\n      }\n      if (data.type === MessageType.CF_AGENT_CHAT_CLEAR) {\n        this._destroyAbortControllers();\n        this.sql`delete from cf_ai_chat_agent_messages`;\n        this.messages = [];\n        this._broadcastChatMessage(\n          {\n            type: MessageType.CF_AGENT_CHAT_CLEAR\n          },\n          [connection.id]\n        );\n      } else if (data.type === MessageType.CF_AGENT_CHAT_MESSAGES) {\n        // replace the messages with the new ones, automatically transformed\n        const transformedMessages = autoTransformMessages(data.messages);\n        await this.persistMessages(transformedMessages, [connection.id]);\n      } else if (data.type === MessageType.CF_AGENT_CHAT_REQUEST_CANCEL) {\n        // propagate an abort signal for the associated request\n        this._cancelChatRequest(data.id);\n      }\n    }\n  }\n\n  override async onRequest(request: Request): Promise<Response> {\n    return this._tryCatchChat(() => {\n      const url = new URL(request.url);\n      if (url.pathname.endsWith(\"/get-messages\")) {\n        const messages = this._loadMessagesFromDb();\n        return Response.json(messages);\n      }\n      return super.onRequest(request);\n    });\n  }\n\n  private async _tryCatchChat<T>(fn: () => T | Promise<T>) {\n    try {\n      return await fn();\n    } catch (e) {\n      throw this.onError(e);\n    }\n  }\n\n  /**\n   * Handle incoming chat messages and generate a response\n   * @param onFinish Callback to be called when the response is finished\n   * @param options.signal A signal to pass to any child requests which can be used to cancel them\n   * @returns Response to send to the client or undefined\n   */\n  async onChatMessage(\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: overridden later\n    onFinish: StreamTextOnFinishCallback<ToolSet>,\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: overridden later\n    options?: { abortSignal: AbortSignal | undefined }\n  ): Promise<Response | undefined> {\n    throw new Error(\n      \"recieved a chat message, override onChatMessage and return a Response to send to the client\"\n    );\n  }\n\n  /**\n   * Save messages on the server side\n   * @param messages Chat messages to save\n   */\n  async saveMessages(messages: ChatMessage[]) {\n    await this.persistMessages(messages);\n    await this._tryCatchChat(async () => {\n      const response = await this.onChatMessage(() => {});\n      if (response) this._reply(crypto.randomUUID(), response);\n    });\n  }\n\n  async persistMessages(\n    messages: ChatMessage[],\n    excludeBroadcastIds: string[] = []\n  ) {\n    for (const message of messages) {\n      this.sql`\n        insert into cf_ai_chat_agent_messages (id, message)\n        values (${message.id}, ${JSON.stringify(message)})\n        on conflict(id) do update set message = excluded.message\n      `;\n    }\n\n    // refresh in-memory messages\n    const persisted = this._loadMessagesFromDb();\n    this.messages = autoTransformMessages(persisted);\n    this._broadcastChatMessage(\n      {\n        messages: messages,\n        type: MessageType.CF_AGENT_CHAT_MESSAGES\n      },\n      excludeBroadcastIds\n    );\n  }\n\n  private async _reply(id: string, response: Response) {\n    return this._tryCatchChat(async () => {\n      if (!response.body) {\n        // Send empty response if no body\n        this._broadcastChatMessage({\n          body: \"\",\n          done: true,\n          id,\n          type: MessageType.CF_AGENT_USE_CHAT_RESPONSE\n        });\n        return;\n      }\n\n      const reader = response.body.getReader();\n\n      // Parsing state adapted from:\n      // https://github.com/vercel/ai/blob/main/packages/ai/src/ui-message-stream/ui-message-chunks.ts#L295\n      const message: ChatMessage = {\n        id: `assistant_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`, // default\n        role: \"assistant\",\n        parts: []\n      };\n      let activeTextParts: Record<string, TextUIPart> = {};\n      let activeReasoningParts: Record<string, ReasoningUIPart> = {};\n      const partialToolCalls: Record<\n        string,\n        { text: string; index: number; toolName: string; dynamic?: boolean }\n      > = {};\n\n      function updateDynamicToolPart(\n        options: {\n          toolName: string;\n          toolCallId: string;\n          providerExecuted?: boolean;\n        } & (\n          | {\n              state: \"input-streaming\";\n              input: unknown;\n            }\n          | {\n              state: \"input-available\";\n              input: unknown;\n              providerMetadata?: ProviderMetadata;\n            }\n          | {\n              state: \"output-available\";\n              input: unknown;\n              output: unknown;\n              preliminary: boolean | undefined;\n            }\n          | {\n              state: \"output-error\";\n              input: unknown;\n              errorText: string;\n              providerMetadata?: ProviderMetadata;\n            }\n        )\n      ) {\n        const part = message.parts.find(\n          (part) =>\n            part.type === \"dynamic-tool\" &&\n            part.toolCallId === options.toolCallId\n        ) as DynamicToolUIPart | undefined;\n\n        const anyOptions = options as Record<string, unknown>;\n        const anyPart = part as Record<string, unknown>;\n\n        if (part != null) {\n          part.state = options.state;\n          anyPart.toolName = options.toolName;\n          anyPart.input = anyOptions.input;\n          anyPart.output = anyOptions.output;\n          anyPart.errorText = anyOptions.errorText;\n          anyPart.rawInput = anyOptions.rawInput ?? anyPart.rawInput;\n          anyPart.preliminary = anyOptions.preliminary;\n\n          if (\n            anyOptions.providerMetadata != null &&\n            part.state === \"input-available\"\n          ) {\n            part.callProviderMetadata =\n              anyOptions.providerMetadata as ProviderMetadata;\n          }\n        } else {\n          message.parts.push({\n            type: \"dynamic-tool\",\n            toolName: options.toolName,\n            toolCallId: options.toolCallId,\n            state: options.state,\n            input: anyOptions.input,\n            output: anyOptions.output,\n            errorText: anyOptions.errorText,\n            preliminary: anyOptions.preliminary,\n            ...(anyOptions.providerMetadata != null\n              ? { callProviderMetadata: anyOptions.providerMetadata }\n              : {})\n          } as DynamicToolUIPart);\n        }\n      }\n\n      function updateToolPart(\n        options: {\n          toolName: string;\n          toolCallId: string;\n          providerExecuted?: boolean;\n        } & (\n          | {\n              state: \"input-streaming\";\n              input: unknown;\n              providerExecuted?: boolean;\n            }\n          | {\n              state: \"input-available\";\n              input: unknown;\n              providerExecuted?: boolean;\n              providerMetadata?: ProviderMetadata;\n            }\n          | {\n              state: \"output-available\";\n              input: unknown;\n              output: unknown;\n              providerExecuted?: boolean;\n              preliminary?: boolean;\n            }\n          | {\n              state: \"output-error\";\n              input: unknown;\n              rawInput?: unknown;\n              errorText: string;\n              providerExecuted?: boolean;\n              providerMetadata?: ProviderMetadata;\n            }\n        )\n      ) {\n        const part = message.parts.find(\n          (part) => isToolUIPart(part) && part.toolCallId === options.toolCallId\n        ) as ToolUIPart | undefined;\n\n        const anyOptions = options as Record<string, unknown>;\n        const anyPart = part as Record<string, unknown>;\n\n        if (part != null) {\n          part.state = options.state;\n          anyPart.input = anyOptions.input;\n          anyPart.output = anyOptions.output;\n          anyPart.errorText = anyOptions.errorText;\n          anyPart.rawInput = anyOptions.rawInput;\n          anyPart.preliminary = anyOptions.preliminary;\n\n          // once providerExecuted is set, it stays for streaming\n          anyPart.providerExecuted =\n            anyOptions.providerExecuted ?? part.providerExecuted;\n\n          if (\n            anyOptions.providerMetadata != null &&\n            part.state === \"input-available\"\n          ) {\n            part.callProviderMetadata =\n              anyOptions.providerMetadata as ProviderMetadata;\n          }\n        } else {\n          message.parts.push({\n            type: `tool-${options.toolName}`,\n            toolCallId: options.toolCallId,\n            state: options.state,\n            input: anyOptions.input,\n            output: anyOptions.output,\n            rawInput: anyOptions.rawInput,\n            errorText: anyOptions.errorText,\n            providerExecuted: anyOptions.providerExecuted,\n            preliminary: anyOptions.preliminary,\n            ...(anyOptions.providerMetadata != null\n              ? { callProviderMetadata: anyOptions.providerMetadata }\n              : {})\n          } as ToolUIPart);\n        }\n      }\n\n      async function updateMessageMetadata(metadata: unknown) {\n        if (metadata != null) {\n          const mergedMetadata =\n            message.metadata != null\n              ? { ...message.metadata, ...metadata } // TODO: do proper merging\n              : metadata;\n\n          message.metadata = mergedMetadata;\n        }\n      }\n\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) {\n            // Send final completion signal\n            this._broadcastChatMessage({\n              body: \"\",\n              done: true,\n              id,\n              type: MessageType.CF_AGENT_USE_CHAT_RESPONSE\n            });\n            break;\n          }\n\n          const chunk = decoder.decode(value);\n\n          // Determine response format based on content-type\n          const contentType = response.headers.get(\"content-type\") || \"\";\n          const isSSE = contentType.includes(\"text/event-stream\");\n\n          // After streaming is complete, persist the complete assistant's response\n          if (isSSE) {\n            // Parse AI SDK v5 SSE format and extract text deltas\n            const lines = chunk.split(\"\\n\");\n            for (const line of lines) {\n              if (line.startsWith(\"data: \") && line !== \"data: [DONE]\") {\n                try {\n                  const data: UIMessageChunk = JSON.parse(line.slice(6)); // Remove 'data: ' prefix\n                  switch (data.type) {\n                    case \"text-start\": {\n                      const textPart: TextUIPart = {\n                        type: \"text\",\n                        text: \"\",\n                        providerMetadata: data.providerMetadata,\n                        state: \"streaming\"\n                      };\n                      activeTextParts[data.id] = textPart;\n                      message.parts.push(textPart);\n                      break;\n                    }\n\n                    case \"text-delta\": {\n                      const textPart = activeTextParts[data.id];\n                      textPart.text += data.delta;\n                      textPart.providerMetadata =\n                        data.providerMetadata ?? textPart.providerMetadata;\n                      break;\n                    }\n\n                    case \"text-end\": {\n                      const textPart = activeTextParts[data.id];\n                      textPart.state = \"done\";\n                      textPart.providerMetadata =\n                        data.providerMetadata ?? textPart.providerMetadata;\n                      delete activeTextParts[data.id];\n                      break;\n                    }\n\n                    case \"reasoning-start\": {\n                      const reasoningPart: ReasoningUIPart = {\n                        type: \"reasoning\",\n                        text: \"\",\n                        providerMetadata: data.providerMetadata,\n                        state: \"streaming\"\n                      };\n                      activeReasoningParts[data.id] = reasoningPart;\n                      message.parts.push(reasoningPart);\n                      break;\n                    }\n\n                    case \"reasoning-delta\": {\n                      const reasoningPart = activeReasoningParts[data.id];\n                      reasoningPart.text += data.delta;\n                      reasoningPart.providerMetadata =\n                        data.providerMetadata ?? reasoningPart.providerMetadata;\n                      break;\n                    }\n\n                    case \"reasoning-end\": {\n                      const reasoningPart = activeReasoningParts[data.id];\n                      reasoningPart.providerMetadata =\n                        data.providerMetadata ?? reasoningPart.providerMetadata;\n                      reasoningPart.state = \"done\";\n                      delete activeReasoningParts[data.id];\n\n                      break;\n                    }\n\n                    case \"file\": {\n                      message.parts.push({\n                        type: \"file\",\n                        mediaType: data.mediaType,\n                        url: data.url\n                      });\n\n                      break;\n                    }\n\n                    case \"source-url\": {\n                      message.parts.push({\n                        type: \"source-url\",\n                        sourceId: data.sourceId,\n                        url: data.url,\n                        title: data.title,\n                        providerMetadata: data.providerMetadata\n                      });\n\n                      break;\n                    }\n\n                    case \"source-document\": {\n                      message.parts.push({\n                        type: \"source-document\",\n                        sourceId: data.sourceId,\n                        mediaType: data.mediaType,\n                        title: data.title,\n                        filename: data.filename,\n                        providerMetadata: data.providerMetadata\n                      });\n\n                      break;\n                    }\n\n                    case \"tool-input-start\": {\n                      const toolInvocations =\n                        message.parts.filter(isToolUIPart);\n\n                      // add the partial tool call to the map\n                      partialToolCalls[data.toolCallId] = {\n                        text: \"\",\n                        toolName: data.toolName,\n                        index: toolInvocations.length,\n                        dynamic: data.dynamic\n                      };\n\n                      if (data.dynamic) {\n                        updateDynamicToolPart({\n                          toolCallId: data.toolCallId,\n                          toolName: data.toolName,\n                          state: \"input-streaming\",\n                          input: undefined\n                        });\n                      } else {\n                        updateToolPart({\n                          toolCallId: data.toolCallId,\n                          toolName: data.toolName,\n                          state: \"input-streaming\",\n                          input: undefined\n                        });\n                      }\n\n                      break;\n                    }\n\n                    case \"tool-input-delta\": {\n                      const partialToolCall = partialToolCalls[data.toolCallId];\n\n                      partialToolCall.text += data.inputTextDelta;\n\n                      const { value: partialArgs } = await parsePartialJson(\n                        partialToolCall.text\n                      );\n\n                      if (partialToolCall.dynamic) {\n                        updateDynamicToolPart({\n                          toolCallId: data.toolCallId,\n                          toolName: partialToolCall.toolName,\n                          state: \"input-streaming\",\n                          input: partialArgs\n                        });\n                      } else {\n                        updateToolPart({\n                          toolCallId: data.toolCallId,\n                          toolName: partialToolCall.toolName,\n                          state: \"input-streaming\",\n                          input: partialArgs\n                        });\n                      }\n\n                      break;\n                    }\n\n                    case \"tool-input-available\": {\n                      if (data.dynamic) {\n                        updateDynamicToolPart({\n                          toolCallId: data.toolCallId,\n                          toolName: data.toolName,\n                          state: \"input-available\",\n                          input: data.input,\n                          providerMetadata: data.providerMetadata\n                        });\n                      } else {\n                        updateToolPart({\n                          toolCallId: data.toolCallId,\n                          toolName: data.toolName,\n                          state: \"input-available\",\n                          input: data.input,\n                          providerExecuted: data.providerExecuted,\n                          providerMetadata: data.providerMetadata\n                        });\n                      }\n\n                      // TODO: Do we want to expose onToolCall?\n\n                      // invoke the onToolCall callback if it exists. This is blocking.\n                      // In the future we should make this non-blocking, which\n                      // requires additional state management for error handling etc.\n                      // Skip calling onToolCall for provider-executed tools since they are already executed\n                      // if (onToolCall && !data.providerExecuted) {\n                      //   await onToolCall({\n                      //     toolCall: data\n                      //   });\n                      // }\n                      break;\n                    }\n\n                    case \"tool-input-error\": {\n                      if (data.dynamic) {\n                        updateDynamicToolPart({\n                          toolCallId: data.toolCallId,\n                          toolName: data.toolName,\n                          state: \"output-error\",\n                          input: data.input,\n                          errorText: data.errorText,\n                          providerMetadata: data.providerMetadata\n                        });\n                      } else {\n                        updateToolPart({\n                          toolCallId: data.toolCallId,\n                          toolName: data.toolName,\n                          state: \"output-error\",\n                          input: undefined,\n                          rawInput: data.input,\n                          errorText: data.errorText,\n                          providerExecuted: data.providerExecuted,\n                          providerMetadata: data.providerMetadata\n                        });\n                      }\n\n                      break;\n                    }\n\n                    case \"tool-output-available\": {\n                      if (data.dynamic) {\n                        const toolInvocations = message.parts.filter(\n                          (part) => part.type === \"dynamic-tool\"\n                        ) as DynamicToolUIPart[];\n\n                        const toolInvocation = toolInvocations.find(\n                          (invocation) =>\n                            invocation.toolCallId === data.toolCallId\n                        );\n\n                        if (!toolInvocation)\n                          throw new Error(\"Tool invocation not found\");\n\n                        updateDynamicToolPart({\n                          toolCallId: data.toolCallId,\n                          toolName: toolInvocation.toolName,\n                          state: \"output-available\",\n                          input: toolInvocation.input,\n                          output: data.output,\n                          preliminary: data.preliminary\n                        });\n                      } else {\n                        const toolInvocations =\n                          message.parts.filter(isToolUIPart);\n\n                        const toolInvocation = toolInvocations.find(\n                          (invocation) =>\n                            invocation.toolCallId === data.toolCallId\n                        );\n\n                        if (!toolInvocation)\n                          throw new Error(\"Tool invocation not found\");\n\n                        updateToolPart({\n                          toolCallId: data.toolCallId,\n                          toolName: getToolName(toolInvocation),\n                          state: \"output-available\",\n                          input: toolInvocation.input,\n                          output: data.output,\n                          providerExecuted: data.providerExecuted,\n                          preliminary: data.preliminary\n                        });\n                      }\n\n                      break;\n                    }\n\n                    case \"tool-output-error\": {\n                      if (data.dynamic) {\n                        const toolInvocations = message.parts.filter(\n                          (part) => part.type === \"dynamic-tool\"\n                        ) as DynamicToolUIPart[];\n\n                        const toolInvocation = toolInvocations.find(\n                          (invocation) =>\n                            invocation.toolCallId === data.toolCallId\n                        );\n\n                        if (!toolInvocation)\n                          throw new Error(\"Tool invocation not found\");\n\n                        updateDynamicToolPart({\n                          toolCallId: data.toolCallId,\n                          toolName: toolInvocation.toolName,\n                          state: \"output-error\",\n                          input: toolInvocation.input,\n                          errorText: data.errorText\n                        });\n                      } else {\n                        const toolInvocations =\n                          message.parts.filter(isToolUIPart);\n\n                        const toolInvocation = toolInvocations.find(\n                          (invocation) =>\n                            invocation.toolCallId === data.toolCallId\n                        );\n\n                        if (!toolInvocation)\n                          throw new Error(\"Tool invocation not found\");\n                        updateToolPart({\n                          toolCallId: data.toolCallId,\n                          toolName: getToolName(toolInvocation),\n                          state: \"output-error\",\n                          input: toolInvocation.input,\n                          rawInput:\n                            \"rawInput\" in toolInvocation\n                              ? toolInvocation.rawInput\n                              : undefined,\n                          errorText: data.errorText\n                        });\n                      }\n\n                      break;\n                    }\n\n                    case \"start-step\": {\n                      // add a step boundary part to the message\n                      message.parts.push({ type: \"step-start\" });\n                      break;\n                    }\n\n                    case \"finish-step\": {\n                      // reset the current text and reasoning parts\n                      activeTextParts = {};\n                      activeReasoningParts = {};\n                      break;\n                    }\n\n                    case \"start\": {\n                      if (data.messageId != null) {\n                        message.id = data.messageId;\n                      }\n\n                      await updateMessageMetadata(data.messageMetadata);\n\n                      break;\n                    }\n\n                    case \"finish\": {\n                      await updateMessageMetadata(data.messageMetadata);\n                      break;\n                    }\n\n                    case \"message-metadata\": {\n                      await updateMessageMetadata(data.messageMetadata);\n                      break;\n                    }\n\n                    case \"error\": {\n                      this._broadcastChatMessage({\n                        error: true,\n                        body: data.errorText ?? JSON.stringify(data),\n                        done: false,\n                        id,\n                        type: MessageType.CF_AGENT_USE_CHAT_RESPONSE\n                      });\n\n                      break;\n                    }\n                    // Do we want to handle data parts?\n                  }\n\n                  // Always forward the raw part to the client\n                  this._broadcastChatMessage({\n                    body: JSON.stringify(data),\n                    done: false,\n                    id,\n                    type: MessageType.CF_AGENT_USE_CHAT_RESPONSE\n                  });\n                } catch (_e) {\n                  // Skip malformed JSON lines silently\n                }\n              }\n            }\n          } else {\n            // Handle plain text responses (e.g., from generateText)\n            // Treat the entire chunk as a text delta to preserve exact formatting\n            if (chunk.length > 0) {\n              message.parts.push({ type: \"text\", text: chunk });\n              // Synthesize a text-delta event so clients can stream-render\n              this._broadcastChatMessage({\n                body: JSON.stringify({ type: \"text-delta\", delta: chunk }),\n                done: false,\n                id,\n                type: MessageType.CF_AGENT_USE_CHAT_RESPONSE\n              });\n            }\n          }\n        }\n      } finally {\n        reader.releaseLock();\n      }\n\n      if (message.parts.length > 0) {\n        await this.persistMessages([...this.messages, message]);\n      }\n    });\n  }\n\n  /**\n   * For the given message id, look up its associated AbortController\n   * If the AbortController does not exist, create and store one in memory\n   *\n   * returns the AbortSignal associated with the AbortController\n   */\n  private _getAbortSignal(id: string): AbortSignal | undefined {\n    // Defensive check, since we're coercing message types at the moment\n    if (typeof id !== \"string\") {\n      return undefined;\n    }\n\n    if (!this._chatMessageAbortControllers.has(id)) {\n      this._chatMessageAbortControllers.set(id, new AbortController());\n    }\n\n    return this._chatMessageAbortControllers.get(id)?.signal;\n  }\n\n  /**\n   * Remove an abort controller from the cache of pending message responses\n   */\n  private _removeAbortController(id: string) {\n    this._chatMessageAbortControllers.delete(id);\n  }\n\n  /**\n   * Propagate an abort signal for any requests associated with the given message id\n   */\n  private _cancelChatRequest(id: string) {\n    if (this._chatMessageAbortControllers.has(id)) {\n      const abortController = this._chatMessageAbortControllers.get(id);\n      abortController?.abort();\n    }\n  }\n\n  /**\n   * Abort all pending requests and clear the cache of AbortControllers\n   */\n  private _destroyAbortControllers() {\n    for (const controller of this._chatMessageAbortControllers.values()) {\n      controller?.abort();\n    }\n    this._chatMessageAbortControllers.clear();\n  }\n\n  /**\n   * When the DO is destroyed, cancel all pending requests\n   */\n  async destroy() {\n    this._destroyAbortControllers();\n    await super.destroy();\n  }\n}\n"],"mappings":"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","names":["part"]}