{"version":3,"sources":["../src/ai-react.tsx"],"sourcesContent":["import { useChat, type UseChatOptions } from \"@ai-sdk/react\";\nimport { getToolName, isToolUIPart } from \"ai\";\nimport type {\n  ChatInit,\n  ChatTransport,\n  UIMessage as Message,\n  UIMessage\n} from \"ai\";\nimport { DefaultChatTransport } from \"ai\";\nimport { nanoid } from \"nanoid\";\nimport { use, useCallback, useEffect, useMemo, useRef } from \"react\";\nimport type { OutgoingMessage } from \"./ai-types\";\nimport { MessageType } from \"./ai-types\";\nimport type { useAgent } from \"./react\";\n\nexport type AITool<Input = unknown, Output = unknown> = {\n  description?: string;\n  inputSchema?: unknown;\n  execute?: (input: Input) => Output | Promise<Output>;\n};\n\ntype GetInitialMessagesOptions = {\n  agent: string;\n  name: string;\n  url: string;\n};\n\n// v5 useChat parameters\ntype UseChatParams<M extends UIMessage = UIMessage> = ChatInit<M> &\n  UseChatOptions<M>;\n\n/**\n * Options for the useAgentChat hook\n */\ntype UseAgentChatOptions<\n  State,\n  ChatMessage extends UIMessage = UIMessage\n> = Omit<UseChatParams<ChatMessage>, \"fetch\"> & {\n  /** Agent connection from useAgent */\n  agent: ReturnType<typeof useAgent<State>>;\n  getInitialMessages?:\n    | undefined\n    | null\n    | ((options: GetInitialMessagesOptions) => Promise<ChatMessage[]>);\n  /** Request credentials */\n  credentials?: RequestCredentials;\n  /** Request headers */\n  headers?: HeadersInit;\n  /**\n   * @description Whether to automatically resolve tool calls that do not require human interaction.\n   * @experimental\n   */\n  experimental_automaticToolResolution?: boolean;\n  /**\n   * @description Tools object for automatic detection of confirmation requirements.\n   * Tools without execute function will require confirmation.\n   */\n  tools?: Record<string, AITool<unknown, unknown>>;\n  /**\n   * @description Manual override for tools requiring confirmation.\n   * If not provided, will auto-detect from tools object.\n   */\n  toolsRequiringConfirmation?: string[];\n  /**\n   * When true (default), automatically sends the next message only after\n   * all pending confirmation-required tool calls have been resolved.\n   * @default true\n   */\n  autoSendAfterAllConfirmationsResolved?: boolean;\n};\n\nconst requestCache = new Map<string, Promise<Message[]>>();\n\n/**\n * React hook for building AI chat interfaces using an Agent\n * @param options Chat options including the agent connection\n * @returns Chat interface controls and state with added clearHistory method\n */\n/**\n * Automatically detects which tools require confirmation based on their configuration.\n * Tools require confirmation if they have no execute function AND are not server-executed.\n * @param tools - Record of tool name to tool definition\n * @returns Array of tool names that require confirmation\n */\nexport function detectToolsRequiringConfirmation(\n  tools?: Record<string, AITool<unknown, unknown>>\n): string[] {\n  if (!tools) return [];\n\n  return Object.entries(tools)\n    .filter(([_name, tool]) => !tool.execute)\n    .map(([name]) => name);\n}\n\nexport function useAgentChat<\n  State = unknown,\n  ChatMessage extends UIMessage = UIMessage\n>(\n  options: UseAgentChatOptions<State, ChatMessage>\n): ReturnType<typeof useChat<ChatMessage>> & {\n  clearHistory: () => void;\n} {\n  const {\n    agent,\n    getInitialMessages,\n    messages: optionsInitialMessages,\n    experimental_automaticToolResolution,\n    tools,\n    toolsRequiringConfirmation: manualToolsRequiringConfirmation,\n    autoSendAfterAllConfirmationsResolved = true,\n    ...rest\n  } = options;\n\n  // Auto-detect tools requiring confirmation, or use manual override\n  const toolsRequiringConfirmation =\n    manualToolsRequiringConfirmation ?? detectToolsRequiringConfirmation(tools);\n\n  const agentUrl = new URL(\n    `${// @ts-expect-error we're using a protected _url property that includes query params\n    ((agent._url as string | null) || agent._pkurl)\n      ?.replace(\"ws://\", \"http://\")\n      .replace(\"wss://\", \"https://\")}`\n  );\n\n  agentUrl.searchParams.delete(\"_pk\");\n  const agentUrlString = agentUrl.toString();\n\n  // Keep a ref to always point to the latest agent instance\n  const agentRef = useRef(agent);\n  useEffect(() => {\n    agentRef.current = agent;\n  }, [agent]);\n\n  async function defaultGetInitialMessagesFetch({\n    url\n  }: GetInitialMessagesOptions) {\n    const getMessagesUrl = new URL(url);\n    getMessagesUrl.pathname += \"/get-messages\";\n    const response = await fetch(getMessagesUrl.toString(), {\n      credentials: options.credentials,\n      headers: options.headers\n    });\n\n    if (!response.ok) {\n      console.warn(\n        `Failed to fetch initial messages: ${response.status} ${response.statusText}`\n      );\n      return [];\n    }\n\n    const text = await response.text();\n    if (!text.trim()) {\n      return [];\n    }\n\n    try {\n      return JSON.parse(text) as ChatMessage[];\n    } catch (error) {\n      console.warn(\"Failed to parse initial messages JSON:\", error);\n      return [];\n    }\n  }\n\n  const getInitialMessagesFetch =\n    getInitialMessages || defaultGetInitialMessagesFetch;\n\n  function doGetInitialMessages(\n    getInitialMessagesOptions: GetInitialMessagesOptions\n  ) {\n    if (requestCache.has(agentUrlString)) {\n      return requestCache.get(agentUrlString)! as Promise<ChatMessage[]>;\n    }\n    const promise = getInitialMessagesFetch(getInitialMessagesOptions);\n    requestCache.set(agentUrlString, promise);\n    return promise;\n  }\n\n  const initialMessagesPromise =\n    getInitialMessages === null\n      ? null\n      : doGetInitialMessages({\n          agent: agent.agent,\n          name: agent.name,\n          url: agentUrlString\n        });\n  const initialMessages = initialMessagesPromise\n    ? use(initialMessagesPromise)\n    : (optionsInitialMessages ?? []);\n\n  useEffect(() => {\n    if (!initialMessagesPromise) {\n      return;\n    }\n    requestCache.set(agentUrlString, initialMessagesPromise!);\n    return () => {\n      if (requestCache.get(agentUrlString) === initialMessagesPromise) {\n        requestCache.delete(agentUrlString);\n      }\n    };\n  }, [agentUrlString, initialMessagesPromise]);\n\n  const aiFetch = useCallback(\n    async (request: RequestInfo | URL, options: RequestInit = {}) => {\n      const {\n        method,\n        keepalive,\n        headers,\n        body,\n        redirect,\n        integrity,\n        signal,\n        credentials,\n        mode,\n        referrer,\n        referrerPolicy,\n        window\n      } = options;\n      const id = nanoid(8);\n      const abortController = new AbortController();\n      let controller: ReadableStreamDefaultController;\n      const currentAgent = agentRef.current;\n\n      signal?.addEventListener(\"abort\", () => {\n        currentAgent.send(\n          JSON.stringify({\n            id,\n            type: MessageType.CF_AGENT_CHAT_REQUEST_CANCEL\n          })\n        );\n\n        // NOTE - If we wanted to, we could preserve the \"interrupted\" message here, with the code below\n        //        However, I think it might be the responsibility of the library user to implement that behavior manually?\n        //        Reasoning: This code could be subject to collisions, as it \"force saves\" the messages we have locally\n        //\n        // agent.send(JSON.stringify({\n        //   type: MessageType.CF_AGENT_CHAT_MESSAGES,\n        //   messages: ... /* some way of getting current messages ref? */\n        // }))\n\n        abortController.abort();\n        // Make sure to also close the stream (cf. https://github.com/cloudflare/agents-starter/issues/69)\n        controller.close();\n      });\n\n      currentAgent.addEventListener(\n        \"message\",\n        (event) => {\n          let data: OutgoingMessage<ChatMessage>;\n          try {\n            data = JSON.parse(event.data) as OutgoingMessage<ChatMessage>;\n          } catch (_error) {\n            // silently ignore invalid messages for now\n            // TODO: log errors with log levels\n            return;\n          }\n          if (data.type === MessageType.CF_AGENT_USE_CHAT_RESPONSE) {\n            if (data.id === id) {\n              if (data.error) {\n                controller.error(new Error(data.body));\n                abortController.abort();\n              } else {\n                // Only enqueue non-empty data to prevent JSON parsing errors\n                if (data.body?.trim()) {\n                  controller.enqueue(\n                    new TextEncoder().encode(`data: ${data.body}\\n\\n`)\n                  );\n                }\n                if (data.done) {\n                  controller.close();\n                  abortController.abort();\n                }\n              }\n            }\n          }\n        },\n        { signal: abortController.signal }\n      );\n\n      const stream = new ReadableStream({\n        start(c) {\n          controller = c;\n        }\n      });\n\n      currentAgent.send(\n        JSON.stringify({\n          id,\n          init: {\n            body,\n            credentials,\n            headers,\n            integrity,\n            keepalive,\n            method,\n            mode,\n            redirect,\n            referrer,\n            referrerPolicy,\n            window\n          },\n          type: MessageType.CF_AGENT_USE_CHAT_REQUEST,\n          url: request.toString()\n        })\n      );\n\n      return new Response(stream);\n    },\n    []\n  );\n\n  const customTransport: ChatTransport<ChatMessage> = useMemo(\n    () => ({\n      sendMessages: async (\n        options: Parameters<\n          typeof DefaultChatTransport.prototype.sendMessages\n        >[0]\n      ) => {\n        const transport = new DefaultChatTransport<ChatMessage>({\n          api: agentUrlString,\n          fetch: aiFetch\n        });\n        return transport.sendMessages(options);\n      },\n      reconnectToStream: async (\n        options: Parameters<\n          typeof DefaultChatTransport.prototype.reconnectToStream\n        >[0]\n      ) => {\n        const transport = new DefaultChatTransport<ChatMessage>({\n          api: agentUrlString,\n          fetch: aiFetch\n        });\n        return transport.reconnectToStream(options);\n      }\n    }),\n    [agentUrlString, aiFetch]\n  );\n\n  const useChatHelpers = useChat<ChatMessage>({\n    ...rest,\n    messages: initialMessages,\n    transport: customTransport,\n    id: agent._pk\n  });\n\n  const processedToolCalls = useRef(new Set<string>());\n\n  // Calculate pending confirmations for the latest assistant message\n  const lastMessage =\n    useChatHelpers.messages[useChatHelpers.messages.length - 1];\n\n  const pendingConfirmations = (() => {\n    if (!lastMessage || lastMessage.role !== \"assistant\") {\n      return { messageId: undefined, toolCallIds: new Set<string>() };\n    }\n\n    const pendingIds = new Set<string>();\n    for (const part of lastMessage.parts ?? []) {\n      if (\n        isToolUIPart(part) &&\n        part.state === \"input-available\" &&\n        toolsRequiringConfirmation.includes(getToolName(part))\n      ) {\n        pendingIds.add(part.toolCallId);\n      }\n    }\n    return { messageId: lastMessage.id, toolCallIds: pendingIds };\n  })();\n\n  const pendingConfirmationsRef = useRef(pendingConfirmations);\n  pendingConfirmationsRef.current = pendingConfirmations;\n\n  // tools can be a different object everytime it's called,\n  // which might lead to this effect being called multiple times with different tools objects.\n  // we need to fix this, but that's a bigger refactor.\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we need to fix this\n  useEffect(() => {\n    if (!experimental_automaticToolResolution) {\n      return;\n    }\n\n    const lastMessage =\n      useChatHelpers.messages[useChatHelpers.messages.length - 1];\n    if (!lastMessage || lastMessage.role !== \"assistant\") {\n      return;\n    }\n\n    const toolCalls = lastMessage.parts.filter(\n      (part) =>\n        isToolUIPart(part) &&\n        part.state === \"input-available\" &&\n        !processedToolCalls.current.has(part.toolCallId)\n    );\n\n    if (toolCalls.length > 0) {\n      (async () => {\n        const toolCallsToResolve = toolCalls.filter(\n          (part) =>\n            isToolUIPart(part) &&\n            !toolsRequiringConfirmation.includes(getToolName(part)) &&\n            tools?.[getToolName(part)]?.execute // Only execute if client has execute function\n        );\n\n        if (toolCallsToResolve.length > 0) {\n          for (const part of toolCallsToResolve) {\n            if (isToolUIPart(part)) {\n              processedToolCalls.current.add(part.toolCallId);\n              let toolOutput = null;\n              const toolName = getToolName(part);\n              const tool = tools?.[toolName];\n\n              if (tool?.execute && part.input) {\n                try {\n                  toolOutput = await tool.execute(part.input);\n                } catch (error) {\n                  toolOutput = `Error executing tool: ${error instanceof Error ? error.message : String(error)}`;\n                }\n              }\n\n              await useChatHelpers.addToolResult({\n                toolCallId: part.toolCallId,\n                tool: toolName,\n                output: toolOutput\n              });\n            }\n          }\n          // If there are NO pending confirmations for the latest assistant message,\n          // we can continue the conversation. Otherwise, wait for the UI to resolve\n          // those confirmations; the addToolResult wrapper will send when the last\n          // pending confirmation is resolved.\n          if (pendingConfirmationsRef.current.toolCallIds.size === 0) {\n            useChatHelpers.sendMessage();\n          }\n        }\n      })();\n    }\n  }, [\n    useChatHelpers.messages,\n    experimental_automaticToolResolution,\n    useChatHelpers.addToolResult,\n    useChatHelpers.sendMessage,\n    toolsRequiringConfirmation\n  ]);\n\n  useEffect(() => {\n    function onClearHistory(event: MessageEvent) {\n      if (typeof event.data !== \"string\") return;\n      let data: OutgoingMessage;\n      try {\n        data = JSON.parse(event.data) as OutgoingMessage;\n      } catch (_error) {\n        return;\n      }\n      if (data.type === MessageType.CF_AGENT_CHAT_CLEAR) {\n        useChatHelpers.setMessages([]);\n      }\n    }\n\n    function onMessages(event: MessageEvent) {\n      if (typeof event.data !== \"string\") return;\n      let data: OutgoingMessage<ChatMessage>;\n      try {\n        data = JSON.parse(event.data) as OutgoingMessage<ChatMessage>;\n      } catch (_error) {\n        return;\n      }\n      if (data.type === MessageType.CF_AGENT_CHAT_MESSAGES) {\n        useChatHelpers.setMessages(data.messages);\n      }\n    }\n\n    agent.addEventListener(\"message\", onClearHistory);\n    agent.addEventListener(\"message\", onMessages);\n\n    return () => {\n      agent.removeEventListener(\"message\", onClearHistory);\n      agent.removeEventListener(\"message\", onMessages);\n    };\n  }, [agent, useChatHelpers.setMessages]);\n\n  // Wrapper that sends only when the last pending confirmation is resolved\n  const addToolResultAndSendMessage: typeof useChatHelpers.addToolResult =\n    async (args) => {\n      const { toolCallId } = args;\n\n      await useChatHelpers.addToolResult(args);\n\n      if (!autoSendAfterAllConfirmationsResolved) {\n        // always send immediately\n        useChatHelpers.sendMessage();\n        return;\n      }\n\n      // wait for all confirmations\n      const pending = pendingConfirmationsRef.current?.toolCallIds;\n      if (!pending) {\n        useChatHelpers.sendMessage();\n        return;\n      }\n\n      const wasLast = pending.size === 1 && pending.has(toolCallId);\n      if (pending.has(toolCallId)) {\n        pending.delete(toolCallId);\n      }\n\n      if (wasLast || pending.size === 0) {\n        useChatHelpers.sendMessage();\n      }\n    };\n\n  return {\n    ...useChatHelpers,\n    addToolResult: addToolResultAndSendMessage,\n    clearHistory: () => {\n      useChatHelpers.setMessages([]);\n      agent.send(\n        JSON.stringify({\n          type: MessageType.CF_AGENT_CHAT_CLEAR\n        })\n      );\n    },\n    setMessages: (\n      messages: Parameters<typeof useChatHelpers.setMessages>[0]\n    ) => {\n      useChatHelpers.setMessages(messages);\n      agent.send(\n        JSON.stringify({\n          messages: Array.isArray(messages) ? messages : [],\n          type: MessageType.CF_AGENT_CHAT_MESSAGES\n        })\n      );\n    }\n  };\n}\n"],"mappings":"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","names":["options","lastMessage"]}