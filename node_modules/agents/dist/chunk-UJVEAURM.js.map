{"version":3,"sources":["../src/ai-chat-v5-migration.ts"],"sourcesContent":["import type { UIMessage } from \"ai\";\n\n/**\n * AI SDK v5 Migration following https://jhak.im/blog/ai-sdk-migration-handling-previously-saved-messages\n * Using exact types from the official AI SDK documentation\n */\n\n/**\n * AI SDK v5 Message Part types reference (from official AI SDK documentation)\n *\n * The migration logic below transforms legacy messages to match these official AI SDK v5 formats:\n * - TextUIPart: { type: \"text\", text: string, state?: \"streaming\" | \"done\" }\n * - ReasoningUIPart: { type: \"reasoning\", text: string, state?: \"streaming\" | \"done\", providerMetadata?: Record<string, unknown> }\n * - FileUIPart: { type: \"file\", mediaType: string, filename?: string, url: string }\n * - ToolUIPart: { type: `tool-${string}`, toolCallId: string, state: \"input-streaming\" | \"input-available\" | \"output-available\" | \"output-error\", input?: Record<string, unknown>, output?: unknown, errorText?: string, providerExecuted?: boolean }\n */\n\n/**\n * Tool invocation from v4 format\n */\ntype ToolInvocation = {\n  toolCallId: string;\n  toolName: string;\n  args: Record<string, unknown>;\n  result?: unknown;\n  state: \"partial-call\" | \"call\" | \"result\" | \"error\";\n};\n\n/**\n * Legacy part from v4 format\n */\ntype LegacyPart = {\n  type: string;\n  text?: string;\n  url?: string;\n  data?: string;\n  mimeType?: string;\n  mediaType?: string;\n  filename?: string;\n};\n\n/**\n * Legacy message format from AI SDK v4\n */\nexport type LegacyMessage = {\n  id?: string;\n  role: string;\n  content: string;\n  reasoning?: string;\n  toolInvocations?: ToolInvocation[];\n  parts?: LegacyPart[];\n  [key: string]: unknown;\n};\n\n/**\n * Corrupt content item\n */\ntype CorruptContentItem = {\n  type: string;\n  text: string;\n};\n\n/**\n * Corrupted message format - has content as array instead of parts\n */\nexport type CorruptArrayMessage = {\n  id?: string;\n  role: string;\n  content: CorruptContentItem[];\n  reasoning?: string;\n  toolInvocations?: ToolInvocation[];\n  [key: string]: unknown;\n};\n\n/**\n * Union type for messages that could be in any format\n */\nexport type MigratableMessage = LegacyMessage | CorruptArrayMessage | UIMessage;\n\n/**\n * Tool call state mapping for v4 to v5 migration\n */\nconst STATE_MAP = {\n  \"partial-call\": \"input-streaming\",\n  call: \"input-available\",\n  result: \"output-available\",\n  error: \"output-error\"\n} as const;\n\n/**\n * Checks if a message is already in the UIMessage format (has parts array)\n */\nexport function isUIMessage(message: unknown): message is UIMessage {\n  return (\n    typeof message === \"object\" &&\n    message !== null &&\n    \"parts\" in message &&\n    Array.isArray((message as { parts: unknown }).parts)\n  );\n}\n\n/**\n * Type guard to check if a message is in legacy format (content as string)\n */\nfunction isLegacyMessage(message: unknown): message is LegacyMessage {\n  return (\n    typeof message === \"object\" &&\n    message !== null &&\n    \"role\" in message &&\n    \"content\" in message &&\n    typeof (message as { role: unknown }).role === \"string\" &&\n    typeof (message as { content: unknown }).content === \"string\"\n  );\n}\n\n/**\n * Type guard to check if a message has corrupted array content format\n * Detects: {role: \"user\", content: [{type: \"text\", text: \"...\"}]}\n */\nfunction isCorruptArrayMessage(\n  message: unknown\n): message is CorruptArrayMessage {\n  return (\n    typeof message === \"object\" &&\n    message !== null &&\n    \"role\" in message &&\n    \"content\" in message &&\n    typeof (message as { role: unknown }).role === \"string\" &&\n    Array.isArray((message as { content: unknown }).content) &&\n    !(\"parts\" in message) // Ensure it's not already a UIMessage\n  );\n}\n\n/**\n * Internal message part type for transformation\n */\ntype TransformMessagePart = {\n  type: string;\n  text?: string;\n  toolCallId?: string;\n  state?: string;\n  input?: Record<string, unknown>;\n  output?: unknown;\n  url?: string;\n  mediaType?: string;\n  errorText?: string;\n  filename?: string;\n};\n\n/**\n * Input message that could be in any format - using unknown for flexibility\n */\ntype InputMessage = {\n  id?: string;\n  role?: string;\n  content?: unknown;\n  reasoning?: string;\n  toolInvocations?: unknown[];\n  parts?: unknown[];\n  [key: string]: unknown;\n};\n\n/**\n * Automatic message transformer following the blog post pattern\n * Handles comprehensive migration from AI SDK v4 to v5 format\n * @param message - Message in any legacy format\n * @param index - Index for ID generation fallback\n * @returns UIMessage in v5 format\n */\nexport function autoTransformMessage(\n  message: InputMessage,\n  index = 0\n): UIMessage {\n  // Already in v5 format\n  if (isUIMessage(message)) {\n    return message;\n  }\n\n  const parts: TransformMessagePart[] = [];\n\n  // Handle reasoning transformation\n  if (message.reasoning) {\n    parts.push({\n      type: \"reasoning\",\n      text: message.reasoning\n    });\n  }\n\n  // Handle tool invocations transformation\n  if (message.toolInvocations && Array.isArray(message.toolInvocations)) {\n    message.toolInvocations.forEach((inv: unknown) => {\n      if (typeof inv === \"object\" && inv !== null && \"toolName\" in inv) {\n        const invObj = inv as ToolInvocation;\n        parts.push({\n          type: `tool-${invObj.toolName}`,\n          toolCallId: invObj.toolCallId,\n          state:\n            STATE_MAP[invObj.state as keyof typeof STATE_MAP] ||\n            \"input-available\",\n          input: invObj.args,\n          output: invObj.result !== undefined ? invObj.result : null\n        });\n      }\n    });\n  }\n\n  // Handle file parts transformation\n  if (message.parts && Array.isArray(message.parts)) {\n    message.parts.forEach((part: unknown) => {\n      if (typeof part === \"object\" && part !== null && \"type\" in part) {\n        const partObj = part as LegacyPart;\n        if (partObj.type === \"file\") {\n          parts.push({\n            type: \"file\",\n            url:\n              partObj.url ||\n              (partObj.data\n                ? `data:${partObj.mimeType || partObj.mediaType};base64,${partObj.data}`\n                : undefined),\n            mediaType: partObj.mediaType || partObj.mimeType,\n            filename: partObj.filename\n          });\n        }\n      }\n    });\n  }\n\n  // Handle corrupt array format: {role: \"user\", content: [{type: \"text\", text: \"...\"}]}\n  if (Array.isArray(message.content)) {\n    message.content.forEach((item: unknown) => {\n      if (typeof item === \"object\" && item !== null && \"text\" in item) {\n        const itemObj = item as CorruptContentItem;\n        parts.push({\n          type: itemObj.type || \"text\",\n          text: itemObj.text || \"\"\n        });\n      }\n    });\n  }\n\n  // Fallback: convert plain content to text part\n  if (!parts.length && message.content !== undefined) {\n    parts.push({\n      type: \"text\",\n      text:\n        typeof message.content === \"string\"\n          ? message.content\n          : JSON.stringify(message.content)\n    });\n  }\n\n  // If still no parts, create a default text part\n  if (!parts.length) {\n    parts.push({\n      type: \"text\",\n      text: typeof message === \"string\" ? message : JSON.stringify(message)\n    });\n  }\n\n  return {\n    id: message.id || `msg-${index}`,\n    role:\n      message.role === \"data\"\n        ? \"system\"\n        : (message.role as \"user\" | \"assistant\" | \"system\") || \"user\",\n    parts: parts as UIMessage[\"parts\"]\n  };\n}\n\n/**\n * Legacy single message migration for backward compatibility\n */\nexport function migrateToUIMessage(message: MigratableMessage): UIMessage {\n  return autoTransformMessage(message as InputMessage);\n}\n\n/**\n * Automatic message transformer for arrays following the blog post pattern\n * @param messages - Array of messages in any format\n * @returns Array of UIMessages in v5 format\n */\nexport function autoTransformMessages(messages: unknown[]): UIMessage[] {\n  return messages.map((msg, i) => autoTransformMessage(msg as InputMessage, i));\n}\n\n/**\n * Migrates an array of messages to UIMessage format (legacy compatibility)\n * @param messages - Array of messages in old or new format\n * @returns Array of UIMessages in the new format\n */\nexport function migrateMessagesToUIFormat(\n  messages: MigratableMessage[]\n): UIMessage[] {\n  return autoTransformMessages(messages as InputMessage[]);\n}\n\n/**\n * Checks if any messages in an array need migration\n * @param messages - Array of messages to check\n * @returns true if any messages are not in proper UIMessage format\n */\nexport function needsMigration(messages: unknown[]): boolean {\n  return messages.some((message) => {\n    // If it's already a UIMessage, no migration needed\n    if (isUIMessage(message)) {\n      return false;\n    }\n\n    // Check for corrupt array format specifically\n    if (isCorruptArrayMessage(message)) {\n      return true;\n    }\n\n    // Check for legacy string format\n    if (isLegacyMessage(message)) {\n      return true;\n    }\n\n    // Any other format needs migration\n    return true;\n  });\n}\n\n/**\n * Analyzes the corruption types in a message array for debugging\n * @param messages - Array of messages to analyze\n * @returns Statistics about corruption types found\n */\nexport function analyzeCorruption(messages: unknown[]): {\n  total: number;\n  clean: number;\n  legacyString: number;\n  corruptArray: number;\n  unknown: number;\n  examples: {\n    legacyString?: unknown;\n    corruptArray?: unknown;\n    unknown?: unknown;\n  };\n} {\n  const stats = {\n    total: messages.length,\n    clean: 0,\n    legacyString: 0,\n    corruptArray: 0,\n    unknown: 0,\n    examples: {} as {\n      legacyString?: unknown;\n      corruptArray?: unknown;\n      unknown?: unknown;\n    }\n  };\n\n  for (const message of messages) {\n    if (isUIMessage(message)) {\n      stats.clean++;\n    } else if (isCorruptArrayMessage(message)) {\n      stats.corruptArray++;\n      if (!stats.examples.corruptArray) {\n        stats.examples.corruptArray = message;\n      }\n    } else if (isLegacyMessage(message)) {\n      stats.legacyString++;\n      if (!stats.examples.legacyString) {\n        stats.examples.legacyString = message;\n      }\n    } else {\n      stats.unknown++;\n      if (!stats.examples.unknown) {\n        stats.examples.unknown = message;\n      }\n    }\n  }\n\n  return stats;\n}\n"],"mappings":"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","names":[]}