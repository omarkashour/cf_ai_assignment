{"version":3,"sources":["../src/index.ts","../src/connection.ts"],"sourcesContent":["// rethink error handling, how to pass it on to the client\n// rethink oBC/oBR\n// push for durable.setState (in addition to connection.setState)\n\nimport { DurableObject } from \"cloudflare:workers\";\nimport { nanoid } from \"nanoid\";\n\nimport {\n  createLazyConnection,\n  HibernatingConnectionManager,\n  InMemoryConnectionManager\n} from \"./connection\";\n\nimport type { ConnectionManager } from \"./connection\";\nimport type {\n  Connection,\n  ConnectionContext,\n  ConnectionSetStateFn,\n  ConnectionState\n} from \"./types\";\n\nexport * from \"./types\";\n\nexport type WSMessage = ArrayBuffer | ArrayBufferView | string;\n\n// Let's cache the server namespace map\n// so we don't call it on every request\nconst serverMapCache = new WeakMap<\n  Record<string, unknown>,\n  Record<string, DurableObjectNamespace>\n>();\n\n/**\n * For a given server namespace, create a server with a name.\n */\nexport async function getServerByName<\n  Env,\n  T extends Server<Env>,\n  Props extends Record<string, unknown> = Record<string, unknown>\n>(\n  serverNamespace: DurableObjectNamespace<T>,\n  name: string,\n  options?: {\n    jurisdiction?: DurableObjectJurisdiction;\n    locationHint?: DurableObjectLocationHint;\n    props?: Props;\n  }\n): Promise<DurableObjectStub<T>> {\n  if (options?.jurisdiction) {\n    serverNamespace = serverNamespace.jurisdiction(options.jurisdiction);\n  }\n\n  const id = serverNamespace.idFromName(name);\n  const stub = serverNamespace.get(id, options);\n\n  // TODO: fix this to use RPC\n\n  const req = new Request(\n    \"http://dummy-example.cloudflare.com/cdn-cgi/partyserver/set-name/\"\n  );\n\n  req.headers.set(\"x-partykit-room\", name);\n\n  if (options?.props) {\n    req.headers.set(\"x-partykit-props\", JSON.stringify(options?.props));\n  }\n\n  // unfortunately we have to await this\n  await stub\n    .fetch(req)\n    // drain body\n    .then((res) => res.text())\n    .catch((e) => {\n      console.error(\"Could not set server name:\", e);\n    });\n\n  return stub;\n}\n\nfunction camelCaseToKebabCase(str: string): string {\n  // If string is all uppercase, convert to lowercase\n  if (str === str.toUpperCase() && str !== str.toLowerCase()) {\n    return str.toLowerCase().replace(/_/g, \"-\");\n  }\n\n  // Otherwise handle camelCase to kebab-case\n  let kebabified = str.replace(\n    /[A-Z]/g,\n    (letter) => `-${letter.toLowerCase()}`\n  );\n  kebabified = kebabified.startsWith(\"-\") ? kebabified.slice(1) : kebabified;\n  // Convert any remaining underscores to hyphens and remove trailing -'s\n  return kebabified.replace(/_/g, \"-\").replace(/-$/, \"\");\n}\nexport interface PartyServerOptions<Env, Props = Record<string, unknown>> {\n  prefix?: string;\n  jurisdiction?: DurableObjectJurisdiction;\n  locationHint?: DurableObjectLocationHint;\n  props?: Props;\n  onBeforeConnect?: (\n    req: Request,\n    lobby: {\n      party: keyof Env;\n      name: string;\n    }\n  ) => Response | Request | void | Promise<Response | Request | void>;\n  onBeforeRequest?: (\n    req: Request,\n    lobby: {\n      party: keyof Env;\n      name: string;\n    }\n  ) =>\n    | Response\n    | Request\n    | void\n    | Promise<Response | Request | undefined | void>;\n}\n/**\n * A utility function for PartyKit style routing.\n */\nexport async function routePartykitRequest<\n  Env = unknown,\n  T extends Server<Env> = Server<Env>,\n  Props extends Record<string, unknown> = Record<string, unknown>\n>(\n  req: Request,\n  env: Record<string, unknown>,\n  options?: PartyServerOptions<typeof env, Props>\n): Promise<Response | null> {\n  if (!serverMapCache.has(env)) {\n    serverMapCache.set(\n      env,\n      Object.entries(env).reduce((acc, [k, v]) => {\n        if (\n          v &&\n          typeof v === \"object\" &&\n          \"idFromName\" in v &&\n          typeof v.idFromName === \"function\"\n        ) {\n          // biome-ignore lint/performance/noAccumulatingSpread: dumb rule\n          Object.assign(acc, { [camelCaseToKebabCase(k)]: v });\n          return acc;\n        }\n        return acc;\n      }, {})\n    );\n  }\n  const map = serverMapCache.get(env) as unknown as Record<\n    string,\n    DurableObjectNamespace<T>\n  >;\n\n  const prefix = options?.prefix || \"parties\";\n  const prefixParts = prefix.split(\"/\");\n\n  const url = new URL(req.url);\n  const parts = url.pathname.split(\"/\").filter(Boolean); // Remove empty strings\n\n  // Check if the URL starts with the prefix\n  const prefixMatches = prefixParts.every(\n    (part, index) => parts[index] === part\n  );\n  if (!prefixMatches || parts.length < prefixParts.length + 2) {\n    return null;\n  }\n\n  const namespace = parts[prefixParts.length];\n  const name = parts[prefixParts.length + 1];\n\n  if (name && namespace) {\n    if (!map[namespace]) {\n      if (namespace === \"main\") {\n        console.warn(\n          \"You appear to be migrating a PartyKit project to PartyServer.\"\n        );\n        console.warn(`PartyServer doesn't have a \"main\" party by default. Try adding this to your PartySocket client:\\n \nparty: \"${camelCaseToKebabCase(Object.keys(map)[0])}\"`);\n      } else {\n        console.error(`The url ${req.url} does not match any server namespace. \nDid you forget to add a durable object binding to the class in your wrangler.toml?`);\n      }\n    }\n\n    let doNamespace = map[namespace];\n    if (options?.jurisdiction) {\n      doNamespace = doNamespace.jurisdiction(options.jurisdiction);\n    }\n\n    const id = doNamespace.idFromName(name);\n    const stub = doNamespace.get(id, options);\n\n    // const stub = await getServerByName(map[namespace], name, options); // TODO: fix this\n    // make a new request with additional headers\n\n    req = new Request(req);\n    req.headers.set(\"x-partykit-room\", name);\n    req.headers.set(\"x-partykit-namespace\", namespace);\n    if (options?.jurisdiction) {\n      req.headers.set(\"x-partykit-jurisdiction\", options.jurisdiction);\n    }\n\n    if (options?.props) {\n      req.headers.set(\"x-partykit-props\", JSON.stringify(options?.props));\n    }\n\n    if (req.headers.get(\"Upgrade\")?.toLowerCase() === \"websocket\") {\n      if (options?.onBeforeConnect) {\n        const reqOrRes = await options.onBeforeConnect(req, {\n          party: namespace,\n          name\n        });\n        if (reqOrRes instanceof Request) {\n          req = reqOrRes;\n        } else if (reqOrRes instanceof Response) {\n          return reqOrRes;\n        }\n      }\n    } else {\n      if (options?.onBeforeRequest) {\n        const reqOrRes = await options.onBeforeRequest(req, {\n          party: namespace,\n          name\n        });\n        if (reqOrRes instanceof Request) {\n          req = reqOrRes;\n        } else if (reqOrRes instanceof Response) {\n          return reqOrRes;\n        }\n      }\n    }\n\n    return stub.fetch(req);\n  } else {\n    return null;\n  }\n}\n\nexport class Server<\n  Env = unknown,\n  Props extends Record<string, unknown> = Record<string, unknown>\n> extends DurableObject<Env> {\n  static options = {\n    hibernate: false\n  };\n\n  #status: \"zero\" | \"starting\" | \"started\" = \"zero\";\n\n  #ParentClass: typeof Server = Object.getPrototypeOf(this).constructor;\n\n  #connectionManager: ConnectionManager = this.#ParentClass.options.hibernate\n    ? new HibernatingConnectionManager(this.ctx)\n    : new InMemoryConnectionManager();\n\n  /**\n   * Execute SQL queries against the Server's database\n   * @template T Type of the returned rows\n   * @param strings SQL query template strings\n   * @param values Values to be inserted into the query\n   * @returns Array of query results\n   */\n  sql<T = Record<string, string | number | boolean | null>>(\n    strings: TemplateStringsArray,\n    ...values: (string | number | boolean | null)[]\n  ) {\n    let query = \"\";\n    try {\n      // Construct the SQL query with placeholders\n      query = strings.reduce(\n        (acc, str, i) => acc + str + (i < values.length ? \"?\" : \"\"),\n        \"\"\n      );\n\n      // Execute the SQL query with the provided values\n      return [...this.ctx.storage.sql.exec(query, ...values)] as T[];\n    } catch (e) {\n      console.error(`failed to execute sql query: ${query}`, e);\n      throw this.onException(e);\n    }\n  }\n\n  // biome-ignore lint/complexity/noUselessConstructor: it's fine\n  constructor(ctx: DurableObjectState, env: Env) {\n    super(ctx, env);\n\n    // TODO: throw error if any of\n    // broadcast/getConnection/getConnections/getConnectionTags\n    // fetch/webSocketMessage/webSocketClose/webSocketError/alarm\n    // have been overridden\n  }\n\n  /**\n   * Handle incoming requests to the server.\n   */\n  async fetch(request: Request): Promise<Response> {\n    // Set the props in-mem if the request included them.\n    const props = request.headers.get(\"x-partykit-props\");\n    if (props) {\n      try {\n        this.#_props = JSON.parse(props);\n      } catch {\n        // This should never happen but log it just in case\n        console.error(\"Internal error parsing context props.\");\n      }\n    }\n\n    if (!this.#_name) {\n      // This is temporary while we solve https://github.com/cloudflare/workerd/issues/2240\n\n      // get namespace and room from headers\n      // const namespace = request.headers.get(\"x-partykit-namespace\");\n      const room = request.headers.get(\"x-partykit-room\");\n      if (\n        // !namespace ||\n        !room\n      ) {\n        throw new Error(`Missing namespace or room headers when connecting to ${this.#ParentClass.name}.\nDid you try connecting directly to this Durable Object? Try using getServerByName(namespace, id) instead.`);\n      }\n      await this.setName(room);\n    }\n\n    try {\n      const url = new URL(request.url);\n\n      // TODO: this is a hack to set the server name,\n      // it'll be replaced with RPC later\n      if (url.pathname === \"/cdn-cgi/partyserver/set-name/\") {\n        // we can just return a 200 for now\n        return Response.json({ ok: true });\n      }\n\n      if (request.headers.get(\"Upgrade\")?.toLowerCase() !== \"websocket\") {\n        return await this.onRequest(request);\n      } else {\n        // Create the websocket pair for the client\n        const { 0: clientWebSocket, 1: serverWebSocket } = new WebSocketPair();\n        let connectionId = url.searchParams.get(\"_pk\");\n        if (!connectionId) {\n          connectionId = nanoid();\n        }\n\n        let connection: Connection = Object.assign(serverWebSocket, {\n          id: connectionId,\n          server: this.name,\n          state: null as unknown as ConnectionState<unknown>,\n          setState<T = unknown>(setState: T | ConnectionSetStateFn<T>) {\n            let state: T;\n            if (setState instanceof Function) {\n              state = setState(this.state as ConnectionState<T>);\n            } else {\n              state = setState;\n            }\n\n            // TODO: deepFreeze object?\n            this.state = state as ConnectionState<T>;\n            return this.state;\n          }\n        });\n\n        const ctx = { request };\n\n        const tags = await this.getConnectionTags(connection, ctx);\n\n        // Accept the websocket connection\n        connection = this.#connectionManager.accept(connection, {\n          tags,\n          server: this.name\n        });\n\n        if (!this.#ParentClass.options.hibernate) {\n          this.#attachSocketEventHandlers(connection);\n        }\n        await this.onConnect(connection, ctx);\n\n        return new Response(null, { status: 101, webSocket: clientWebSocket });\n      }\n    } catch (err) {\n      console.error(\n        `Error in ${this.#ParentClass.name}:${this.name} fetch:`,\n        err\n      );\n      if (!(err instanceof Error)) throw err;\n      if (request.headers.get(\"Upgrade\") === \"websocket\") {\n        // Annoyingly, if we return an HTTP error in response to a WebSocket request, Chrome devtools\n        // won't show us the response body! So... let's send a WebSocket response with an error\n        // frame instead.\n        const pair = new WebSocketPair();\n        pair[1].accept();\n        pair[1].send(JSON.stringify({ error: err.stack }));\n        pair[1].close(1011, \"Uncaught exception during session setup\");\n        return new Response(null, { status: 101, webSocket: pair[0] });\n      } else {\n        return new Response(err.stack, { status: 500 });\n      }\n    }\n  }\n\n  async webSocketMessage(ws: WebSocket, message: WSMessage): Promise<void> {\n    const connection = createLazyConnection(ws);\n\n    // rehydrate the server name if it's woken up\n    await this.setName(connection.server);\n    // TODO: ^ this shouldn't be async\n\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n\n    return this.onMessage(connection, message);\n  }\n\n  async webSocketClose(\n    ws: WebSocket,\n    code: number,\n    reason: string,\n    wasClean: boolean\n  ): Promise<void> {\n    const connection = createLazyConnection(ws);\n\n    // rehydrate the server name if it's woken up\n    await this.setName(connection.server);\n    // TODO: ^ this shouldn't be async\n\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n    return this.onClose(connection, code, reason, wasClean);\n  }\n\n  async webSocketError(ws: WebSocket, error: unknown): Promise<void> {\n    const connection = createLazyConnection(ws);\n\n    // rehydrate the server name if it's woken up\n    await this.setName(connection.server);\n    // TODO: ^ this shouldn't be async\n\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n    return this.onError(connection, error);\n  }\n\n  async #initialize(): Promise<void> {\n    await this.ctx.blockConcurrencyWhile(async () => {\n      this.#status = \"starting\";\n      await this.onStart(this.#_props);\n      this.#status = \"started\";\n    });\n  }\n\n  #attachSocketEventHandlers(connection: Connection) {\n    const handleMessageFromClient = (event: MessageEvent) => {\n      this.onMessage(connection, event.data)?.catch<void>((e) => {\n        console.error(\"onMessage error:\", e);\n      });\n    };\n\n    const handleCloseFromClient = (event: CloseEvent) => {\n      connection.removeEventListener(\"message\", handleMessageFromClient);\n      connection.removeEventListener(\"close\", handleCloseFromClient);\n      this.onClose(connection, event.code, event.reason, event.wasClean)?.catch(\n        (e) => {\n          console.error(\"onClose error:\", e);\n        }\n      );\n    };\n\n    const handleErrorFromClient = (e: ErrorEvent) => {\n      connection.removeEventListener(\"message\", handleMessageFromClient);\n      connection.removeEventListener(\"error\", handleErrorFromClient);\n      this.onError(connection, e.error)?.catch((e) => {\n        console.error(\"onError error:\", e);\n      });\n    };\n\n    connection.addEventListener(\"close\", handleCloseFromClient);\n    connection.addEventListener(\"error\", handleErrorFromClient);\n    connection.addEventListener(\"message\", handleMessageFromClient);\n  }\n\n  // Public API\n\n  #_name: string | undefined;\n\n  #_longErrorAboutNameThrown = false;\n  /**\n   * The name for this server. Write-once-only.\n   */\n  get name(): string {\n    if (!this.#_name) {\n      if (!this.#_longErrorAboutNameThrown) {\n        this.#_longErrorAboutNameThrown = true;\n        throw new Error(\n          `Attempting to read .name on ${this.#ParentClass.name} before it was set. The name can be set by explicitly calling .setName(name) on the stub, or by using routePartyKitRequest(). This is a known issue and will be fixed soon. Follow https://github.com/cloudflare/workerd/issues/2240 for more updates.`\n        );\n      } else {\n        throw new Error(\n          `Attempting to read .name on ${this.#ParentClass.name} before it was set.`\n        );\n      }\n    }\n    return this.#_name;\n  }\n\n  // We won't have an await inside this function\n  // but it will be called remotely,\n  // so we need to mark it as async\n  async setName(name: string) {\n    if (!name) {\n      throw new Error(\"A name is required.\");\n    }\n    if (this.#_name && this.#_name !== name) {\n      throw new Error(\"This server already has a name.\");\n    }\n    this.#_name = name;\n\n    if (this.#status !== \"started\") {\n      await this.ctx.blockConcurrencyWhile(async () => {\n        await this.#initialize();\n      });\n    }\n  }\n\n  #sendMessageToConnection(connection: Connection, message: WSMessage): void {\n    try {\n      connection.send(message);\n    } catch (_e) {\n      // close connection\n      connection.close(1011, \"Unexpected error\");\n    }\n  }\n\n  /** Send a message to all connected clients, except connection ids listed in `without` */\n  broadcast(\n    msg: string | ArrayBuffer | ArrayBufferView,\n    without?: string[] | undefined\n  ): void {\n    for (const connection of this.#connectionManager.getConnections()) {\n      if (!without || !without.includes(connection.id)) {\n        this.#sendMessageToConnection(connection, msg);\n      }\n    }\n  }\n\n  /** Get a connection by connection id */\n  getConnection<TState = unknown>(id: string): Connection<TState> | undefined {\n    return this.#connectionManager.getConnection<TState>(id);\n  }\n\n  /**\n   * Get all connections. Optionally, you can provide a tag to filter returned connections.\n   * Use `Server#getConnectionTags` to tag the connection on connect.\n   */\n  getConnections<TState = unknown>(tag?: string): Iterable<Connection<TState>> {\n    return this.#connectionManager.getConnections<TState>(tag);\n  }\n\n  /**\n   * You can tag a connection to filter them in Server#getConnections.\n   * Each connection supports up to 9 tags, each tag max length is 256 characters.\n   */\n  getConnectionTags(\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n    connection: Connection,\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n    context: ConnectionContext\n  ): string[] | Promise<string[]> {\n    return [];\n  }\n\n  #_props?: Props;\n\n  // Implemented by the user\n\n  /**\n   * Called when the server is started for the first time.\n   */\n  // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n  onStart(props?: Props): void | Promise<void> {}\n\n  /**\n   * Called when a new connection is made to the server.\n   */\n  onConnect(\n    connection: Connection,\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n    ctx: ConnectionContext\n  ): void | Promise<void> {\n    console.log(\n      `Connection ${connection.id} connected to ${this.#ParentClass.name}:${this.name}`\n    );\n    // console.log(\n    //   `Implement onConnect on ${this.#ParentClass.name} to handle websocket connections.`\n    // );\n  }\n\n  /**\n   * Called when a message is received from a connection.\n   */\n  // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n  onMessage(connection: Connection, message: WSMessage): void | Promise<void> {\n    console.log(\n      `Received message on connection ${this.#ParentClass.name}:${connection.id}`\n    );\n    console.info(\n      `Implement onMessage on ${this.#ParentClass.name} to handle this message.`\n    );\n  }\n\n  /**\n   * Called when a connection is closed.\n   */\n  onClose(\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n    connection: Connection,\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n    code: number,\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n    reason: string,\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n    wasClean: boolean\n  ): void | Promise<void> {}\n\n  /**\n   * Called when an error occurs on a connection.\n   */\n  onError(connection: Connection, error: unknown): void | Promise<void> {\n    console.error(\n      `Error on connection ${connection.id} in ${this.#ParentClass.name}:${this.name}:`,\n      error\n    );\n    console.info(\n      `Implement onError on ${this.#ParentClass.name} to handle this error.`\n    );\n  }\n\n  /**\n   * Called when a request is made to the server.\n   */\n  onRequest(request: Request): Response | Promise<Response> {\n    // default to 404\n\n    console.warn(\n      `onRequest hasn't been implemented on ${this.#ParentClass.name}:${this.name} responding to ${request.url}`\n    );\n\n    return new Response(\"Not implemented\", { status: 404 });\n  }\n\n  /**\n   * Called when an exception occurs.\n   * @param error - The error that occurred.\n   */\n  onException(error: unknown): void | Promise<void> {\n    console.error(\n      `Exception in ${this.#ParentClass.name}:${this.name}:`,\n      error\n    );\n    console.info(\n      `Implement onException on ${this.#ParentClass.name} to handle this error.`\n    );\n  }\n\n  onAlarm(): void | Promise<void> {\n    console.log(\n      `Implement onAlarm on ${this.#ParentClass.name} to handle alarms.`\n    );\n  }\n\n  async alarm(): Promise<void> {\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n    await this.onAlarm();\n  }\n}\n","// Polyfill WebSocket status code constants for environments that don't have them\n// in order to support libraries that expect standards-compatible WebSocket\n// implementations (e.g. PartySocket)\n\nimport type {\n  Connection,\n  ConnectionSetStateFn,\n  ConnectionState\n} from \"./types\";\n\nif (!(\"OPEN\" in WebSocket)) {\n  const WebSocketStatus = {\n    // @ts-expect-error\n    CONNECTING: WebSocket.READY_STATE_CONNECTING,\n    // @ts-expect-error\n    OPEN: WebSocket.READY_STATE_OPEN,\n    // @ts-expect-error\n    CLOSING: WebSocket.READY_STATE_CLOSING,\n    // @ts-expect-error\n    CLOSED: WebSocket.READY_STATE_CLOSED\n  };\n\n  Object.assign(WebSocket, WebSocketStatus);\n  // @ts-expect-error\n  Object.assign(WebSocket.prototype, WebSocketStatus);\n}\n\n/**\n * Store both platform attachments and user attachments in different namespaces\n */\ntype ConnectionAttachments = {\n  __pk: {\n    id: string;\n    // TODO: remove this once we have\n    // durable object level setState\n    server: string;\n  };\n  __user?: unknown;\n};\n\n/**\n * Cache websocket attachments to avoid having to rehydrate them on every property access.\n */\nclass AttachmentCache {\n  #cache = new WeakMap<WebSocket, ConnectionAttachments>();\n\n  get(ws: WebSocket): ConnectionAttachments {\n    let attachment = this.#cache.get(ws);\n    if (!attachment) {\n      attachment = WebSocket.prototype.deserializeAttachment.call(\n        ws\n      ) as ConnectionAttachments;\n      if (attachment !== undefined) {\n        this.#cache.set(ws, attachment);\n      } else {\n        throw new Error(\n          \"Missing websocket attachment. This is most likely an issue in PartyServer, please open an issue at https://github.com/threepointone/partyserver/issues\"\n        );\n      }\n    }\n\n    return attachment;\n  }\n\n  set(ws: WebSocket, attachment: ConnectionAttachments) {\n    this.#cache.set(ws, attachment);\n    WebSocket.prototype.serializeAttachment.call(ws, attachment);\n  }\n}\n\nconst attachments = new AttachmentCache();\nconst connections = new WeakSet<Connection>();\nconst isWrapped = (ws: WebSocket): ws is Connection => {\n  return connections.has(ws as Connection);\n};\n\n/**\n * Wraps a WebSocket with Connection fields that rehydrate the\n * socket attachments lazily only when requested.\n */\nexport const createLazyConnection = (\n  ws: WebSocket | Connection\n): Connection => {\n  if (isWrapped(ws)) {\n    return ws;\n  }\n\n  // if state was set on the socket before initializing the connection,\n  // capture it here so we can persist it again\n  // biome-ignore lint/suspicious/noImplicitAnyLet: it's fine\n  let initialState;\n  if (\"state\" in ws) {\n    initialState = ws.state;\n    delete ws.state;\n  }\n\n  const connection = Object.defineProperties(ws, {\n    id: {\n      get() {\n        return attachments.get(ws).__pk.id;\n      }\n    },\n    server: {\n      get() {\n        return attachments.get(ws).__pk.server;\n      }\n    },\n    socket: {\n      get() {\n        return ws;\n      }\n    },\n    state: {\n      get() {\n        return ws.deserializeAttachment() as ConnectionState<unknown>;\n      }\n    },\n    setState: {\n      value: function setState<T>(setState: T | ConnectionSetStateFn<T>) {\n        let state: T;\n        if (setState instanceof Function) {\n          state = setState((this as Connection<T>).state);\n        } else {\n          state = setState;\n        }\n\n        ws.serializeAttachment(state);\n        return state as ConnectionState<T>;\n      }\n    },\n\n    deserializeAttachment: {\n      value: function deserializeAttachment<T = unknown>() {\n        const attachment = attachments.get(ws);\n        return (attachment.__user ?? null) as T;\n      }\n    },\n\n    serializeAttachment: {\n      value: function serializeAttachment<T = unknown>(attachment: T) {\n        const setting = {\n          ...attachments.get(ws),\n          __user: attachment ?? null\n        };\n\n        attachments.set(ws, setting);\n      }\n    }\n  }) as Connection;\n\n  if (initialState) {\n    connection.setState(initialState);\n  }\n\n  connections.add(connection);\n  return connection;\n};\n\nclass HibernatingConnectionIterator<T>\n  implements IterableIterator<Connection<T>>\n{\n  private index = 0;\n  private sockets: WebSocket[] | undefined;\n  constructor(\n    private state: DurableObjectState,\n    private tag?: string\n  ) {}\n\n  [Symbol.iterator](): IterableIterator<Connection<T>> {\n    return this;\n  }\n\n  next(): IteratorResult<Connection<T>, number | undefined> {\n    const sockets =\n      // biome-ignore lint/suspicious/noAssignInExpressions: it's fine\n      this.sockets ?? (this.sockets = this.state.getWebSockets(this.tag));\n\n    let socket: WebSocket;\n    // biome-ignore lint/suspicious/noAssignInExpressions: it's fine\n    while ((socket = sockets[this.index++])) {\n      // only yield open sockets to match non-hibernating behaviour\n      if (socket.readyState === WebSocket.READY_STATE_OPEN) {\n        const value = createLazyConnection(socket) as Connection<T>;\n        return { done: false, value };\n      }\n    }\n\n    // reached the end of the iteratee\n    return { done: true, value: undefined };\n  }\n}\n\nexport interface ConnectionManager {\n  getCount(): number;\n  getConnection<TState>(id: string): Connection<TState> | undefined;\n  getConnections<TState>(tag?: string): IterableIterator<Connection<TState>>;\n  accept(\n    connection: Connection,\n    options: { tags: string[]; server: string }\n  ): Connection;\n}\n\n/**\n * When not using hibernation, we track active connections manually.\n */\nexport class InMemoryConnectionManager<TState> implements ConnectionManager {\n  #connections: Map<string, Connection> = new Map();\n  tags: WeakMap<Connection, string[]> = new WeakMap();\n\n  getCount() {\n    return this.#connections.size;\n  }\n\n  getConnection<T = TState>(id: string) {\n    return this.#connections.get(id) as Connection<T> | undefined;\n  }\n\n  *getConnections<T = TState>(tag?: string): IterableIterator<Connection<T>> {\n    if (!tag) {\n      yield* this.#connections\n        .values()\n        .filter(\n          (c) => c.readyState === WebSocket.READY_STATE_OPEN\n        ) as IterableIterator<Connection<T>>;\n      return;\n    }\n\n    // simulate DurableObjectState.getWebSockets(tag) behaviour\n    for (const connection of this.#connections.values()) {\n      const connectionTags = this.tags.get(connection) ?? [];\n      if (connectionTags.includes(tag)) {\n        yield connection as Connection<T>;\n      }\n    }\n  }\n\n  accept(connection: Connection, options: { tags: string[]; server: string }) {\n    connection.accept();\n\n    this.#connections.set(connection.id, connection);\n    this.tags.set(connection, [\n      // make sure we have id tag\n      connection.id,\n      ...options.tags.filter((t) => t !== connection.id)\n    ]);\n\n    const removeConnection = () => {\n      this.#connections.delete(connection.id);\n      connection.removeEventListener(\"close\", removeConnection);\n      connection.removeEventListener(\"error\", removeConnection);\n    };\n    connection.addEventListener(\"close\", removeConnection);\n    connection.addEventListener(\"error\", removeConnection);\n\n    return connection;\n  }\n}\n\n/**\n * When opting into hibernation, the platform tracks connections for us.\n */\nexport class HibernatingConnectionManager<TState> implements ConnectionManager {\n  constructor(private controller: DurableObjectState) {}\n\n  getCount() {\n    return Number(this.controller.getWebSockets().length);\n  }\n\n  getConnection<T = TState>(id: string) {\n    // TODO: Should we cache the connections?\n    const sockets = this.controller.getWebSockets(id);\n    if (sockets.length === 0) return undefined;\n    if (sockets.length === 1)\n      return createLazyConnection(sockets[0]) as Connection<T>;\n\n    throw new Error(\n      `More than one connection found for id ${id}. Did you mean to use getConnections(tag) instead?`\n    );\n  }\n\n  getConnections<T = TState>(tag?: string | undefined) {\n    return new HibernatingConnectionIterator<T>(this.controller, tag);\n  }\n\n  accept(connection: Connection, options: { tags: string[]; server: string }) {\n    // dedupe tags in case user already provided id tag\n    const tags = [\n      connection.id,\n      ...options.tags.filter((t) => t !== connection.id)\n    ];\n\n    // validate tags against documented restrictions\n    // shttps://developers.cloudflare.com/durable-objects/api/hibernatable-websockets-api/#state-methods-for-websockets\n    if (tags.length > 10) {\n      throw new Error(\n        \"A connection can only have 10 tags, including the default id tag.\"\n      );\n    }\n\n    for (const tag of tags) {\n      if (typeof tag !== \"string\") {\n        throw new Error(`A connection tag must be a string. Received: ${tag}`);\n      }\n      if (tag === \"\") {\n        throw new Error(\"A connection tag must not be an empty string.\");\n      }\n      if (tag.length > 256) {\n        throw new Error(\"A connection tag must not exceed 256 characters\");\n      }\n    }\n\n    this.controller.acceptWebSocket(connection, tags);\n    connection.serializeAttachment({\n      __pk: {\n        id: connection.id,\n        server: options.server\n      },\n      __user: null\n    });\n\n    return createLazyConnection(connection);\n  }\n}\n"],"mappings":"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","names":["e"]}